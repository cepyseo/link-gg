/*!
  * Bootstrap v5.2.0 (https://getbootstrap.com/)
  * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).bootstrap = t() }(this, (function () { "use strict"; const e = "transitionend", t = e => { let t = e.getAttribute("data-bs-target"); if (!t || "#" === t) { let i = e.getAttribute("href"); if (!i || !i.includes("#") && !i.startsWith(".")) return null; i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`), t = i && "#" !== i ? i.trim() : null } return t }, i = e => { const i = t(e); return i && document.querySelector(i) ? i : null }, n = e => { const i = t(e); return i ? document.querySelector(i) : null }, s = t => { t.dispatchEvent(new Event(e)) }, r = e => !(!e || "object" != typeof e) && (void 0 !== e.jquery && (e = e[0]), void 0 !== e.nodeType), o = e => r(e) ? e.jquery ? e[0] : e : "string" == typeof e && e.length > 0 ? document.querySelector(e) : null, a = e => { if (!r(e) || 0 === e.getClientRects().length) return !1; const t = "visible" === getComputedStyle(e).getPropertyValue("visibility"), i = e.closest("details:not([open])"); if (!i) return t; if (i !== e) { const t = e.closest("summary"); if (t && t.parentNode !== i) return !1; if (null === t) return !1 } return t }, l = e => !e || e.nodeType !== Node.ELEMENT_NODE || (!!e.classList.contains("disabled") || (void 0 !== e.disabled ? e.disabled : e.hasAttribute("disabled") && "false" !== e.getAttribute("disabled"))), c = e => { if (!document.documentElement.attachShadow) return null; if ("function" == typeof e.getRootNode) { const t = e.getRootNode(); return t instanceof ShadowRoot ? t : null } return e instanceof ShadowRoot ? e : e.parentNode ? c(e.parentNode) : null }, d = () => { }, u = e => { e.offsetHeight }, h = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null, p = [], f = () => "rtl" === document.documentElement.dir, m = e => { var t; t = () => { const t = h(); if (t) { const i = e.NAME, n = t.fn[i]; t.fn[i] = e.jQueryInterface, t.fn[i].Constructor = e, t.fn[i].noConflict = () => (t.fn[i] = n, e.jQueryInterface) } }, "loading" === document.readyState ? (p.length || document.addEventListener("DOMContentLoaded", (() => { for (const e of p) e() })), p.push(t)) : t() }, g = e => { "function" == typeof e && e() }, v = (t, i, n = !0) => { if (!n) return void g(t); const r = (e => { if (!e) return 0; let { transitionDuration: t, transitionDelay: i } = window.getComputedStyle(e); const n = Number.parseFloat(t), s = Number.parseFloat(i); return n || s ? (t = t.split(",")[0], i = i.split(",")[0], 1e3 * (Number.parseFloat(t) + Number.parseFloat(i))) : 0 })(i) + 5; let o = !1; const a = ({ target: n }) => { n === i && (o = !0, i.removeEventListener(e, a), g(t)) }; i.addEventListener(e, a), setTimeout((() => { o || s(i) }), r) }, y = (e, t, i, n) => { const s = e.length; let r = e.indexOf(t); return -1 === r ? !i && n ? e[s - 1] : e[0] : (r += i ? 1 : -1, n && (r = (r + s) % s), e[Math.max(0, Math.min(r, s - 1))]) }, b = /[^.]*(?=\..*)\.|.*/, w = /\..*/, x = /::\d+$/, _ = {}; let T = 1; const E = { mouseenter: "mouseover", mouseleave: "mouseout" }, S = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]); function C(e, t) { return t && `${t}::${T++}` || e.uidEvent || T++ } function k(e) { const t = C(e); return e.uidEvent = t, _[t] = _[t] || {}, _[t] } function A(e, t, i = null) { return Object.values(e).find((e => e.callable === t && e.delegationSelector === i)) } function $(e, t, i) { const n = "string" == typeof t, s = n ? i : t || i; let r = L(e); return S.has(r) || (r = e), [n, s, r] } function M(e, t, i, n, s) { if ("string" != typeof t || !e) return; let [r, o, a] = $(t, i, n); if (t in E) { const e = e => function (t) { if (!t.relatedTarget || t.relatedTarget !== t.delegateTarget && !t.delegateTarget.contains(t.relatedTarget)) return e.call(this, t) }; o = e(o) } const l = k(e), c = l[a] || (l[a] = {}), d = A(c, o, r ? i : null); if (d) return void (d.oneOff = d.oneOff && s); const u = C(o, t.replace(b, "")), h = r ? function (e, t, i) { return function n(s) { const r = e.querySelectorAll(t); for (let { target: o } = s; o && o !== this; o = o.parentNode)for (const a of r) if (a === o) return z(s, { delegateTarget: o }), n.oneOff && O.off(e, s.type, t, i), i.apply(o, [s]) } }(e, i, o) : function (e, t) { return function i(n) { return z(n, { delegateTarget: e }), i.oneOff && O.off(e, n.type, t), t.apply(e, [n]) } }(e, o); h.delegationSelector = r ? i : null, h.callable = o, h.oneOff = s, h.uidEvent = u, c[u] = h, e.addEventListener(a, h, r) } function P(e, t, i, n, s) { const r = A(t[i], n, s); r && (e.removeEventListener(i, r, Boolean(s)), delete t[i][r.uidEvent]) } function I(e, t, i, n) { const s = t[i] || {}; for (const r of Object.keys(s)) if (r.includes(n)) { const n = s[r]; P(e, t, i, n.callable, n.delegationSelector) } } function L(e) { return e = e.replace(w, ""), E[e] || e } const O = { on(e, t, i, n) { M(e, t, i, n, !1) }, one(e, t, i, n) { M(e, t, i, n, !0) }, off(e, t, i, n) { if ("string" != typeof t || !e) return; const [s, r, o] = $(t, i, n), a = o !== t, l = k(e), c = l[o] || {}, d = t.startsWith("."); if (void 0 === r) { if (d) for (const i of Object.keys(l)) I(e, l, i, t.slice(1)); for (const i of Object.keys(c)) { const n = i.replace(x, ""); if (!a || t.includes(n)) { const t = c[i]; P(e, l, o, t.callable, t.delegationSelector) } } } else { if (!Object.keys(c).length) return; P(e, l, o, r, s ? i : null) } }, trigger(e, t, i) { if ("string" != typeof t || !e) return null; const n = h(); let s = null, r = !0, o = !0, a = !1; t !== L(t) && n && (s = n.Event(t, i), n(e).trigger(s), r = !s.isPropagationStopped(), o = !s.isImmediatePropagationStopped(), a = s.isDefaultPrevented()); let l = new Event(t, { bubbles: r, cancelable: !0 }); return l = z(l, i), a && l.preventDefault(), o && e.dispatchEvent(l), l.defaultPrevented && s && s.preventDefault(), l } }; function z(e, t) { for (const [i, n] of Object.entries(t || {})) try { e[i] = n } catch (t) { Object.defineProperty(e, i, { configurable: !0, get: () => n }) } return e } const D = new Map, N = { set(e, t, i) { D.has(e) || D.set(e, new Map); const n = D.get(e); n.has(t) || 0 === n.size ? n.set(t, i) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(n.keys())[0]}.`) }, get: (e, t) => D.has(e) && D.get(e).get(t) || null, remove(e, t) { if (!D.has(e)) return; const i = D.get(e); i.delete(t), 0 === i.size && D.delete(e) } }; function j(e) { if ("true" === e) return !0; if ("false" === e) return !1; if (e === Number(e).toString()) return Number(e); if ("" === e || "null" === e) return null; if ("string" != typeof e) return e; try { return JSON.parse(decodeURIComponent(e)) } catch (t) { return e } } function F(e) { return e.replace(/[A-Z]/g, (e => `-${e.toLowerCase()}`)) } const H = { setDataAttribute(e, t, i) { e.setAttribute(`data-bs-${F(t)}`, i) }, removeDataAttribute(e, t) { e.removeAttribute(`data-bs-${F(t)}`) }, getDataAttributes(e) { if (!e) return {}; const t = {}, i = Object.keys(e.dataset).filter((e => e.startsWith("bs") && !e.startsWith("bsConfig"))); for (const n of i) { let i = n.replace(/^bs/, ""); i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = j(e.dataset[n]) } return t }, getDataAttribute: (e, t) => j(e.getAttribute(`data-bs-${F(t)}`)) }; class q { static get Default() { return {} } static get DefaultType() { return {} } static get NAME() { throw new Error('You have to implement the static method "NAME", for each component!') } _getConfig(e) { return e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e } _configAfterMerge(e) { return e } _mergeConfigObj(e, t) { const i = r(t) ? H.getDataAttribute(t, "config") : {}; return { ...this.constructor.Default, ..."object" == typeof i ? i : {}, ...r(t) ? H.getDataAttributes(t) : {}, ..."object" == typeof e ? e : {} } } _typeCheckConfig(e, t = this.constructor.DefaultType) { for (const n of Object.keys(t)) { const s = t[n], o = e[n], a = r(o) ? "element" : null == (i = o) ? `${i}` : Object.prototype.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase(); if (!new RegExp(s).test(a)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${n}" provided type "${a}" but expected type "${s}".`) } var i } } class B extends q { constructor(e, t) { super(), (e = o(e)) && (this._element = e, this._config = this._getConfig(t), N.set(this._element, this.constructor.DATA_KEY, this)) } dispose() { N.remove(this._element, this.constructor.DATA_KEY), O.off(this._element, this.constructor.EVENT_KEY); for (const e of Object.getOwnPropertyNames(this)) this[e] = null } _queueCallback(e, t, i = !0) { v(e, t, i) } _getConfig(e) { return e = this._mergeConfigObj(e, this._element), e = this._configAfterMerge(e), this._typeCheckConfig(e), e } static getInstance(e) { return N.get(o(e), this.DATA_KEY) } static getOrCreateInstance(e, t = {}) { return this.getInstance(e) || new this(e, "object" == typeof t ? t : null) } static get VERSION() { return "5.2.0" } static get DATA_KEY() { return `bs.${this.NAME}` } static get EVENT_KEY() { return `.${this.DATA_KEY}` } static eventName(e) { return `${e}${this.EVENT_KEY}` } } const R = (e, t = "hide") => { const i = `click.dismiss${e.EVENT_KEY}`, s = e.NAME; O.on(document, i, `[data-bs-dismiss="${s}"]`, (function (i) { if (["A", "AREA"].includes(this.tagName) && i.preventDefault(), l(this)) return; const r = n(this) || this.closest(`.${s}`); e.getOrCreateInstance(r)[t]() })) }, W = ".bs.alert", Y = `close${W}`, X = `closed${W}`; class V extends B { static get NAME() { return "alert" } close() { if (O.trigger(this._element, Y).defaultPrevented) return; this._element.classList.remove("show"); const e = this._element.classList.contains("fade"); this._queueCallback((() => this._destroyElement()), this._element, e) } _destroyElement() { this._element.remove(), O.trigger(this._element, X), this.dispose() } static jQueryInterface(e) { return this.each((function () { const t = V.getOrCreateInstance(this); if ("string" == typeof e) { if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw new TypeError(`No method named "${e}"`); t[e](this) } })) } } R(V, "close"), m(V); const G = '[data-bs-toggle="button"]'; class U extends B { static get NAME() { return "button" } toggle() { this._element.setAttribute("aria-pressed", this._element.classList.toggle("active")) } static jQueryInterface(e) { return this.each((function () { const t = U.getOrCreateInstance(this); "toggle" === e && t[e]() })) } } O.on(document, "click.bs.button.data-api", G, (e => { e.preventDefault(); const t = e.target.closest(G); U.getOrCreateInstance(t).toggle() })), m(U); const Q = { find: (e, t = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(t, e)), findOne: (e, t = document.documentElement) => Element.prototype.querySelector.call(t, e), children: (e, t) => [].concat(...e.children).filter((e => e.matches(t))), parents(e, t) { const i = []; let n = e.parentNode.closest(t); for (; n;)i.push(n), n = n.parentNode.closest(t); return i }, prev(e, t) { let i = e.previousElementSibling; for (; i;) { if (i.matches(t)) return [i]; i = i.previousElementSibling } return [] }, next(e, t) { let i = e.nextElementSibling; for (; i;) { if (i.matches(t)) return [i]; i = i.nextElementSibling } return [] }, focusableChildren(e) { const t = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((e => `${e}:not([tabindex^="-"])`)).join(","); return this.find(t, e).filter((e => !l(e) && a(e))) } }, K = ".bs.swipe", Z = `touchstart${K}`, J = `touchmove${K}`, ee = `touchend${K}`, te = `pointerdown${K}`, ie = `pointerup${K}`, ne = { endCallback: null, leftCallback: null, rightCallback: null }, se = { endCallback: "(function|null)", leftCallback: "(function|null)", rightCallback: "(function|null)" }; class re extends q { constructor(e, t) { super(), this._element = e, e && re.isSupported() && (this._config = this._getConfig(t), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents()) } static get Default() { return ne } static get DefaultType() { return se } static get NAME() { return "swipe" } dispose() { O.off(this._element, K) } _start(e) { this._supportPointerEvents ? this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX) : this._deltaX = e.touches[0].clientX } _end(e) { this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX - this._deltaX), this._handleSwipe(), g(this._config.endCallback) } _move(e) { this._deltaX = e.touches && e.touches.length > 1 ? 0 : e.touches[0].clientX - this._deltaX } _handleSwipe() { const e = Math.abs(this._deltaX); if (e <= 40) return; const t = e / this._deltaX; this._deltaX = 0, t && g(t > 0 ? this._config.rightCallback : this._config.leftCallback) } _initEvents() { this._supportPointerEvents ? (O.on(this._element, te, (e => this._start(e))), O.on(this._element, ie, (e => this._end(e))), this._element.classList.add("pointer-event")) : (O.on(this._element, Z, (e => this._start(e))), O.on(this._element, J, (e => this._move(e))), O.on(this._element, ee, (e => this._end(e)))) } _eventIsPointerPenTouch(e) { return this._supportPointerEvents && ("pen" === e.pointerType || "touch" === e.pointerType) } static isSupported() { return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0 } } const oe = ".bs.carousel", ae = ".data-api", le = "next", ce = "prev", de = "left", ue = "right", he = `slide${oe}`, pe = `slid${oe}`, fe = `keydown${oe}`, me = `mouseenter${oe}`, ge = `mouseleave${oe}`, ve = `dragstart${oe}`, ye = `load${oe}${ae}`, be = `click${oe}${ae}`, we = "carousel", xe = "active", _e = ".active", Te = ".carousel-item", Ee = _e + Te, Se = { ArrowLeft: ue, ArrowRight: de }, Ce = { interval: 5e3, keyboard: !0, pause: "hover", ride: !1, touch: !0, wrap: !0 }, ke = { interval: "(number|boolean)", keyboard: "boolean", pause: "(string|boolean)", ride: "(boolean|string)", touch: "boolean", wrap: "boolean" }; class Ae extends B { constructor(e, t) { super(e, t), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = Q.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === we && this.cycle() } static get Default() { return Ce } static get DefaultType() { return ke } static get NAME() { return "carousel" } next() { this._slide(le) } nextWhenVisible() { !document.hidden && a(this._element) && this.next() } prev() { this._slide(ce) } pause() { this._isSliding && s(this._element), this._clearInterval() } cycle() { this._clearInterval(), this._updateInterval(), this._interval = setInterval((() => this.nextWhenVisible()), this._config.interval) } _maybeEnableCycle() { this._config.ride && (this._isSliding ? O.one(this._element, pe, (() => this.cycle())) : this.cycle()) } to(e) { const t = this._getItems(); if (e > t.length - 1 || e < 0) return; if (this._isSliding) return void O.one(this._element, pe, (() => this.to(e))); const i = this._getItemIndex(this._getActive()); if (i === e) return; const n = e > i ? le : ce; this._slide(n, t[e]) } dispose() { this._swipeHelper && this._swipeHelper.dispose(), super.dispose() } _configAfterMerge(e) { return e.defaultInterval = e.interval, e } _addEventListeners() { this._config.keyboard && O.on(this._element, fe, (e => this._keydown(e))), "hover" === this._config.pause && (O.on(this._element, me, (() => this.pause())), O.on(this._element, ge, (() => this._maybeEnableCycle()))), this._config.touch && re.isSupported() && this._addTouchEventListeners() } _addTouchEventListeners() { for (const e of Q.find(".carousel-item img", this._element)) O.on(e, ve, (e => e.preventDefault())); const e = { leftCallback: () => this._slide(this._directionToOrder(de)), rightCallback: () => this._slide(this._directionToOrder(ue)), endCallback: () => { "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout((() => this._maybeEnableCycle()), 500 + this._config.interval)) } }; this._swipeHelper = new re(this._element, e) } _keydown(e) { if (/input|textarea/i.test(e.target.tagName)) return; const t = Se[e.key]; t && (e.preventDefault(), this._slide(this._directionToOrder(t))) } _getItemIndex(e) { return this._getItems().indexOf(e) } _setActiveIndicatorElement(e) { if (!this._indicatorsElement) return; const t = Q.findOne(_e, this._indicatorsElement); t.classList.remove(xe), t.removeAttribute("aria-current"); const i = Q.findOne(`[data-bs-slide-to="${e}"]`, this._indicatorsElement); i && (i.classList.add(xe), i.setAttribute("aria-current", "true")) } _updateInterval() { const e = this._activeElement || this._getActive(); if (!e) return; const t = Number.parseInt(e.getAttribute("data-bs-interval"), 10); this._config.interval = t || this._config.defaultInterval } _slide(e, t = null) { if (this._isSliding) return; const i = this._getActive(), n = e === le, s = t || y(this._getItems(), i, n, this._config.wrap); if (s === i) return; const r = this._getItemIndex(s), o = t => O.trigger(this._element, t, { relatedTarget: s, direction: this._orderToDirection(e), from: this._getItemIndex(i), to: r }); if (o(he).defaultPrevented) return; if (!i || !s) return; const a = Boolean(this._interval); this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(r), this._activeElement = s; const l = n ? "carousel-item-start" : "carousel-item-end", c = n ? "carousel-item-next" : "carousel-item-prev"; s.classList.add(c), u(s), i.classList.add(l), s.classList.add(l); this._queueCallback((() => { s.classList.remove(l, c), s.classList.add(xe), i.classList.remove(xe, c, l), this._isSliding = !1, o(pe) }), i, this._isAnimated()), a && this.cycle() } _isAnimated() { return this._element.classList.contains("slide") } _getActive() { return Q.findOne(Ee, this._element) } _getItems() { return Q.find(Te, this._element) } _clearInterval() { this._interval && (clearInterval(this._interval), this._interval = null) } _directionToOrder(e) { return f() ? e === de ? ce : le : e === de ? le : ce } _orderToDirection(e) { return f() ? e === ce ? de : ue : e === ce ? ue : de } static jQueryInterface(e) { return this.each((function () { const t = Ae.getOrCreateInstance(this, e); if ("number" != typeof e) { if ("string" == typeof e) { if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw new TypeError(`No method named "${e}"`); t[e]() } } else t.to(e) })) } } O.on(document, be, "[data-bs-slide], [data-bs-slide-to]", (function (e) { const t = n(this); if (!t || !t.classList.contains(we)) return; e.preventDefault(); const i = Ae.getOrCreateInstance(t), s = this.getAttribute("data-bs-slide-to"); return s ? (i.to(s), void i._maybeEnableCycle()) : "next" === H.getDataAttribute(this, "slide") ? (i.next(), void i._maybeEnableCycle()) : (i.prev(), void i._maybeEnableCycle()) })), O.on(window, ye, (() => { const e = Q.find('[data-bs-ride="carousel"]'); for (const t of e) Ae.getOrCreateInstance(t) })), m(Ae); const $e = ".bs.collapse", Me = `show${$e}`, Pe = `shown${$e}`, Ie = `hide${$e}`, Le = `hidden${$e}`, Oe = `click${$e}.data-api`, ze = "show", De = "collapse", Ne = "collapsing", je = `:scope .${De} .${De}`, Fe = '[data-bs-toggle="collapse"]', He = { parent: null, toggle: !0 }, qe = { parent: "(null|element)", toggle: "boolean" }; class Be extends B { constructor(e, t) { super(e, t), this._isTransitioning = !1, this._triggerArray = []; const n = Q.find(Fe); for (const e of n) { const t = i(e), n = Q.find(t).filter((e => e === this._element)); null !== t && n.length && this._triggerArray.push(e) } this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle() } static get Default() { return He } static get DefaultType() { return qe } static get NAME() { return "collapse" } toggle() { this._isShown() ? this.hide() : this.show() } show() { if (this._isTransitioning || this._isShown()) return; let e = []; if (this._config.parent && (e = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((e => e !== this._element)).map((e => Be.getOrCreateInstance(e, { toggle: !1 })))), e.length && e[0]._isTransitioning) return; if (O.trigger(this._element, Me).defaultPrevented) return; for (const t of e) t.hide(); const t = this._getDimension(); this._element.classList.remove(De), this._element.classList.add(Ne), this._element.style[t] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0; const i = `scroll${t[0].toUpperCase() + t.slice(1)}`; this._queueCallback((() => { this._isTransitioning = !1, this._element.classList.remove(Ne), this._element.classList.add(De, ze), this._element.style[t] = "", O.trigger(this._element, Pe) }), this._element, !0), this._element.style[t] = `${this._element[i]}px` } hide() { if (this._isTransitioning || !this._isShown()) return; if (O.trigger(this._element, Ie).defaultPrevented) return; const e = this._getDimension(); this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, u(this._element), this._element.classList.add(Ne), this._element.classList.remove(De, ze); for (const e of this._triggerArray) { const t = n(e); t && !this._isShown(t) && this._addAriaAndCollapsedClass([e], !1) } this._isTransitioning = !0; this._element.style[e] = "", this._queueCallback((() => { this._isTransitioning = !1, this._element.classList.remove(Ne), this._element.classList.add(De), O.trigger(this._element, Le) }), this._element, !0) } _isShown(e = this._element) { return e.classList.contains(ze) } _configAfterMerge(e) { return e.toggle = Boolean(e.toggle), e.parent = o(e.parent), e } _getDimension() { return this._element.classList.contains("collapse-horizontal") ? "width" : "height" } _initializeChildren() { if (!this._config.parent) return; const e = this._getFirstLevelChildren(Fe); for (const t of e) { const e = n(t); e && this._addAriaAndCollapsedClass([t], this._isShown(e)) } } _getFirstLevelChildren(e) { const t = Q.find(je, this._config.parent); return Q.find(e, this._config.parent).filter((e => !t.includes(e))) } _addAriaAndCollapsedClass(e, t) { if (e.length) for (const i of e) i.classList.toggle("collapsed", !t), i.setAttribute("aria-expanded", t) } static jQueryInterface(e) { const t = {}; return "string" == typeof e && /show|hide/.test(e) && (t.toggle = !1), this.each((function () { const i = Be.getOrCreateInstance(this, t); if ("string" == typeof e) { if (void 0 === i[e]) throw new TypeError(`No method named "${e}"`); i[e]() } })) } } O.on(document, Oe, Fe, (function (e) { ("A" === e.target.tagName || e.delegateTarget && "A" === e.delegateTarget.tagName) && e.preventDefault(); const t = i(this), n = Q.find(t); for (const e of n) Be.getOrCreateInstance(e, { toggle: !1 }).toggle() })), m(Be); var Re = "top", We = "bottom", Ye = "right", Xe = "left", Ve = "auto", Ge = [Re, We, Ye, Xe], Ue = "start", Qe = "end", Ke = "clippingParents", Ze = "viewport", Je = "popper", et = "reference", tt = Ge.reduce((function (e, t) { return e.concat([t + "-" + Ue, t + "-" + Qe]) }), []), it = [].concat(Ge, [Ve]).reduce((function (e, t) { return e.concat([t, t + "-" + Ue, t + "-" + Qe]) }), []), nt = "beforeRead", st = "read", rt = "afterRead", ot = "beforeMain", at = "main", lt = "afterMain", ct = "beforeWrite", dt = "write", ut = "afterWrite", ht = [nt, st, rt, ot, at, lt, ct, dt, ut]; function pt(e) { return e ? (e.nodeName || "").toLowerCase() : null } function ft(e) { if (null == e) return window; if ("[object Window]" !== e.toString()) { var t = e.ownerDocument; return t && t.defaultView || window } return e } function mt(e) { return e instanceof ft(e).Element || e instanceof Element } function gt(e) { return e instanceof ft(e).HTMLElement || e instanceof HTMLElement } function vt(e) { return "undefined" != typeof ShadowRoot && (e instanceof ft(e).ShadowRoot || e instanceof ShadowRoot) } const yt = { name: "applyStyles", enabled: !0, phase: "write", fn: function (e) { var t = e.state; Object.keys(t.elements).forEach((function (e) { var i = t.styles[e] || {}, n = t.attributes[e] || {}, s = t.elements[e]; gt(s) && pt(s) && (Object.assign(s.style, i), Object.keys(n).forEach((function (e) { var t = n[e]; !1 === t ? s.removeAttribute(e) : s.setAttribute(e, !0 === t ? "" : t) }))) })) }, effect: function (e) { var t = e.state, i = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(t.elements.popper.style, i.popper), t.styles = i, t.elements.arrow && Object.assign(t.elements.arrow.style, i.arrow), function () { Object.keys(t.elements).forEach((function (e) { var n = t.elements[e], s = t.attributes[e] || {}, r = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : i[e]).reduce((function (e, t) { return e[t] = "", e }), {}); gt(n) && pt(n) && (Object.assign(n.style, r), Object.keys(s).forEach((function (e) { n.removeAttribute(e) }))) })) } }, requires: ["computeStyles"] }; function bt(e) { return e.split("-")[0] } var wt = Math.max, xt = Math.min, _t = Math.round; function Tt(e, t) { void 0 === t && (t = !1); var i = e.getBoundingClientRect(), n = 1, s = 1; if (gt(e) && t) { var r = e.offsetHeight, o = e.offsetWidth; o > 0 && (n = _t(i.width) / o || 1), r > 0 && (s = _t(i.height) / r || 1) } return { width: i.width / n, height: i.height / s, top: i.top / s, right: i.right / n, bottom: i.bottom / s, left: i.left / n, x: i.left / n, y: i.top / s } } function Et(e) { var t = Tt(e), i = e.offsetWidth, n = e.offsetHeight; return Math.abs(t.width - i) <= 1 && (i = t.width), Math.abs(t.height - n) <= 1 && (n = t.height), { x: e.offsetLeft, y: e.offsetTop, width: i, height: n } } function St(e, t) { var i = t.getRootNode && t.getRootNode(); if (e.contains(t)) return !0; if (i && vt(i)) { var n = t; do { if (n && e.isSameNode(n)) return !0; n = n.parentNode || n.host } while (n) } return !1 } function Ct(e) { return ft(e).getComputedStyle(e) } function kt(e) { return ["table", "td", "th"].indexOf(pt(e)) >= 0 } function At(e) { return ((mt(e) ? e.ownerDocument : e.document) || window.document).documentElement } function $t(e) { return "html" === pt(e) ? e : e.assignedSlot || e.parentNode || (vt(e) ? e.host : null) || At(e) } function Mt(e) { return gt(e) && "fixed" !== Ct(e).position ? e.offsetParent : null } function Pt(e) { for (var t = ft(e), i = Mt(e); i && kt(i) && "static" === Ct(i).position;)i = Mt(i); return i && ("html" === pt(i) || "body" === pt(i) && "static" === Ct(i).position) ? t : i || function (e) { var t = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox"); if (-1 !== navigator.userAgent.indexOf("Trident") && gt(e) && "fixed" === Ct(e).position) return null; var i = $t(e); for (vt(i) && (i = i.host); gt(i) && ["html", "body"].indexOf(pt(i)) < 0;) { var n = Ct(i); if ("none" !== n.transform || "none" !== n.perspective || "paint" === n.contain || -1 !== ["transform", "perspective"].indexOf(n.willChange) || t && "filter" === n.willChange || t && n.filter && "none" !== n.filter) return i; i = i.parentNode } return null }(e) || t } function It(e) { return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y" } function Lt(e, t, i) { return wt(e, xt(t, i)) } function Ot(e) { return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, e) } function zt(e, t) { return t.reduce((function (t, i) { return t[i] = e, t }), {}) } const Dt = { name: "arrow", enabled: !0, phase: "main", fn: function (e) { var t, i = e.state, n = e.name, s = e.options, r = i.elements.arrow, o = i.modifiersData.popperOffsets, a = bt(i.placement), l = It(a), c = [Xe, Ye].indexOf(a) >= 0 ? "height" : "width"; if (r && o) { var d = function (e, t) { return Ot("number" != typeof (e = "function" == typeof e ? e(Object.assign({}, t.rects, { placement: t.placement })) : e) ? e : zt(e, Ge)) }(s.padding, i), u = Et(r), h = "y" === l ? Re : Xe, p = "y" === l ? We : Ye, f = i.rects.reference[c] + i.rects.reference[l] - o[l] - i.rects.popper[c], m = o[l] - i.rects.reference[l], g = Pt(r), v = g ? "y" === l ? g.clientHeight || 0 : g.clientWidth || 0 : 0, y = f / 2 - m / 2, b = d[h], w = v - u[c] - d[p], x = v / 2 - u[c] / 2 + y, _ = Lt(b, x, w), T = l; i.modifiersData[n] = ((t = {})[T] = _, t.centerOffset = _ - x, t) } }, effect: function (e) { var t = e.state, i = e.options.element, n = void 0 === i ? "[data-popper-arrow]" : i; null != n && ("string" != typeof n || (n = t.elements.popper.querySelector(n))) && St(t.elements.popper, n) && (t.elements.arrow = n) }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }; function Nt(e) { return e.split("-")[1] } var jt = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function Ft(e) { var t, i = e.popper, n = e.popperRect, s = e.placement, r = e.variation, o = e.offsets, a = e.position, l = e.gpuAcceleration, c = e.adaptive, d = e.roundOffsets, u = e.isFixed, h = o.x, p = void 0 === h ? 0 : h, f = o.y, m = void 0 === f ? 0 : f, g = "function" == typeof d ? d({ x: p, y: m }) : { x: p, y: m }; p = g.x, m = g.y; var v = o.hasOwnProperty("x"), y = o.hasOwnProperty("y"), b = Xe, w = Re, x = window; if (c) { var _ = Pt(i), T = "clientHeight", E = "clientWidth"; if (_ === ft(i) && "static" !== Ct(_ = At(i)).position && "absolute" === a && (T = "scrollHeight", E = "scrollWidth"), s === Re || (s === Xe || s === Ye) && r === Qe) w = We, m -= (u && _ === x && x.visualViewport ? x.visualViewport.height : _[T]) - n.height, m *= l ? 1 : -1; if (s === Xe || (s === Re || s === We) && r === Qe) b = Ye, p -= (u && _ === x && x.visualViewport ? x.visualViewport.width : _[E]) - n.width, p *= l ? 1 : -1 } var S, C = Object.assign({ position: a }, c && jt), k = !0 === d ? function (e) { var t = e.x, i = e.y, n = window.devicePixelRatio || 1; return { x: _t(t * n) / n || 0, y: _t(i * n) / n || 0 } }({ x: p, y: m }) : { x: p, y: m }; return p = k.x, m = k.y, l ? Object.assign({}, C, ((S = {})[w] = y ? "0" : "", S[b] = v ? "0" : "", S.transform = (x.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + m + "px)" : "translate3d(" + p + "px, " + m + "px, 0)", S)) : Object.assign({}, C, ((t = {})[w] = y ? m + "px" : "", t[b] = v ? p + "px" : "", t.transform = "", t)) } const Ht = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: function (e) { var t = e.state, i = e.options, n = i.gpuAcceleration, s = void 0 === n || n, r = i.adaptive, o = void 0 === r || r, a = i.roundOffsets, l = void 0 === a || a, c = { placement: bt(t.placement), variation: Nt(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: s, isFixed: "fixed" === t.options.strategy }; null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, Ft(Object.assign({}, c, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: o, roundOffsets: l })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, Ft(Object.assign({}, c, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-placement": t.placement }) }, data: {} }; var qt = { passive: !0 }; const Bt = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: function (e) { var t = e.state, i = e.instance, n = e.options, s = n.scroll, r = void 0 === s || s, o = n.resize, a = void 0 === o || o, l = ft(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper); return r && c.forEach((function (e) { e.addEventListener("scroll", i.update, qt) })), a && l.addEventListener("resize", i.update, qt), function () { r && c.forEach((function (e) { e.removeEventListener("scroll", i.update, qt) })), a && l.removeEventListener("resize", i.update, qt) } }, data: {} }; var Rt = { left: "right", right: "left", bottom: "top", top: "bottom" }; function Wt(e) { return e.replace(/left|right|bottom|top/g, (function (e) { return Rt[e] })) } var Yt = { start: "end", end: "start" }; function Xt(e) { return e.replace(/start|end/g, (function (e) { return Yt[e] })) } function Vt(e) { var t = ft(e); return { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset } } function Gt(e) { return Tt(At(e)).left + Vt(e).scrollLeft } function Ut(e) { var t = Ct(e), i = t.overflow, n = t.overflowX, s = t.overflowY; return /auto|scroll|overlay|hidden/.test(i + s + n) } function Qt(e) { return ["html", "body", "#document"].indexOf(pt(e)) >= 0 ? e.ownerDocument.body : gt(e) && Ut(e) ? e : Qt($t(e)) } function Kt(e, t) { var i; void 0 === t && (t = []); var n = Qt(e), s = n === (null == (i = e.ownerDocument) ? void 0 : i.body), r = ft(n), o = s ? [r].concat(r.visualViewport || [], Ut(n) ? n : []) : n, a = t.concat(o); return s ? a : a.concat(Kt($t(o))) } function Zt(e) { return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height }) } function Jt(e, t) { return t === Ze ? Zt(function (e) { var t = ft(e), i = At(e), n = t.visualViewport, s = i.clientWidth, r = i.clientHeight, o = 0, a = 0; return n && (s = n.width, r = n.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = n.offsetLeft, a = n.offsetTop)), { width: s, height: r, x: o + Gt(e), y: a } }(e)) : mt(t) ? function (e) { var t = Tt(e); return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t }(t) : Zt(function (e) { var t, i = At(e), n = Vt(e), s = null == (t = e.ownerDocument) ? void 0 : t.body, r = wt(i.scrollWidth, i.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0), o = wt(i.scrollHeight, i.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0), a = -n.scrollLeft + Gt(e), l = -n.scrollTop; return "rtl" === Ct(s || i).direction && (a += wt(i.clientWidth, s ? s.clientWidth : 0) - r), { width: r, height: o, x: a, y: l } }(At(e))) } function ei(e, t, i) { var n = "clippingParents" === t ? function (e) { var t = Kt($t(e)), i = ["absolute", "fixed"].indexOf(Ct(e).position) >= 0 && gt(e) ? Pt(e) : e; return mt(i) ? t.filter((function (e) { return mt(e) && St(e, i) && "body" !== pt(e) })) : [] }(e) : [].concat(t), s = [].concat(n, [i]), r = s[0], o = s.reduce((function (t, i) { var n = Jt(e, i); return t.top = wt(n.top, t.top), t.right = xt(n.right, t.right), t.bottom = xt(n.bottom, t.bottom), t.left = wt(n.left, t.left), t }), Jt(e, r)); return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o } function ti(e) { var t, i = e.reference, n = e.element, s = e.placement, r = s ? bt(s) : null, o = s ? Nt(s) : null, a = i.x + i.width / 2 - n.width / 2, l = i.y + i.height / 2 - n.height / 2; switch (r) { case Re: t = { x: a, y: i.y - n.height }; break; case We: t = { x: a, y: i.y + i.height }; break; case Ye: t = { x: i.x + i.width, y: l }; break; case Xe: t = { x: i.x - n.width, y: l }; break; default: t = { x: i.x, y: i.y } }var c = r ? It(r) : null; if (null != c) { var d = "y" === c ? "height" : "width"; switch (o) { case Ue: t[c] = t[c] - (i[d] / 2 - n[d] / 2); break; case Qe: t[c] = t[c] + (i[d] / 2 - n[d] / 2) } } return t } function ii(e, t) { void 0 === t && (t = {}); var i = t, n = i.placement, s = void 0 === n ? e.placement : n, r = i.boundary, o = void 0 === r ? Ke : r, a = i.rootBoundary, l = void 0 === a ? Ze : a, c = i.elementContext, d = void 0 === c ? Je : c, u = i.altBoundary, h = void 0 !== u && u, p = i.padding, f = void 0 === p ? 0 : p, m = Ot("number" != typeof f ? f : zt(f, Ge)), g = d === Je ? et : Je, v = e.rects.popper, y = e.elements[h ? g : d], b = ei(mt(y) ? y : y.contextElement || At(e.elements.popper), o, l), w = Tt(e.elements.reference), x = ti({ reference: w, element: v, strategy: "absolute", placement: s }), _ = Zt(Object.assign({}, v, x)), T = d === Je ? _ : w, E = { top: b.top - T.top + m.top, bottom: T.bottom - b.bottom + m.bottom, left: b.left - T.left + m.left, right: T.right - b.right + m.right }, S = e.modifiersData.offset; if (d === Je && S) { var C = S[s]; Object.keys(E).forEach((function (e) { var t = [Ye, We].indexOf(e) >= 0 ? 1 : -1, i = [Re, We].indexOf(e) >= 0 ? "y" : "x"; E[e] += C[i] * t })) } return E } function ni(e, t) { void 0 === t && (t = {}); var i = t, n = i.placement, s = i.boundary, r = i.rootBoundary, o = i.padding, a = i.flipVariations, l = i.allowedAutoPlacements, c = void 0 === l ? it : l, d = Nt(n), u = d ? a ? tt : tt.filter((function (e) { return Nt(e) === d })) : Ge, h = u.filter((function (e) { return c.indexOf(e) >= 0 })); 0 === h.length && (h = u); var p = h.reduce((function (t, i) { return t[i] = ii(e, { placement: i, boundary: s, rootBoundary: r, padding: o })[bt(i)], t }), {}); return Object.keys(p).sort((function (e, t) { return p[e] - p[t] })) } const si = { name: "flip", enabled: !0, phase: "main", fn: function (e) { var t = e.state, i = e.options, n = e.name; if (!t.modifiersData[n]._skip) { for (var s = i.mainAxis, r = void 0 === s || s, o = i.altAxis, a = void 0 === o || o, l = i.fallbackPlacements, c = i.padding, d = i.boundary, u = i.rootBoundary, h = i.altBoundary, p = i.flipVariations, f = void 0 === p || p, m = i.allowedAutoPlacements, g = t.options.placement, v = bt(g), y = l || (v === g || !f ? [Wt(g)] : function (e) { if (bt(e) === Ve) return []; var t = Wt(e); return [Xt(e), t, Xt(t)] }(g)), b = [g].concat(y).reduce((function (e, i) { return e.concat(bt(i) === Ve ? ni(t, { placement: i, boundary: d, rootBoundary: u, padding: c, flipVariations: f, allowedAutoPlacements: m }) : i) }), []), w = t.rects.reference, x = t.rects.popper, _ = new Map, T = !0, E = b[0], S = 0; S < b.length; S++) { var C = b[S], k = bt(C), A = Nt(C) === Ue, $ = [Re, We].indexOf(k) >= 0, M = $ ? "width" : "height", P = ii(t, { placement: C, boundary: d, rootBoundary: u, altBoundary: h, padding: c }), I = $ ? A ? Ye : Xe : A ? We : Re; w[M] > x[M] && (I = Wt(I)); var L = Wt(I), O = []; if (r && O.push(P[k] <= 0), a && O.push(P[I] <= 0, P[L] <= 0), O.every((function (e) { return e }))) { E = C, T = !1; break } _.set(C, O) } if (T) for (var z = function (e) { var t = b.find((function (t) { var i = _.get(t); if (i) return i.slice(0, e).every((function (e) { return e })) })); if (t) return E = t, "break" }, D = f ? 3 : 1; D > 0; D--) { if ("break" === z(D)) break } t.placement !== E && (t.modifiersData[n]._skip = !0, t.placement = E, t.reset = !0) } }, requiresIfExists: ["offset"], data: { _skip: !1 } }; function ri(e, t, i) { return void 0 === i && (i = { x: 0, y: 0 }), { top: e.top - t.height - i.y, right: e.right - t.width + i.x, bottom: e.bottom - t.height + i.y, left: e.left - t.width - i.x } } function oi(e) { return [Re, Ye, We, Xe].some((function (t) { return e[t] >= 0 })) } const ai = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: function (e) { var t = e.state, i = e.name, n = t.rects.reference, s = t.rects.popper, r = t.modifiersData.preventOverflow, o = ii(t, { elementContext: "reference" }), a = ii(t, { altBoundary: !0 }), l = ri(o, n), c = ri(a, s, r), d = oi(l), u = oi(c); t.modifiersData[i] = { referenceClippingOffsets: l, popperEscapeOffsets: c, isReferenceHidden: d, hasPopperEscaped: u }, t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-reference-hidden": d, "data-popper-escaped": u }) } }; const li = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: function (e) { var t = e.state, i = e.options, n = e.name, s = i.offset, r = void 0 === s ? [0, 0] : s, o = it.reduce((function (e, i) { return e[i] = function (e, t, i) { var n = bt(e), s = [Xe, Re].indexOf(n) >= 0 ? -1 : 1, r = "function" == typeof i ? i(Object.assign({}, t, { placement: e })) : i, o = r[0], a = r[1]; return o = o || 0, a = (a || 0) * s, [Xe, Ye].indexOf(n) >= 0 ? { x: a, y: o } : { x: o, y: a } }(i, t.rects, r), e }), {}), a = o[t.placement], l = a.x, c = a.y; null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[n] = o } }; const ci = { name: "popperOffsets", enabled: !0, phase: "read", fn: function (e) { var t = e.state, i = e.name; t.modifiersData[i] = ti({ reference: t.rects.reference, element: t.rects.popper, strategy: "absolute", placement: t.placement }) }, data: {} }; const di = { name: "preventOverflow", enabled: !0, phase: "main", fn: function (e) { var t = e.state, i = e.options, n = e.name, s = i.mainAxis, r = void 0 === s || s, o = i.altAxis, a = void 0 !== o && o, l = i.boundary, c = i.rootBoundary, d = i.altBoundary, u = i.padding, h = i.tether, p = void 0 === h || h, f = i.tetherOffset, m = void 0 === f ? 0 : f, g = ii(t, { boundary: l, rootBoundary: c, padding: u, altBoundary: d }), v = bt(t.placement), y = Nt(t.placement), b = !y, w = It(v), x = "x" === w ? "y" : "x", _ = t.modifiersData.popperOffsets, T = t.rects.reference, E = t.rects.popper, S = "function" == typeof m ? m(Object.assign({}, t.rects, { placement: t.placement })) : m, C = "number" == typeof S ? { mainAxis: S, altAxis: S } : Object.assign({ mainAxis: 0, altAxis: 0 }, S), k = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, A = { x: 0, y: 0 }; if (_) { if (r) { var $, M = "y" === w ? Re : Xe, P = "y" === w ? We : Ye, I = "y" === w ? "height" : "width", L = _[w], O = L + g[M], z = L - g[P], D = p ? -E[I] / 2 : 0, N = y === Ue ? T[I] : E[I], j = y === Ue ? -E[I] : -T[I], F = t.elements.arrow, H = p && F ? Et(F) : { width: 0, height: 0 }, q = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, B = q[M], R = q[P], W = Lt(0, T[I], H[I]), Y = b ? T[I] / 2 - D - W - B - C.mainAxis : N - W - B - C.mainAxis, X = b ? -T[I] / 2 + D + W + R + C.mainAxis : j + W + R + C.mainAxis, V = t.elements.arrow && Pt(t.elements.arrow), G = V ? "y" === w ? V.clientTop || 0 : V.clientLeft || 0 : 0, U = null != ($ = null == k ? void 0 : k[w]) ? $ : 0, Q = L + X - U, K = Lt(p ? xt(O, L + Y - U - G) : O, L, p ? wt(z, Q) : z); _[w] = K, A[w] = K - L } if (a) { var Z, J = "x" === w ? Re : Xe, ee = "x" === w ? We : Ye, te = _[x], ie = "y" === x ? "height" : "width", ne = te + g[J], se = te - g[ee], re = -1 !== [Re, Xe].indexOf(v), oe = null != (Z = null == k ? void 0 : k[x]) ? Z : 0, ae = re ? ne : te - T[ie] - E[ie] - oe + C.altAxis, le = re ? te + T[ie] + E[ie] - oe - C.altAxis : se, ce = p && re ? function (e, t, i) { var n = Lt(e, t, i); return n > i ? i : n }(ae, te, le) : Lt(p ? ae : ne, te, p ? le : se); _[x] = ce, A[x] = ce - te } t.modifiersData[n] = A } }, requiresIfExists: ["offset"] }; function ui(e, t, i) { void 0 === i && (i = !1); var n, s, r = gt(t), o = gt(t) && function (e) { var t = e.getBoundingClientRect(), i = _t(t.width) / e.offsetWidth || 1, n = _t(t.height) / e.offsetHeight || 1; return 1 !== i || 1 !== n }(t), a = At(t), l = Tt(e, o), c = { scrollLeft: 0, scrollTop: 0 }, d = { x: 0, y: 0 }; return (r || !r && !i) && (("body" !== pt(t) || Ut(a)) && (c = (n = t) !== ft(n) && gt(n) ? { scrollLeft: (s = n).scrollLeft, scrollTop: s.scrollTop } : Vt(n)), gt(t) ? ((d = Tt(t, !0)).x += t.clientLeft, d.y += t.clientTop) : a && (d.x = Gt(a))), { x: l.left + c.scrollLeft - d.x, y: l.top + c.scrollTop - d.y, width: l.width, height: l.height } } function hi(e) { var t = new Map, i = new Set, n = []; function s(e) { i.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach((function (e) { if (!i.has(e)) { var n = t.get(e); n && s(n) } })), n.push(e) } return e.forEach((function (e) { t.set(e.name, e) })), e.forEach((function (e) { i.has(e.name) || s(e) })), n } var pi = { placement: "bottom", modifiers: [], strategy: "absolute" }; function fi() { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; return !t.some((function (e) { return !(e && "function" == typeof e.getBoundingClientRect) })) } function mi(e) { void 0 === e && (e = {}); var t = e, i = t.defaultModifiers, n = void 0 === i ? [] : i, s = t.defaultOptions, r = void 0 === s ? pi : s; return function (e, t, i) { void 0 === i && (i = r); var s, o, a = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, pi, r), modifiersData: {}, elements: { reference: e, popper: t }, attributes: {}, styles: {} }, l = [], c = !1, d = { state: a, setOptions: function (i) { var s = "function" == typeof i ? i(a.options) : i; u(), a.options = Object.assign({}, r, a.options, s), a.scrollParents = { reference: mt(e) ? Kt(e) : e.contextElement ? Kt(e.contextElement) : [], popper: Kt(t) }; var o, c, h = function (e) { var t = hi(e); return ht.reduce((function (e, i) { return e.concat(t.filter((function (e) { return e.phase === i }))) }), []) }((o = [].concat(n, a.options.modifiers), c = o.reduce((function (e, t) { var i = e[t.name]; return e[t.name] = i ? Object.assign({}, i, t, { options: Object.assign({}, i.options, t.options), data: Object.assign({}, i.data, t.data) }) : t, e }), {}), Object.keys(c).map((function (e) { return c[e] })))); return a.orderedModifiers = h.filter((function (e) { return e.enabled })), a.orderedModifiers.forEach((function (e) { var t = e.name, i = e.options, n = void 0 === i ? {} : i, s = e.effect; if ("function" == typeof s) { var r = s({ state: a, name: t, instance: d, options: n }), o = function () { }; l.push(r || o) } })), d.update() }, forceUpdate: function () { if (!c) { var e = a.elements, t = e.reference, i = e.popper; if (fi(t, i)) { a.rects = { reference: ui(t, Pt(i), "fixed" === a.options.strategy), popper: Et(i) }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach((function (e) { return a.modifiersData[e.name] = Object.assign({}, e.data) })); for (var n = 0; n < a.orderedModifiers.length; n++)if (!0 !== a.reset) { var s = a.orderedModifiers[n], r = s.fn, o = s.options, l = void 0 === o ? {} : o, u = s.name; "function" == typeof r && (a = r({ state: a, options: l, name: u, instance: d }) || a) } else a.reset = !1, n = -1 } } }, update: (s = function () { return new Promise((function (e) { d.forceUpdate(), e(a) })) }, function () { return o || (o = new Promise((function (e) { Promise.resolve().then((function () { o = void 0, e(s()) })) }))), o }), destroy: function () { u(), c = !0 } }; if (!fi(e, t)) return d; function u() { l.forEach((function (e) { return e() })), l = [] } return d.setOptions(i).then((function (e) { !c && i.onFirstUpdate && i.onFirstUpdate(e) })), d } } var gi = mi(), vi = mi({ defaultModifiers: [Bt, ci, Ht, yt] }), yi = mi({ defaultModifiers: [Bt, ci, Ht, yt, li, si, di, Dt, ai] }); const bi = Object.freeze(Object.defineProperty({ __proto__: null, popperGenerator: mi, detectOverflow: ii, createPopperBase: gi, createPopper: yi, createPopperLite: vi, top: Re, bottom: We, right: Ye, left: Xe, auto: Ve, basePlacements: Ge, start: Ue, end: Qe, clippingParents: Ke, viewport: Ze, popper: Je, reference: et, variationPlacements: tt, placements: it, beforeRead: nt, read: st, afterRead: rt, beforeMain: ot, main: at, afterMain: lt, beforeWrite: ct, write: dt, afterWrite: ut, modifierPhases: ht, applyStyles: yt, arrow: Dt, computeStyles: Ht, eventListeners: Bt, flip: si, hide: ai, offset: li, popperOffsets: ci, preventOverflow: di }, Symbol.toStringTag, { value: "Module" })), wi = "dropdown", xi = ".bs.dropdown", _i = ".data-api", Ti = "ArrowUp", Ei = "ArrowDown", Si = `hide${xi}`, Ci = `hidden${xi}`, ki = `show${xi}`, Ai = `shown${xi}`, $i = `click${xi}${_i}`, Mi = `keydown${xi}${_i}`, Pi = `keyup${xi}${_i}`, Ii = "show", Li = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)', Oi = `${Li}.${Ii}`, zi = ".dropdown-menu", Di = f() ? "top-end" : "top-start", Ni = f() ? "top-start" : "top-end", ji = f() ? "bottom-end" : "bottom-start", Fi = f() ? "bottom-start" : "bottom-end", Hi = f() ? "left-start" : "right-start", qi = f() ? "right-start" : "left-start", Bi = { autoClose: !0, boundary: "clippingParents", display: "dynamic", offset: [0, 2], popperConfig: null, reference: "toggle" }, Ri = { autoClose: "(boolean|string)", boundary: "(string|element)", display: "string", offset: "(array|string|function)", popperConfig: "(null|object|function)", reference: "(string|element|object)" }; class Wi extends B { constructor(e, t) { super(e, t), this._popper = null, this._parent = this._element.parentNode, this._menu = Q.findOne(zi, this._parent), this._inNavbar = this._detectNavbar() } static get Default() { return Bi } static get DefaultType() { return Ri } static get NAME() { return wi } toggle() { return this._isShown() ? this.hide() : this.show() } show() { if (l(this._element) || this._isShown()) return; const e = { relatedTarget: this._element }; if (!O.trigger(this._element, ki, e).defaultPrevented) { if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav")) for (const e of [].concat(...document.body.children)) O.on(e, "mouseover", d); this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(Ii), this._element.classList.add(Ii), O.trigger(this._element, Ai, e) } } hide() { if (l(this._element) || !this._isShown()) return; const e = { relatedTarget: this._element }; this._completeHide(e) } dispose() { this._popper && this._popper.destroy(), super.dispose() } update() { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update() } _completeHide(e) { if (!O.trigger(this._element, Si, e).defaultPrevented) { if ("ontouchstart" in document.documentElement) for (const e of [].concat(...document.body.children)) O.off(e, "mouseover", d); this._popper && this._popper.destroy(), this._menu.classList.remove(Ii), this._element.classList.remove(Ii), this._element.setAttribute("aria-expanded", "false"), H.removeDataAttribute(this._menu, "popper"), O.trigger(this._element, Ci, e) } } _getConfig(e) { if ("object" == typeof (e = super._getConfig(e)).reference && !r(e.reference) && "function" != typeof e.reference.getBoundingClientRect) throw new TypeError(`${wi.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`); return e } _createPopper() { if (void 0 === bi) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); let e = this._element; "parent" === this._config.reference ? e = this._parent : r(this._config.reference) ? e = o(this._config.reference) : "object" == typeof this._config.reference && (e = this._config.reference); const t = this._getPopperConfig(); this._popper = yi(e, this._menu, t) } _isShown() { return this._menu.classList.contains(Ii) } _getPlacement() { const e = this._parent; if (e.classList.contains("dropend")) return Hi; if (e.classList.contains("dropstart")) return qi; if (e.classList.contains("dropup-center")) return "top"; if (e.classList.contains("dropdown-center")) return "bottom"; const t = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim(); return e.classList.contains("dropup") ? t ? Ni : Di : t ? Fi : ji } _detectNavbar() { return null !== this._element.closest(".navbar") } _getOffset() { const { offset: e } = this._config; return "string" == typeof e ? e.split(",").map((e => Number.parseInt(e, 10))) : "function" == typeof e ? t => e(t, this._element) : e } _getPopperConfig() { const e = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] }; return (this._inNavbar || "static" === this._config.display) && (H.setDataAttribute(this._menu, "popper", "static"), e.modifiers = [{ name: "applyStyles", enabled: !1 }]), { ...e, ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(e) : this._config.popperConfig } } _selectMenuItem({ key: e, target: t }) { const i = Q.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter((e => a(e))); i.length && y(i, t, e === Ei, !i.includes(t)).focus() } static jQueryInterface(e) { return this.each((function () { const t = Wi.getOrCreateInstance(this, e); if ("string" == typeof e) { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e]() } })) } static clearMenus(e) { if (2 === e.button || "keyup" === e.type && "Tab" !== e.key) return; const t = Q.find(Oi); for (const i of t) { const t = Wi.getInstance(i); if (!t || !1 === t._config.autoClose) continue; const n = e.composedPath(), s = n.includes(t._menu); if (n.includes(t._element) || "inside" === t._config.autoClose && !s || "outside" === t._config.autoClose && s) continue; if (t._menu.contains(e.target) && ("keyup" === e.type && "Tab" === e.key || /input|select|option|textarea|form/i.test(e.target.tagName))) continue; const r = { relatedTarget: t._element }; "click" === e.type && (r.clickEvent = e), t._completeHide(r) } } static dataApiKeydownHandler(e) { const t = /input|textarea/i.test(e.target.tagName), i = "Escape" === e.key, n = [Ti, Ei].includes(e.key); if (!n && !i) return; if (t && !i) return; e.preventDefault(); const s = Q.findOne(Li, e.delegateTarget.parentNode), r = Wi.getOrCreateInstance(s); if (n) return e.stopPropagation(), r.show(), void r._selectMenuItem(e); r._isShown() && (e.stopPropagation(), r.hide(), s.focus()) } } O.on(document, Mi, Li, Wi.dataApiKeydownHandler), O.on(document, Mi, zi, Wi.dataApiKeydownHandler), O.on(document, $i, Wi.clearMenus), O.on(document, Pi, Wi.clearMenus), O.on(document, $i, Li, (function (e) { e.preventDefault(), Wi.getOrCreateInstance(this).toggle() })), m(Wi); const Yi = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", Xi = ".sticky-top", Vi = "padding-right", Gi = "margin-right"; class Ui { constructor() { this._element = document.body } getWidth() { const e = document.documentElement.clientWidth; return Math.abs(window.innerWidth - e) } hide() { const e = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, Vi, (t => t + e)), this._setElementAttributes(Yi, Vi, (t => t + e)), this._setElementAttributes(Xi, Gi, (t => t - e)) } reset() { this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, Vi), this._resetElementAttributes(Yi, Vi), this._resetElementAttributes(Xi, Gi) } isOverflowing() { return this.getWidth() > 0 } _disableOverFlow() { this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden" } _setElementAttributes(e, t, i) { const n = this.getWidth(); this._applyManipulationCallback(e, (e => { if (e !== this._element && window.innerWidth > e.clientWidth + n) return; this._saveInitialAttribute(e, t); const s = window.getComputedStyle(e).getPropertyValue(t); e.style.setProperty(t, `${i(Number.parseFloat(s))}px`) })) } _saveInitialAttribute(e, t) { const i = e.style.getPropertyValue(t); i && H.setDataAttribute(e, t, i) } _resetElementAttributes(e, t) { this._applyManipulationCallback(e, (e => { const i = H.getDataAttribute(e, t); null !== i ? (H.removeDataAttribute(e, t), e.style.setProperty(t, i)) : e.style.removeProperty(t) })) } _applyManipulationCallback(e, t) { if (r(e)) t(e); else for (const i of Q.find(e, this._element)) t(i) } } const Qi = "backdrop", Ki = "show", Zi = `mousedown.bs.${Qi}`, Ji = { className: "modal-backdrop", clickCallback: null, isAnimated: !1, isVisible: !0, rootElement: "body" }, en = { className: "string", clickCallback: "(function|null)", isAnimated: "boolean", isVisible: "boolean", rootElement: "(element|string)" }; class tn extends q { constructor(e) { super(), this._config = this._getConfig(e), this._isAppended = !1, this._element = null } static get Default() { return Ji } static get DefaultType() { return en } static get NAME() { return Qi } show(e) { if (!this._config.isVisible) return void g(e); this._append(); const t = this._getElement(); this._config.isAnimated && u(t), t.classList.add(Ki), this._emulateAnimation((() => { g(e) })) } hide(e) { this._config.isVisible ? (this._getElement().classList.remove(Ki), this._emulateAnimation((() => { this.dispose(), g(e) }))) : g(e) } dispose() { this._isAppended && (O.off(this._element, Zi), this._element.remove(), this._isAppended = !1) } _getElement() { if (!this._element) { const e = document.createElement("div"); e.className = this._config.className, this._config.isAnimated && e.classList.add("fade"), this._element = e } return this._element } _configAfterMerge(e) { return e.rootElement = o(e.rootElement), e } _append() { if (this._isAppended) return; const e = this._getElement(); this._config.rootElement.append(e), O.on(e, Zi, (() => { g(this._config.clickCallback) })), this._isAppended = !0 } _emulateAnimation(e) { v(e, this._getElement(), this._config.isAnimated) } } const nn = ".bs.focustrap", sn = `focusin${nn}`, rn = `keydown.tab${nn}`, on = "backward", an = { autofocus: !0, trapElement: null }, ln = { autofocus: "boolean", trapElement: "element" }; class cn extends q { constructor(e) { super(), this._config = this._getConfig(e), this._isActive = !1, this._lastTabNavDirection = null } static get Default() { return an } static get DefaultType() { return ln } static get NAME() { return "focustrap" } activate() { this._isActive || (this._config.autofocus && this._config.trapElement.focus(), O.off(document, nn), O.on(document, sn, (e => this._handleFocusin(e))), O.on(document, rn, (e => this._handleKeydown(e))), this._isActive = !0) } deactivate() { this._isActive && (this._isActive = !1, O.off(document, nn)) } _handleFocusin(e) { const { trapElement: t } = this._config; if (e.target === document || e.target === t || t.contains(e.target)) return; const i = Q.focusableChildren(t); 0 === i.length ? t.focus() : this._lastTabNavDirection === on ? i[i.length - 1].focus() : i[0].focus() } _handleKeydown(e) { "Tab" === e.key && (this._lastTabNavDirection = e.shiftKey ? on : "forward") } } const dn = ".bs.modal", un = `hide${dn}`, hn = `hidePrevented${dn}`, pn = `hidden${dn}`, fn = `show${dn}`, mn = `shown${dn}`, gn = `resize${dn}`, vn = `mousedown.dismiss${dn}`, yn = `keydown.dismiss${dn}`, bn = `click${dn}.data-api`, wn = "modal-open", xn = "show", _n = "modal-static", Tn = { backdrop: !0, focus: !0, keyboard: !0 }, En = { backdrop: "(boolean|string)", focus: "boolean", keyboard: "boolean" }; class Sn extends B { constructor(e, t) { super(e, t), this._dialog = Q.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new Ui, this._addEventListeners() } static get Default() { return Tn } static get DefaultType() { return En } static get NAME() { return "modal" } toggle(e) { return this._isShown ? this.hide() : this.show(e) } show(e) { if (this._isShown || this._isTransitioning) return; O.trigger(this._element, fn, { relatedTarget: e }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(wn), this._adjustDialog(), this._backdrop.show((() => this._showElement(e)))) } hide() { if (!this._isShown || this._isTransitioning) return; O.trigger(this._element, un).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(xn), this._queueCallback((() => this._hideModal()), this._element, this._isAnimated())) } dispose() { for (const e of [window, this._dialog]) O.off(e, dn); this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } handleUpdate() { this._adjustDialog() } _initializeBackDrop() { return new tn({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() }) } _initializeFocusTrap() { return new cn({ trapElement: this._element }) } _showElement(e) { document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0; const t = Q.findOne(".modal-body", this._dialog); t && (t.scrollTop = 0), u(this._element), this._element.classList.add(xn); this._queueCallback((() => { this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, O.trigger(this._element, mn, { relatedTarget: e }) }), this._dialog, this._isAnimated()) } _addEventListeners() { O.on(this._element, yn, (e => { if ("Escape" === e.key) return this._config.keyboard ? (e.preventDefault(), void this.hide()) : void this._triggerBackdropTransition() })), O.on(window, gn, (() => { this._isShown && !this._isTransitioning && this._adjustDialog() })), O.on(this._element, vn, (e => { e.target === e.currentTarget && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition()) })) } _hideModal() { this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide((() => { document.body.classList.remove(wn), this._resetAdjustments(), this._scrollBar.reset(), O.trigger(this._element, pn) })) } _isAnimated() { return this._element.classList.contains("fade") } _triggerBackdropTransition() { if (O.trigger(this._element, hn).defaultPrevented) return; const e = this._element.scrollHeight > document.documentElement.clientHeight, t = this._element.style.overflowY; "hidden" === t || this._element.classList.contains(_n) || (e || (this._element.style.overflowY = "hidden"), this._element.classList.add(_n), this._queueCallback((() => { this._element.classList.remove(_n), this._queueCallback((() => { this._element.style.overflowY = t }), this._dialog) }), this._dialog), this._element.focus()) } _adjustDialog() { const e = this._element.scrollHeight > document.documentElement.clientHeight, t = this._scrollBar.getWidth(), i = t > 0; if (i && !e) { const e = f() ? "paddingLeft" : "paddingRight"; this._element.style[e] = `${t}px` } if (!i && e) { const e = f() ? "paddingRight" : "paddingLeft"; this._element.style[e] = `${t}px` } } _resetAdjustments() { this._element.style.paddingLeft = "", this._element.style.paddingRight = "" } static jQueryInterface(e, t) { return this.each((function () { const i = Sn.getOrCreateInstance(this, e); if ("string" == typeof e) { if (void 0 === i[e]) throw new TypeError(`No method named "${e}"`); i[e](t) } })) } } O.on(document, bn, '[data-bs-toggle="modal"]', (function (e) { const t = n(this);["A", "AREA"].includes(this.tagName) && e.preventDefault(), O.one(t, fn, (e => { e.defaultPrevented || O.one(t, pn, (() => { a(this) && this.focus() })) })); const i = Q.findOne(".modal.show"); i && Sn.getInstance(i).hide(); Sn.getOrCreateInstance(t).toggle(this) })), R(Sn), m(Sn); const Cn = ".bs.offcanvas", kn = ".data-api", An = `load${Cn}${kn}`, $n = "show", Mn = "showing", Pn = "hiding", In = ".offcanvas.show", Ln = `show${Cn}`, On = `shown${Cn}`, zn = `hide${Cn}`, Dn = `hidePrevented${Cn}`, Nn = `hidden${Cn}`, jn = `resize${Cn}`, Fn = `click${Cn}${kn}`, Hn = `keydown.dismiss${Cn}`, qn = { backdrop: !0, keyboard: !0, scroll: !1 }, Bn = { backdrop: "(boolean|string)", keyboard: "boolean", scroll: "boolean" }; class Rn extends B { constructor(e, t) { super(e, t), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners() } static get Default() { return qn } static get DefaultType() { return Bn } static get NAME() { return "offcanvas" } toggle(e) { return this._isShown ? this.hide() : this.show(e) } show(e) { if (this._isShown) return; if (O.trigger(this._element, Ln, { relatedTarget: e }).defaultPrevented) return; this._isShown = !0, this._backdrop.show(), this._config.scroll || (new Ui).hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(Mn); this._queueCallback((() => { this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add($n), this._element.classList.remove(Mn), O.trigger(this._element, On, { relatedTarget: e }) }), this._element, !0) } hide() { if (!this._isShown) return; if (O.trigger(this._element, zn).defaultPrevented) return; this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(Pn), this._backdrop.hide(); this._queueCallback((() => { this._element.classList.remove($n, Pn), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || (new Ui).reset(), O.trigger(this._element, Nn) }), this._element, !0) } dispose() { this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } _initializeBackDrop() { const e = Boolean(this._config.backdrop); return new tn({ className: "offcanvas-backdrop", isVisible: e, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: e ? () => { "static" !== this._config.backdrop ? this.hide() : O.trigger(this._element, Dn) } : null }) } _initializeFocusTrap() { return new cn({ trapElement: this._element }) } _addEventListeners() { O.on(this._element, Hn, (e => { "Escape" === e.key && (this._config.keyboard ? this.hide() : O.trigger(this._element, Dn)) })) } static jQueryInterface(e) { return this.each((function () { const t = Rn.getOrCreateInstance(this, e); if ("string" == typeof e) { if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw new TypeError(`No method named "${e}"`); t[e](this) } })) } } O.on(document, Fn, '[data-bs-toggle="offcanvas"]', (function (e) { const t = n(this); if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), l(this)) return; O.one(t, Nn, (() => { a(this) && this.focus() })); const i = Q.findOne(In); i && i !== t && Rn.getInstance(i).hide(); Rn.getOrCreateInstance(t).toggle(this) })), O.on(window, An, (() => { for (const e of Q.find(In)) Rn.getOrCreateInstance(e).show() })), O.on(window, jn, (() => { for (const e of Q.find("[aria-modal][class*=show][class*=offcanvas-]")) "fixed" !== getComputedStyle(e).position && Rn.getOrCreateInstance(e).hide() })), R(Rn), m(Rn); const Wn = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), Yn = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Xn = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, Vn = (e, t) => { const i = e.nodeName.toLowerCase(); return t.includes(i) ? !Wn.has(i) || Boolean(Yn.test(e.nodeValue) || Xn.test(e.nodeValue)) : t.filter((e => e instanceof RegExp)).some((e => e.test(i))) }, Gn = { "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }; const Un = { allowList: Gn, content: {}, extraClass: "", html: !1, sanitize: !0, sanitizeFn: null, template: "<div></div>" }, Qn = { allowList: "object", content: "object", extraClass: "(string|function)", html: "boolean", sanitize: "boolean", sanitizeFn: "(null|function)", template: "string" }, Kn = { entry: "(string|element|function|null)", selector: "(string|element)" }; class Zn extends q { constructor(e) { super(), this._config = this._getConfig(e) } static get Default() { return Un } static get DefaultType() { return Qn } static get NAME() { return "TemplateFactory" } getContent() { return Object.values(this._config.content).map((e => this._resolvePossibleFunction(e))).filter(Boolean) } hasContent() { return this.getContent().length > 0 } changeContent(e) { return this._checkContent(e), this._config.content = { ...this._config.content, ...e }, this } toHtml() { const e = document.createElement("div"); e.innerHTML = this._maybeSanitize(this._config.template); for (const [t, i] of Object.entries(this._config.content)) this._setContent(e, i, t); const t = e.children[0], i = this._resolvePossibleFunction(this._config.extraClass); return i && t.classList.add(...i.split(" ")), t } _typeCheckConfig(e) { super._typeCheckConfig(e), this._checkContent(e.content) } _checkContent(e) { for (const [t, i] of Object.entries(e)) super._typeCheckConfig({ selector: t, entry: i }, Kn) } _setContent(e, t, i) { const n = Q.findOne(i, e); n && ((t = this._resolvePossibleFunction(t)) ? r(t) ? this._putElementInTemplate(o(t), n) : this._config.html ? n.innerHTML = this._maybeSanitize(t) : n.textContent = t : n.remove()) } _maybeSanitize(e) { return this._config.sanitize ? function (e, t, i) { if (!e.length) return e; if (i && "function" == typeof i) return i(e); const n = (new window.DOMParser).parseFromString(e, "text/html"), s = [].concat(...n.body.querySelectorAll("*")); for (const e of s) { const i = e.nodeName.toLowerCase(); if (!Object.keys(t).includes(i)) { e.remove(); continue } const n = [].concat(...e.attributes), s = [].concat(t["*"] || [], t[i] || []); for (const t of n) Vn(t, s) || e.removeAttribute(t.nodeName) } return n.body.innerHTML }(e, this._config.allowList, this._config.sanitizeFn) : e } _resolvePossibleFunction(e) { return "function" == typeof e ? e(this) : e } _putElementInTemplate(e, t) { if (this._config.html) return t.innerHTML = "", void t.append(e); t.textContent = e.textContent } } const Jn = new Set(["sanitize", "allowList", "sanitizeFn"]), es = "fade", ts = "show", is = ".modal", ns = "hide.bs.modal", ss = "hover", rs = "focus", os = { AUTO: "auto", TOP: "top", RIGHT: f() ? "left" : "right", BOTTOM: "bottom", LEFT: f() ? "right" : "left" }, as = { allowList: Gn, animation: !0, boundary: "clippingParents", container: !1, customClass: "", delay: 0, fallbackPlacements: ["top", "right", "bottom", "left"], html: !1, offset: [0, 0], placement: "top", popperConfig: null, sanitize: !0, sanitizeFn: null, selector: !1, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', title: "", trigger: "hover focus" }, ls = { allowList: "object", animation: "boolean", boundary: "(string|element)", container: "(string|element|boolean)", customClass: "(string|function)", delay: "(number|object)", fallbackPlacements: "array", html: "boolean", offset: "(array|string|function)", placement: "(string|function)", popperConfig: "(null|object|function)", sanitize: "boolean", sanitizeFn: "(null|function)", selector: "(string|boolean)", template: "string", title: "(string|element|function)", trigger: "string" }; class cs extends B { constructor(e, t) { if (void 0 === bi) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)"); super(e, t), this._isEnabled = !0, this._timeout = 0, this._isHovered = !1, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners() } static get Default() { return as } static get DefaultType() { return ls } static get NAME() { return "tooltip" } enable() { this._isEnabled = !0 } disable() { this._isEnabled = !1 } toggleEnabled() { this._isEnabled = !this._isEnabled } toggle(e) { if (this._isEnabled) { if (e) { const t = this._initializeOnDelegatedTarget(e); return t._activeTrigger.click = !t._activeTrigger.click, void (t._isWithActiveTrigger() ? t._enter() : t._leave()) } this._isShown() ? this._leave() : this._enter() } } dispose() { clearTimeout(this._timeout), O.off(this._element.closest(is), ns, this._hideModalHandler), this.tip && this.tip.remove(), this._disposePopper(), super.dispose() } show() { if ("none" === this._element.style.display) throw new Error("Please use show on visible elements"); if (!this._isWithContent() || !this._isEnabled) return; const e = O.trigger(this._element, this.constructor.eventName("show")), t = (c(this._element) || this._element.ownerDocument.documentElement).contains(this._element); if (e.defaultPrevented || !t) return; this.tip && (this.tip.remove(), this.tip = null); const i = this._getTipElement(); this._element.setAttribute("aria-describedby", i.getAttribute("id")); const { container: n } = this._config; if (this._element.ownerDocument.documentElement.contains(this.tip) || (n.append(i), O.trigger(this._element, this.constructor.eventName("inserted"))), this._popper ? this._popper.update() : this._popper = this._createPopper(i), i.classList.add(ts), "ontouchstart" in document.documentElement) for (const e of [].concat(...document.body.children)) O.on(e, "mouseover", d); this._queueCallback((() => { const e = this._isHovered; this._isHovered = !1, O.trigger(this._element, this.constructor.eventName("shown")), e && this._leave() }), this.tip, this._isAnimated()) } hide() { if (!this._isShown()) return; if (O.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) return; const e = this._getTipElement(); if (e.classList.remove(ts), "ontouchstart" in document.documentElement) for (const e of [].concat(...document.body.children)) O.off(e, "mouseover", d); this._activeTrigger.click = !1, this._activeTrigger[rs] = !1, this._activeTrigger[ss] = !1, this._isHovered = !1; this._queueCallback((() => { this._isWithActiveTrigger() || (this._isHovered || e.remove(), this._element.removeAttribute("aria-describedby"), O.trigger(this._element, this.constructor.eventName("hidden")), this._disposePopper()) }), this.tip, this._isAnimated()) } update() { this._popper && this._popper.update() } _isWithContent() { return Boolean(this._getTitle()) } _getTipElement() { return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip } _createTipElement(e) { const t = this._getTemplateFactory(e).toHtml(); if (!t) return null; t.classList.remove(es, ts), t.classList.add(`bs-${this.constructor.NAME}-auto`); const i = (e => { do { e += Math.floor(1e6 * Math.random()) } while (document.getElementById(e)); return e })(this.constructor.NAME).toString(); return t.setAttribute("id", i), this._isAnimated() && t.classList.add(es), t } setContent(e) { this._newContent = e, this._isShown() && (this._disposePopper(), this.show()) } _getTemplateFactory(e) { return this._templateFactory ? this._templateFactory.changeContent(e) : this._templateFactory = new Zn({ ...this._config, content: e, extraClass: this._resolvePossibleFunction(this._config.customClass) }), this._templateFactory } _getContentForTemplate() { return { ".tooltip-inner": this._getTitle() } } _getTitle() { return this._resolvePossibleFunction(this._config.title) || this._config.originalTitle } _initializeOnDelegatedTarget(e) { return this.constructor.getOrCreateInstance(e.delegateTarget, this._getDelegateConfig()) } _isAnimated() { return this._config.animation || this.tip && this.tip.classList.contains(es) } _isShown() { return this.tip && this.tip.classList.contains(ts) } _createPopper(e) { const t = "function" == typeof this._config.placement ? this._config.placement.call(this, e, this._element) : this._config.placement, i = os[t.toUpperCase()]; return yi(this._element, e, this._getPopperConfig(i)) } _getOffset() { const { offset: e } = this._config; return "string" == typeof e ? e.split(",").map((e => Number.parseInt(e, 10))) : "function" == typeof e ? t => e(t, this._element) : e } _resolvePossibleFunction(e) { return "function" == typeof e ? e.call(this._element) : e } _getPopperConfig(e) { const t = { placement: e, modifiers: [{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: "offset", options: { offset: this._getOffset() } }, { name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } }, { name: "preSetPlacement", enabled: !0, phase: "beforeMain", fn: e => { this._getTipElement().setAttribute("data-popper-placement", e.state.placement) } }] }; return { ...t, ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(t) : this._config.popperConfig } } _setListeners() { const e = this._config.trigger.split(" "); for (const t of e) if ("click" === t) O.on(this._element, this.constructor.eventName("click"), this._config.selector, (e => this.toggle(e))); else if ("manual" !== t) { const e = t === ss ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"), i = t === ss ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout"); O.on(this._element, e, this._config.selector, (e => { const t = this._initializeOnDelegatedTarget(e); t._activeTrigger["focusin" === e.type ? rs : ss] = !0, t._enter() })), O.on(this._element, i, this._config.selector, (e => { const t = this._initializeOnDelegatedTarget(e); t._activeTrigger["focusout" === e.type ? rs : ss] = t._element.contains(e.relatedTarget), t._leave() })) } this._hideModalHandler = () => { this._element && this.hide() }, O.on(this._element.closest(is), ns, this._hideModalHandler), this._config.selector ? this._config = { ...this._config, trigger: "manual", selector: "" } : this._fixTitle() } _fixTitle() { const e = this._config.originalTitle; e && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", e), this._element.removeAttribute("title")) } _enter() { this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0, this._setTimeout((() => { this._isHovered && this.show() }), this._config.delay.show)) } _leave() { this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout((() => { this._isHovered || this.hide() }), this._config.delay.hide)) } _setTimeout(e, t) { clearTimeout(this._timeout), this._timeout = setTimeout(e, t) } _isWithActiveTrigger() { return Object.values(this._activeTrigger).includes(!0) } _getConfig(e) { const t = H.getDataAttributes(this._element); for (const e of Object.keys(t)) Jn.has(e) && delete t[e]; return e = { ...t, ..."object" == typeof e && e ? e : {} }, e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e } _configAfterMerge(e) { return e.container = !1 === e.container ? document.body : o(e.container), "number" == typeof e.delay && (e.delay = { show: e.delay, hide: e.delay }), e.originalTitle = this._element.getAttribute("title") || "", "number" == typeof e.title && (e.title = e.title.toString()), "number" == typeof e.content && (e.content = e.content.toString()), e } _getDelegateConfig() { const e = {}; for (const t in this._config) this.constructor.Default[t] !== this._config[t] && (e[t] = this._config[t]); return e } _disposePopper() { this._popper && (this._popper.destroy(), this._popper = null) } static jQueryInterface(e) { return this.each((function () { const t = cs.getOrCreateInstance(this, e); if ("string" == typeof e) { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e]() } })) } } m(cs); const ds = { ...cs.Default, content: "", offset: [0, 8], placement: "right", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger: "click" }, us = { ...cs.DefaultType, content: "(null|string|element|function)" }; class hs extends cs { static get Default() { return ds } static get DefaultType() { return us } static get NAME() { return "popover" } _isWithContent() { return this._getTitle() || this._getContent() } _getContentForTemplate() { return { ".popover-header": this._getTitle(), ".popover-body": this._getContent() } } _getContent() { return this._resolvePossibleFunction(this._config.content) } static jQueryInterface(e) { return this.each((function () { const t = hs.getOrCreateInstance(this, e); if ("string" == typeof e) { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e]() } })) } } m(hs); const ps = ".bs.scrollspy", fs = `activate${ps}`, ms = `click${ps}`, gs = `load${ps}.data-api`, vs = "active", ys = "[href]", bs = ".nav-link", ws = `${bs}, .nav-item > ${bs}, .list-group-item`, xs = { offset: null, rootMargin: "0px 0px -25%", smoothScroll: !1, target: null }, _s = { offset: "(number|null)", rootMargin: "string", smoothScroll: "boolean", target: "element" }; class Ts extends B { constructor(e, t) { super(e, t), this._targetLinks = new Map, this._observableSections = new Map, this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }, this.refresh() } static get Default() { return xs } static get DefaultType() { return _s } static get NAME() { return "scrollspy" } refresh() { this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver(); for (const e of this._observableSections.values()) this._observer.observe(e) } dispose() { this._observer.disconnect(), super.dispose() } _configAfterMerge(e) { return e.target = o(e.target) || document.body, e } _maybeEnableSmoothScroll() { this._config.smoothScroll && (O.off(this._config.target, ms), O.on(this._config.target, ms, ys, (e => { const t = this._observableSections.get(e.target.hash); if (t) { e.preventDefault(); const i = this._rootElement || window, n = t.offsetTop - this._element.offsetTop; if (i.scrollTo) return void i.scrollTo({ top: n, behavior: "smooth" }); i.scrollTop = n } }))) } _getNewObserver() { const e = { root: this._rootElement, threshold: [.1, .5, 1], rootMargin: this._getRootMargin() }; return new IntersectionObserver((e => this._observerCallback(e)), e) } _observerCallback(e) { const t = e => this._targetLinks.get(`#${e.target.id}`), i = e => { this._previousScrollData.visibleEntryTop = e.target.offsetTop, this._process(t(e)) }, n = (this._rootElement || document.documentElement).scrollTop, s = n >= this._previousScrollData.parentScrollTop; this._previousScrollData.parentScrollTop = n; for (const r of e) { if (!r.isIntersecting) { this._activeTarget = null, this._clearActiveClass(t(r)); continue } const e = r.target.offsetTop >= this._previousScrollData.visibleEntryTop; if (s && e) { if (i(r), !n) return } else s || e || i(r) } } _getRootMargin() { return this._config.offset ? `${this._config.offset}px 0px -30%` : this._config.rootMargin } _initializeTargetsAndObservables() { this._targetLinks = new Map, this._observableSections = new Map; const e = Q.find(ys, this._config.target); for (const t of e) { if (!t.hash || l(t)) continue; const e = Q.findOne(t.hash, this._element); a(e) && (this._targetLinks.set(t.hash, t), this._observableSections.set(t.hash, e)) } } _process(e) { this._activeTarget !== e && (this._clearActiveClass(this._config.target), this._activeTarget = e, e.classList.add(vs), this._activateParents(e), O.trigger(this._element, fs, { relatedTarget: e })) } _activateParents(e) { if (e.classList.contains("dropdown-item")) Q.findOne(".dropdown-toggle", e.closest(".dropdown")).classList.add(vs); else for (const t of Q.parents(e, ".nav, .list-group")) for (const e of Q.prev(t, ws)) e.classList.add(vs) } _clearActiveClass(e) { e.classList.remove(vs); const t = Q.find(`${ys}.${vs}`, e); for (const e of t) e.classList.remove(vs) } static jQueryInterface(e) { return this.each((function () { const t = Ts.getOrCreateInstance(this, e); if ("string" == typeof e) { if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw new TypeError(`No method named "${e}"`); t[e]() } })) } } O.on(window, gs, (() => { for (const e of Q.find('[data-bs-spy="scroll"]')) Ts.getOrCreateInstance(e) })), m(Ts); const Es = ".bs.tab", Ss = `hide${Es}`, Cs = `hidden${Es}`, ks = `show${Es}`, As = `shown${Es}`, $s = `click${Es}`, Ms = `keydown${Es}`, Ps = `load${Es}`, Is = "ArrowLeft", Ls = "ArrowRight", Os = "ArrowUp", zs = "ArrowDown", Ds = "active", Ns = "fade", js = "show", Fs = ":not(.dropdown-toggle)", Hs = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', qs = `${`.nav-link${Fs}, .list-group-item${Fs}, [role="tab"]${Fs}`}, ${Hs}`, Bs = `.${Ds}[data-bs-toggle="tab"], .${Ds}[data-bs-toggle="pill"], .${Ds}[data-bs-toggle="list"]`; class Rs extends B { constructor(e) { super(e), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), O.on(this._element, Ms, (e => this._keydown(e)))) } static get NAME() { return "tab" } show() { const e = this._element; if (this._elemIsActive(e)) return; const t = this._getActiveElem(), i = t ? O.trigger(t, Ss, { relatedTarget: e }) : null; O.trigger(e, ks, { relatedTarget: t }).defaultPrevented || i && i.defaultPrevented || (this._deactivate(t, e), this._activate(e, t)) } _activate(e, t) { if (!e) return; e.classList.add(Ds), this._activate(n(e)); this._queueCallback((() => { "tab" === e.getAttribute("role") ? (e.focus(), e.removeAttribute("tabindex"), e.setAttribute("aria-selected", !0), this._toggleDropDown(e, !0), O.trigger(e, As, { relatedTarget: t })) : e.classList.add(js) }), e, e.classList.contains(Ns)) } _deactivate(e, t) { if (!e) return; e.classList.remove(Ds), e.blur(), this._deactivate(n(e)); this._queueCallback((() => { "tab" === e.getAttribute("role") ? (e.setAttribute("aria-selected", !1), e.setAttribute("tabindex", "-1"), this._toggleDropDown(e, !1), O.trigger(e, Cs, { relatedTarget: t })) : e.classList.remove(js) }), e, e.classList.contains(Ns)) } _keydown(e) { if (![Is, Ls, Os, zs].includes(e.key)) return; e.stopPropagation(), e.preventDefault(); const t = [Ls, zs].includes(e.key), i = y(this._getChildren().filter((e => !l(e))), e.target, t, !0); i && Rs.getOrCreateInstance(i).show() } _getChildren() { return Q.find(qs, this._parent) } _getActiveElem() { return this._getChildren().find((e => this._elemIsActive(e))) || null } _setInitialAttributes(e, t) { this._setAttributeIfNotExists(e, "role", "tablist"); for (const e of t) this._setInitialAttributesOnChild(e) } _setInitialAttributesOnChild(e) { e = this._getInnerElement(e); const t = this._elemIsActive(e), i = this._getOuterElement(e); e.setAttribute("aria-selected", t), i !== e && this._setAttributeIfNotExists(i, "role", "presentation"), t || e.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(e, "role", "tab"), this._setInitialAttributesOnTargetPanel(e) } _setInitialAttributesOnTargetPanel(e) { const t = n(e); t && (this._setAttributeIfNotExists(t, "role", "tabpanel"), e.id && this._setAttributeIfNotExists(t, "aria-labelledby", `#${e.id}`)) } _toggleDropDown(e, t) { const i = this._getOuterElement(e); if (!i.classList.contains("dropdown")) return; const n = (e, n) => { const s = Q.findOne(e, i); s && s.classList.toggle(n, t) }; n(".dropdown-toggle", Ds), n(".dropdown-menu", js), n(".dropdown-item", Ds), i.setAttribute("aria-expanded", t) } _setAttributeIfNotExists(e, t, i) { e.hasAttribute(t) || e.setAttribute(t, i) } _elemIsActive(e) { return e.classList.contains(Ds) } _getInnerElement(e) { return e.matches(qs) ? e : Q.findOne(qs, e) } _getOuterElement(e) { return e.closest(".nav-item, .list-group-item") || e } static jQueryInterface(e) { return this.each((function () { const t = Rs.getOrCreateInstance(this); if ("string" == typeof e) { if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw new TypeError(`No method named "${e}"`); t[e]() } })) } } O.on(document, $s, Hs, (function (e) { ["A", "AREA"].includes(this.tagName) && e.preventDefault(), l(this) || Rs.getOrCreateInstance(this).show() })), O.on(window, Ps, (() => { for (const e of Q.find(Bs)) Rs.getOrCreateInstance(e) })), m(Rs); const Ws = ".bs.toast", Ys = `mouseover${Ws}`, Xs = `mouseout${Ws}`, Vs = `focusin${Ws}`, Gs = `focusout${Ws}`, Us = `hide${Ws}`, Qs = `hidden${Ws}`, Ks = `show${Ws}`, Zs = `shown${Ws}`, Js = "hide", er = "show", tr = "showing", ir = { animation: "boolean", autohide: "boolean", delay: "number" }, nr = { animation: !0, autohide: !0, delay: 5e3 }; class sr extends B { constructor(e, t) { super(e, t), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners() } static get Default() { return nr } static get DefaultType() { return ir } static get NAME() { return "toast" } show() { if (O.trigger(this._element, Ks).defaultPrevented) return; this._clearTimeout(), this._config.animation && this._element.classList.add("fade"); this._element.classList.remove(Js), u(this._element), this._element.classList.add(er, tr), this._queueCallback((() => { this._element.classList.remove(tr), O.trigger(this._element, Zs), this._maybeScheduleHide() }), this._element, this._config.animation) } hide() { if (!this.isShown()) return; if (O.trigger(this._element, Us).defaultPrevented) return; this._element.classList.add(tr), this._queueCallback((() => { this._element.classList.add(Js), this._element.classList.remove(tr, er), O.trigger(this._element, Qs) }), this._element, this._config.animation) } dispose() { this._clearTimeout(), this.isShown() && this._element.classList.remove(er), super.dispose() } isShown() { return this._element.classList.contains(er) } _maybeScheduleHide() { this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout((() => { this.hide() }), this._config.delay))) } _onInteraction(e, t) { switch (e.type) { case "mouseover": case "mouseout": this._hasMouseInteraction = t; break; case "focusin": case "focusout": this._hasKeyboardInteraction = t }if (t) return void this._clearTimeout(); const i = e.relatedTarget; this._element === i || this._element.contains(i) || this._maybeScheduleHide() } _setListeners() { O.on(this._element, Ys, (e => this._onInteraction(e, !0))), O.on(this._element, Xs, (e => this._onInteraction(e, !1))), O.on(this._element, Vs, (e => this._onInteraction(e, !0))), O.on(this._element, Gs, (e => this._onInteraction(e, !1))) } _clearTimeout() { clearTimeout(this._timeout), this._timeout = null } static jQueryInterface(e) { return this.each((function () { const t = sr.getOrCreateInstance(this, e); if ("string" == typeof e) { if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`); t[e](this) } })) } } R(sr), m(sr); return { Alert: V, Button: U, Carousel: Ae, Collapse: Be, Dropdown: Wi, Modal: Sn, Offcanvas: Rn, Popover: hs, ScrollSpy: Ts, Tab: Rs, Toast: sr, Tooltip: cs } })), function (e, t) { "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.ClipboardJS = t() : e.ClipboardJS = t() }(this, (function () { return t = { 686: function (e, t, i) { "use strict"; i.d(t, { default: function () { return g } }); t = i(279); var n = i.n(t), s = (t = i(370), i.n(t)), r = (t = i(817), i.n(t)); function o(e) { try { return document.execCommand(e) } catch (e) { return } } var a = function (e) { return e = r()(e), o("cut"), e }, l = function (e) { var t, i, n, s = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : { container: document.body }, a = ""; return "string" == typeof e ? (t = e, i = "rtl" === document.documentElement.getAttribute("dir"), (n = document.createElement("textarea")).style.fontSize = "12pt", n.style.border = "0", n.style.padding = "0", n.style.margin = "0", n.style.position = "absolute", n.style[i ? "right" : "left"] = "-9999px", i = window.pageYOffset || document.documentElement.scrollTop, n.style.top = "".concat(i, "px"), n.setAttribute("readonly", ""), n.value = t, s.container.appendChild(n), a = r()(n), o("copy"), n.remove()) : (a = r()(e), o("copy")), a }; function c(e) { return (c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } var d = function () { var e = void 0 === (i = (n = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {}).action) ? "copy" : i, t = n.container, i = n.target, n = n.text; if ("copy" !== e && "cut" !== e) throw new Error('Invalid "action" value, use either "copy" or "cut"'); if (void 0 !== i) { if (!i || "object" !== c(i) || 1 !== i.nodeType) throw new Error('Invalid "target" value, use a valid Element'); if ("copy" === e && i.hasAttribute("disabled")) throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute'); if ("cut" === e && (i.hasAttribute("readonly") || i.hasAttribute("disabled"))) throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes') } return n ? l(n, { container: t }) : i ? "cut" === e ? a(i) : l(i, { container: t }) : void 0 }; function u(e) { return (u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } function h(e, t) { for (var i = 0; i < t.length; i++) { var n = t[i]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } function p(e, t) { return (p = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e })(e, t) } function f(e) { return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) })(e) } function m(e, t) { if (e = "data-clipboard-".concat(e), t.hasAttribute(e)) return t.getAttribute(e) } var g = function () { !function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && p(e, t) }(o, n()); var e, t, i, r = function (e) { var t = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (e) { return !1 } }(); return function () { var i, n = f(e); return i = t ? (i = f(this).constructor, Reflect.construct(n, arguments, i)) : n.apply(this, arguments), n = this, !i || "object" !== u(i) && "function" != typeof i ? function (e) { if (void 0 !== e) return e; throw new ReferenceError("this hasn't been initialised - super() hasn't been called") }(n) : i } }(o); function o(e, t) { var i; return function (e) { if (!(e instanceof o)) throw new TypeError("Cannot call a class as a function") }(this), (i = r.call(this)).resolveOptions(t), i.listenClick(e), i } return e = o, i = [{ key: "copy", value: function (e) { var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : { container: document.body }; return l(e, t) } }, { key: "cut", value: function (e) { return a(e) } }, { key: "isSupported", value: function () { var e = "string" == typeof (e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : ["copy", "cut"]) ? [e] : e, t = !!document.queryCommandSupported; return e.forEach((function (e) { t = t && !!document.queryCommandSupported(e) })), t } }], (t = [{ key: "resolveOptions", value: function () { var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {}; this.action = "function" == typeof e.action ? e.action : this.defaultAction, this.target = "function" == typeof e.target ? e.target : this.defaultTarget, this.text = "function" == typeof e.text ? e.text : this.defaultText, this.container = "object" === u(e.container) ? e.container : document.body } }, { key: "listenClick", value: function (e) { var t = this; this.listener = s()(e, "click", (function (e) { return t.onClick(e) })) } }, { key: "onClick", value: function (e) { var t = e.delegateTarget || e.currentTarget; e = d({ action: this.action(t), container: this.container, target: this.target(t), text: this.text(t) }); this.emit(e ? "success" : "error", { action: this.action, text: e, trigger: t, clearSelection: function () { t && t.focus(), document.activeElement.blur(), window.getSelection().removeAllRanges() } }) } }, { key: "defaultAction", value: function (e) { return m("action", e) } }, { key: "defaultTarget", value: function (e) { if (e = m("target", e)) return document.querySelector(e) } }, { key: "defaultText", value: function (e) { return m("text", e) } }, { key: "destroy", value: function () { this.listener.destroy() } }]) && h(e.prototype, t), i && h(e, i), o }() }, 828: function (e) { var t; "undefined" == typeof Element || Element.prototype.matches || ((t = Element.prototype).matches = t.matchesSelector || t.mozMatchesSelector || t.msMatchesSelector || t.oMatchesSelector || t.webkitMatchesSelector), e.exports = function (e, t) { for (; e && 9 !== e.nodeType;) { if ("function" == typeof e.matches && e.matches(t)) return e; e = e.parentNode } } }, 438: function (e, t, i) { var n = i(828); function s(e, t, i, s, r) { var o = function (e, t, i, s) { return function (i) { i.delegateTarget = n(i.target, t), i.delegateTarget && s.call(e, i) } }.apply(this, arguments); return e.addEventListener(i, o, r), { destroy: function () { e.removeEventListener(i, o, r) } } } e.exports = function (e, t, i, n, r) { return "function" == typeof e.addEventListener ? s.apply(null, arguments) : "function" == typeof i ? s.bind(null, document).apply(null, arguments) : ("string" == typeof e && (e = document.querySelectorAll(e)), Array.prototype.map.call(e, (function (e) { return s(e, t, i, n, r) }))) } }, 879: function (e, t) { t.node = function (e) { return void 0 !== e && e instanceof HTMLElement && 1 === e.nodeType }, t.nodeList = function (e) { var i = Object.prototype.toString.call(e); return void 0 !== e && ("[object NodeList]" === i || "[object HTMLCollection]" === i) && "length" in e && (0 === e.length || t.node(e[0])) }, t.string = function (e) { return "string" == typeof e || e instanceof String }, t.fn = function (e) { return "[object Function]" === Object.prototype.toString.call(e) } }, 370: function (e, t, i) { var n = i(879), s = i(438); e.exports = function (e, t, i) { if (!e && !t && !i) throw new Error("Missing required arguments"); if (!n.string(t)) throw new TypeError("Second argument must be a String"); if (!n.fn(i)) throw new TypeError("Third argument must be a Function"); if (n.node(e)) return c = t, d = i, (l = e).addEventListener(c, d), { destroy: function () { l.removeEventListener(c, d) } }; if (n.nodeList(e)) return r = e, o = t, a = i, Array.prototype.forEach.call(r, (function (e) { e.addEventListener(o, a) })), { destroy: function () { Array.prototype.forEach.call(r, (function (e) { e.removeEventListener(o, a) })) } }; if (n.string(e)) return s(document.body, e, t, i); throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList"); var r, o, a, l, c, d } }, 817: function (e) { e.exports = function (e) { var t, i = "SELECT" === e.nodeName ? (e.focus(), e.value) : "INPUT" === e.nodeName || "TEXTAREA" === e.nodeName ? ((t = e.hasAttribute("readonly")) || e.setAttribute("readonly", ""), e.select(), e.setSelectionRange(0, e.value.length), t || e.removeAttribute("readonly"), e.value) : (e.hasAttribute("contenteditable") && e.focus(), i = window.getSelection(), (t = document.createRange()).selectNodeContents(e), i.removeAllRanges(), i.addRange(t), i.toString()); return i } }, 279: function (e) { function t() { } t.prototype = { on: function (e, t, i) { var n = this.e || (this.e = {}); return (n[e] || (n[e] = [])).push({ fn: t, ctx: i }), this }, once: function (e, t, i) { var n = this; function s() { n.off(e, s), t.apply(i, arguments) } return s._ = t, this.on(e, s, i) }, emit: function (e) { for (var t = [].slice.call(arguments, 1), i = ((this.e || (this.e = {}))[e] || []).slice(), n = 0, s = i.length; n < s; n++)i[n].fn.apply(i[n].ctx, t); return this }, off: function (e, t) { var i = this.e || (this.e = {}), n = i[e], s = []; if (n && t) for (var r = 0, o = n.length; r < o; r++)n[r].fn !== t && n[r].fn._ !== t && s.push(n[r]); return s.length ? i[e] = s : delete i[e], this } }, e.exports = t, e.exports.TinyEmitter = t } }, i = {}, e.n = function (t) { var i = t && t.__esModule ? function () { return t.default } : function () { return t }; return e.d(i, { a: i }), i }, e.d = function (t, i) { for (var n in i) e.o(i, n) && !e.o(t, n) && Object.defineProperty(t, n, { enumerable: !0, get: i[n] }) }, e.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, e(686).default; function e(n) { if (i[n]) return i[n].exports; var s = i[n] = { exports: {} }; return t[n](s, s.exports, e), s.exports } var t, i })), function (e, t) { "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.counterUp = t() : e.counterUp = t() }(self, (function () { return (() => { "use strict"; var e = { d: (t, i) => { for (var n in i) e.o(i, n) && !e.o(t, n) && Object.defineProperty(t, n, { enumerable: !0, get: i[n] }) }, o: (e, t) => Object.prototype.hasOwnProperty.call(e, t), r: e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) } }, t = {}; e.r(t), e.d(t, { default: () => i, divideNumbers: () => s }); const i = (e, t = {}) => { const { action: i = "start", duration: r = 1e3, delay: o = 16 } = t; if ("stop" === i) return void n(e); if (n(e), !/[0-9]/.test(e.innerHTML)) return; const a = s(e.innerHTML, { duration: r || e.getAttribute("data-duration"), delay: o || e.getAttribute("data-delay") }); e._countUpOrigInnerHTML = e.innerHTML, e.innerHTML = a[0] || "&nbsp;", e.style.visibility = "visible"; const l = function () { e.innerHTML = a.shift() || "&nbsp;", a.length ? (clearTimeout(e.countUpTimeout), e.countUpTimeout = setTimeout(l, o)) : e._countUpOrigInnerHTML = void 0 }; e.countUpTimeout = setTimeout(l, o) }, n = e => { clearTimeout(e.countUpTimeout), e._countUpOrigInnerHTML && (e.innerHTML = e._countUpOrigInnerHTML, e._countUpOrigInnerHTML = void 0), e.style.visibility = "" }, s = (e, t = {}) => { const { duration: i = 1e3, delay: n = 16 } = t, s = i / n, r = e.toString().split(/(<[^>]+>|[0-9.][,.0-9]*[0-9]*)/), o = []; for (let e = 0; e < s; e++)o.push(""); for (let e = 0; e < r.length; e++)if (/([0-9.][,.0-9]*[0-9]*)/.test(r[e]) && !/<[^>]+>/.test(r[e])) { let t = r[e]; const i = [...t.matchAll(/[.,]/g)].map((e => ({ char: e[0], i: t.length - e.index - 1 }))).sort(((e, t) => e.i - t.i)); t = t.replace(/[.,]/g, ""); let n = o.length - 1; for (let e = s; e >= 1; e--) { let r = parseInt(t / s * e, 10); r = i.reduce(((e, { char: t, i: i }) => e.length <= i ? e : e.slice(0, -i) + t + e.slice(-i)), r.toString()), o[n--] += r } } else for (let t = 0; t < s; t++)o[t] += r[e]; return o[o.length] = e.toString(), o }; return t })() })),
  /*!
   * GLightbox v3.2.0
   * https://github.com/biati-digital/glightbox
   */
  function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = e || self).GLightbox = t() }(this, (function () { "use strict"; function e(t) { return e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, e(t) } function t(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function i(e, t) { for (var i = 0; i < t.length; i++) { var n = t[i]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } function n(e, t, n) { return t && i(e.prototype, t), n && i(e, n), e } var s = Date.now(); function r() { var e = {}, t = !0, i = 0, n = arguments.length; "[object Boolean]" === Object.prototype.toString.call(arguments[0]) && (t = arguments[0], i++); for (var s = function (i) { for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (t && "[object Object]" === Object.prototype.toString.call(i[n]) ? e[n] = r(!0, e[n], i[n]) : e[n] = i[n]) }; i < n; i++) { s(arguments[i]) } return e } function o(e, t) { if ((E(e) || e === window || e === document) && (e = [e]), C(e) || k(e) || (e = [e]), 0 != M(e)) if (C(e) && !k(e)) for (var i = e.length, n = 0; n < i && !1 !== t.call(e[n], e[n], n, e); n++); else if (k(e)) for (var s in e) if ($(e, s) && !1 === t.call(e[s], e[s], s, e)) break } function a(e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, n = e[s] = e[s] || [], r = { all: n, evt: null, found: null }; return t && i && M(n) > 0 && o(n, (function (e, n) { if (e.eventName == t && e.fn.toString() == i.toString()) return r.found = !0, r.evt = n, !1 })), r } function l(e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i = t.onElement, n = t.withCallback, s = t.avoidDuplicate, r = void 0 === s || s, l = t.once, c = void 0 !== l && l, d = t.useCapture, u = void 0 !== d && d, h = arguments.length > 2 ? arguments[2] : void 0, p = i || []; function f(e) { _(n) && n.call(h, e, this), c && f.destroy() } return T(p) && (p = document.querySelectorAll(p)), f.destroy = function () { o(p, (function (t) { var i = a(t, e, f); i.found && i.all.splice(i.evt, 1), t.removeEventListener && t.removeEventListener(e, f, u) })) }, o(p, (function (t) { var i = a(t, e, f); (t.addEventListener && r && !i.found || !r) && (t.addEventListener(e, f, u), i.all.push({ eventName: e, fn: f })) })), f } function c(e, t) { o(t.split(" "), (function (t) { return e.classList.add(t) })) } function d(e, t) { o(t.split(" "), (function (t) { return e.classList.remove(t) })) } function u(e, t) { return e.classList.contains(t) } function h(e, t) { for (; e !== document.body;) { if (!(e = e.parentElement)) return !1; if ("function" == typeof e.matches ? e.matches(t) : e.msMatchesSelector(t)) return e } } function p(e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; if (!e || "" === t) return !1; if ("none" === t) return _(i) && i(), !1; var n = function () { var e, t = document.createElement("fakeelement"), i = { animation: "animationend", OAnimation: "oAnimationEnd", MozAnimation: "animationend", WebkitAnimation: "webkitAnimationEnd" }; for (e in i) if (void 0 !== t.style[e]) return i[e] }(), s = t.split(" "); o(s, (function (t) { c(e, "g" + t) })), l(n, { onElement: e, avoidDuplicate: !1, once: !0, withCallback: function (e, t) { o(s, (function (e) { d(t, "g" + e) })), _(i) && i() } }) } function f(e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ""; if ("" === t) return e.style.webkitTransform = "", e.style.MozTransform = "", e.style.msTransform = "", e.style.OTransform = "", e.style.transform = "", !1; e.style.webkitTransform = t, e.style.MozTransform = t, e.style.msTransform = t, e.style.OTransform = t, e.style.transform = t } function m(e) { e.style.display = "block" } function g(e) { e.style.display = "none" } function v(e) { var t = document.createDocumentFragment(), i = document.createElement("div"); for (i.innerHTML = e; i.firstChild;)t.appendChild(i.firstChild); return t } function y() { return { width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight } } function b(e, t, i, n) { if (e()) t(); else { var s; i || (i = 100); var r = setInterval((function () { e() && (clearInterval(r), s && clearTimeout(s), t()) }), i); n && (s = setTimeout((function () { clearInterval(r) }), n)) } } function w(e, t, i) { if (A(e)) console.error("Inject assets error"); else if (_(t) && (i = t, t = !1), T(t) && t in window) _(i) && i(); else { var n; if (-1 !== e.indexOf(".css")) { if ((n = document.querySelectorAll('link[href="' + e + '"]')) && n.length > 0) return void (_(i) && i()); var s = document.getElementsByTagName("head")[0], r = s.querySelectorAll('link[rel="stylesheet"]'), o = document.createElement("link"); return o.rel = "stylesheet", o.type = "text/css", o.href = e, o.media = "all", r ? s.insertBefore(o, r[0]) : s.appendChild(o), void (_(i) && i()) } if ((n = document.querySelectorAll('script[src="' + e + '"]')) && n.length > 0) { if (_(i)) { if (T(t)) return b((function () { return void 0 !== window[t] }), (function () { i() })), !1; i() } } else { var a = document.createElement("script"); a.type = "text/javascript", a.src = e, a.onload = function () { if (_(i)) { if (T(t)) return b((function () { return void 0 !== window[t] }), (function () { i() })), !1; i() } }, document.body.appendChild(a) } } } function x() { return "navigator" in window && window.navigator.userAgent.match(/(iPad)|(iPhone)|(iPod)|(Android)|(PlayBook)|(BB10)|(BlackBerry)|(Opera Mini)|(IEMobile)|(webOS)|(MeeGo)/i) } function _(e) { return "function" == typeof e } function T(e) { return "string" == typeof e } function E(e) { return !(!e || !e.nodeType || 1 != e.nodeType) } function S(e) { return Array.isArray(e) } function C(e) { return e && e.length && isFinite(e.length) } function k(t) { return "object" === e(t) && null != t && !_(t) && !S(t) } function A(e) { return null == e } function $(e, t) { return null !== e && hasOwnProperty.call(e, t) } function M(e) { if (k(e)) { if (e.keys) return e.keys().length; var t = 0; for (var i in e) $(e, i) && t++; return t } return e.length } function P(e) { return !isNaN(parseFloat(e)) && isFinite(e) } function I() { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1, t = document.querySelectorAll(".gbtn[data-taborder]:not(.disabled)"); if (!t.length) return !1; if (1 == t.length) return t[0]; "string" == typeof e && (e = parseInt(e)); var i = []; o(t, (function (e) { i.push(e.getAttribute("data-taborder")) })); var n = Math.max.apply(Math, i.map((function (e) { return parseInt(e) }))), s = e < 0 ? 1 : e + 1; s > n && (s = "1"); var r = i.filter((function (e) { return e >= parseInt(s) })).sort()[0]; return document.querySelector('.gbtn[data-taborder="'.concat(r, '"]')) } function L(e) { return Math.sqrt(e.x * e.x + e.y * e.y) } function O(e, t) { var i = function (e, t) { var i = L(e) * L(t); if (0 === i) return 0; var n = function (e, t) { return e.x * t.x + e.y * t.y }(e, t) / i; return n > 1 && (n = 1), Math.acos(n) }(e, t); return function (e, t) { return e.x * t.y - t.x * e.y }(e, t) > 0 && (i *= -1), 180 * i / Math.PI } var z = function () { function e(i) { t(this, e), this.handlers = [], this.el = i } return n(e, [{ key: "add", value: function (e) { this.handlers.push(e) } }, { key: "del", value: function (e) { e || (this.handlers = []); for (var t = this.handlers.length; t >= 0; t--)this.handlers[t] === e && this.handlers.splice(t, 1) } }, { key: "dispatch", value: function () { for (var e = 0, t = this.handlers.length; e < t; e++) { var i = this.handlers[e]; "function" == typeof i && i.apply(this.el, arguments) } } }]), e }(); function D(e, t) { var i = new z(e); return i.add(t), i } var N = function () { function e(i, n) { t(this, e), this.element = "string" == typeof i ? document.querySelector(i) : i, this.start = this.start.bind(this), this.move = this.move.bind(this), this.end = this.end.bind(this), this.cancel = this.cancel.bind(this), this.element.addEventListener("touchstart", this.start, !1), this.element.addEventListener("touchmove", this.move, !1), this.element.addEventListener("touchend", this.end, !1), this.element.addEventListener("touchcancel", this.cancel, !1), this.preV = { x: null, y: null }, this.pinchStartLen = null, this.zoom = 1, this.isDoubleTap = !1; var s = function () { }; this.rotate = D(this.element, n.rotate || s), this.touchStart = D(this.element, n.touchStart || s), this.multipointStart = D(this.element, n.multipointStart || s), this.multipointEnd = D(this.element, n.multipointEnd || s), this.pinch = D(this.element, n.pinch || s), this.swipe = D(this.element, n.swipe || s), this.tap = D(this.element, n.tap || s), this.doubleTap = D(this.element, n.doubleTap || s), this.longTap = D(this.element, n.longTap || s), this.singleTap = D(this.element, n.singleTap || s), this.pressMove = D(this.element, n.pressMove || s), this.twoFingerPressMove = D(this.element, n.twoFingerPressMove || s), this.touchMove = D(this.element, n.touchMove || s), this.touchEnd = D(this.element, n.touchEnd || s), this.touchCancel = D(this.element, n.touchCancel || s), this.translateContainer = this.element, this._cancelAllHandler = this.cancelAll.bind(this), window.addEventListener("scroll", this._cancelAllHandler), this.delta = null, this.last = null, this.now = null, this.tapTimeout = null, this.singleTapTimeout = null, this.longTapTimeout = null, this.swipeTimeout = null, this.x1 = this.x2 = this.y1 = this.y2 = null, this.preTapPosition = { x: null, y: null } } return n(e, [{ key: "start", value: function (e) { if (e.touches) { if (e.target && e.target.nodeName && ["a", "button", "input"].indexOf(e.target.nodeName.toLowerCase()) >= 0) console.log("ignore drag for this touched element", e.target.nodeName.toLowerCase()); else { this.now = Date.now(), this.x1 = e.touches[0].pageX, this.y1 = e.touches[0].pageY, this.delta = this.now - (this.last || this.now), this.touchStart.dispatch(e, this.element), null !== this.preTapPosition.x && (this.isDoubleTap = this.delta > 0 && this.delta <= 250 && Math.abs(this.preTapPosition.x - this.x1) < 30 && Math.abs(this.preTapPosition.y - this.y1) < 30, this.isDoubleTap && clearTimeout(this.singleTapTimeout)), this.preTapPosition.x = this.x1, this.preTapPosition.y = this.y1, this.last = this.now; var t = this.preV; if (e.touches.length > 1) { this._cancelLongTap(), this._cancelSingleTap(); var i = { x: e.touches[1].pageX - this.x1, y: e.touches[1].pageY - this.y1 }; t.x = i.x, t.y = i.y, this.pinchStartLen = L(t), this.multipointStart.dispatch(e, this.element) } this._preventTap = !1, this.longTapTimeout = setTimeout(function () { this.longTap.dispatch(e, this.element), this._preventTap = !0 }.bind(this), 750) } } } }, { key: "move", value: function (e) { if (e.touches) { var t = this.preV, i = e.touches.length, n = e.touches[0].pageX, s = e.touches[0].pageY; if (this.isDoubleTap = !1, i > 1) { var r = e.touches[1].pageX, o = e.touches[1].pageY, a = { x: e.touches[1].pageX - n, y: e.touches[1].pageY - s }; null !== t.x && (this.pinchStartLen > 0 && (e.zoom = L(a) / this.pinchStartLen, this.pinch.dispatch(e, this.element)), e.angle = O(a, t), this.rotate.dispatch(e, this.element)), t.x = a.x, t.y = a.y, null !== this.x2 && null !== this.sx2 ? (e.deltaX = (n - this.x2 + r - this.sx2) / 2, e.deltaY = (s - this.y2 + o - this.sy2) / 2) : (e.deltaX = 0, e.deltaY = 0), this.twoFingerPressMove.dispatch(e, this.element), this.sx2 = r, this.sy2 = o } else { if (null !== this.x2) { e.deltaX = n - this.x2, e.deltaY = s - this.y2; var l = Math.abs(this.x1 - this.x2), c = Math.abs(this.y1 - this.y2); (l > 10 || c > 10) && (this._preventTap = !0) } else e.deltaX = 0, e.deltaY = 0; this.pressMove.dispatch(e, this.element) } this.touchMove.dispatch(e, this.element), this._cancelLongTap(), this.x2 = n, this.y2 = s, i > 1 && e.preventDefault() } } }, { key: "end", value: function (e) { if (e.changedTouches) { this._cancelLongTap(); var t = this; e.touches.length < 2 && (this.multipointEnd.dispatch(e, this.element), this.sx2 = this.sy2 = null), this.x2 && Math.abs(this.x1 - this.x2) > 30 || this.y2 && Math.abs(this.y1 - this.y2) > 30 ? (e.direction = this._swipeDirection(this.x1, this.x2, this.y1, this.y2), this.swipeTimeout = setTimeout((function () { t.swipe.dispatch(e, t.element) }), 0)) : (this.tapTimeout = setTimeout((function () { t._preventTap || t.tap.dispatch(e, t.element), t.isDoubleTap && (t.doubleTap.dispatch(e, t.element), t.isDoubleTap = !1) }), 0), t.isDoubleTap || (t.singleTapTimeout = setTimeout((function () { t.singleTap.dispatch(e, t.element) }), 250))), this.touchEnd.dispatch(e, this.element), this.preV.x = 0, this.preV.y = 0, this.zoom = 1, this.pinchStartLen = null, this.x1 = this.x2 = this.y1 = this.y2 = null } } }, { key: "cancelAll", value: function () { this._preventTap = !0, clearTimeout(this.singleTapTimeout), clearTimeout(this.tapTimeout), clearTimeout(this.longTapTimeout), clearTimeout(this.swipeTimeout) } }, { key: "cancel", value: function (e) { this.cancelAll(), this.touchCancel.dispatch(e, this.element) } }, { key: "_cancelLongTap", value: function () { clearTimeout(this.longTapTimeout) } }, { key: "_cancelSingleTap", value: function () { clearTimeout(this.singleTapTimeout) } }, { key: "_swipeDirection", value: function (e, t, i, n) { return Math.abs(e - t) >= Math.abs(i - n) ? e - t > 0 ? "Left" : "Right" : i - n > 0 ? "Up" : "Down" } }, { key: "on", value: function (e, t) { this[e] && this[e].add(t) } }, { key: "off", value: function (e, t) { this[e] && this[e].del(t) } }, { key: "destroy", value: function () { return this.singleTapTimeout && clearTimeout(this.singleTapTimeout), this.tapTimeout && clearTimeout(this.tapTimeout), this.longTapTimeout && clearTimeout(this.longTapTimeout), this.swipeTimeout && clearTimeout(this.swipeTimeout), this.element.removeEventListener("touchstart", this.start), this.element.removeEventListener("touchmove", this.move), this.element.removeEventListener("touchend", this.end), this.element.removeEventListener("touchcancel", this.cancel), this.rotate.del(), this.touchStart.del(), this.multipointStart.del(), this.multipointEnd.del(), this.pinch.del(), this.swipe.del(), this.tap.del(), this.doubleTap.del(), this.longTap.del(), this.singleTap.del(), this.pressMove.del(), this.twoFingerPressMove.del(), this.touchMove.del(), this.touchEnd.del(), this.touchCancel.del(), this.preV = this.pinchStartLen = this.zoom = this.isDoubleTap = this.delta = this.last = this.now = this.tapTimeout = this.singleTapTimeout = this.longTapTimeout = this.swipeTimeout = this.x1 = this.x2 = this.y1 = this.y2 = this.preTapPosition = this.rotate = this.touchStart = this.multipointStart = this.multipointEnd = this.pinch = this.swipe = this.tap = this.doubleTap = this.longTap = this.singleTap = this.pressMove = this.touchMove = this.touchEnd = this.touchCancel = this.twoFingerPressMove = null, window.removeEventListener("scroll", this._cancelAllHandler), null } }]), e }(); function j(e) { var t = function () { var e, t = document.createElement("fakeelement"), i = { transition: "transitionend", OTransition: "oTransitionEnd", MozTransition: "transitionend", WebkitTransition: "webkitTransitionEnd" }; for (e in i) if (void 0 !== t.style[e]) return i[e] }(), i = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, n = u(e, "gslide-media") ? e : e.querySelector(".gslide-media"), s = h(n, ".ginner-container"), r = e.querySelector(".gslide-description"); i > 769 && (n = s), c(n, "greset"), f(n, "translate3d(0, 0, 0)"), l(t, { onElement: n, once: !0, withCallback: function (e, t) { d(n, "greset") } }), n.style.opacity = "", r && (r.style.opacity = "") } var F = function () { function e(i, n) { var s = this, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; if (t(this, e), this.img = i, this.slide = n, this.onclose = r, this.img.setZoomEvents) return !1; this.active = !1, this.zoomedIn = !1, this.dragging = !1, this.currentX = null, this.currentY = null, this.initialX = null, this.initialY = null, this.xOffset = 0, this.yOffset = 0, this.img.addEventListener("mousedown", (function (e) { return s.dragStart(e) }), !1), this.img.addEventListener("mouseup", (function (e) { return s.dragEnd(e) }), !1), this.img.addEventListener("mousemove", (function (e) { return s.drag(e) }), !1), this.img.addEventListener("click", (function (e) { return s.slide.classList.contains("dragging-nav") ? (s.zoomOut(), !1) : s.zoomedIn ? void (s.zoomedIn && !s.dragging && s.zoomOut()) : s.zoomIn() }), !1), this.img.setZoomEvents = !0 } return n(e, [{ key: "zoomIn", value: function () { var e = this.widowWidth(); if (!(this.zoomedIn || e <= 768)) { var t = this.img; if (t.setAttribute("data-style", t.getAttribute("style")), t.style.maxWidth = t.naturalWidth + "px", t.style.maxHeight = t.naturalHeight + "px", t.naturalWidth > e) { var i = e / 2 - t.naturalWidth / 2; this.setTranslate(this.img.parentNode, i, 0) } this.slide.classList.add("zoomed"), this.zoomedIn = !0 } } }, { key: "zoomOut", value: function () { this.img.parentNode.setAttribute("style", ""), this.img.setAttribute("style", this.img.getAttribute("data-style")), this.slide.classList.remove("zoomed"), this.zoomedIn = !1, this.currentX = null, this.currentY = null, this.initialX = null, this.initialY = null, this.xOffset = 0, this.yOffset = 0, this.onclose && "function" == typeof this.onclose && this.onclose() } }, { key: "dragStart", value: function (e) { e.preventDefault(), this.zoomedIn ? ("touchstart" === e.type ? (this.initialX = e.touches[0].clientX - this.xOffset, this.initialY = e.touches[0].clientY - this.yOffset) : (this.initialX = e.clientX - this.xOffset, this.initialY = e.clientY - this.yOffset), e.target === this.img && (this.active = !0, this.img.classList.add("dragging"))) : this.active = !1 } }, { key: "dragEnd", value: function (e) { var t = this; e.preventDefault(), this.initialX = this.currentX, this.initialY = this.currentY, this.active = !1, setTimeout((function () { t.dragging = !1, t.img.isDragging = !1, t.img.classList.remove("dragging") }), 100) } }, { key: "drag", value: function (e) { this.active && (e.preventDefault(), "touchmove" === e.type ? (this.currentX = e.touches[0].clientX - this.initialX, this.currentY = e.touches[0].clientY - this.initialY) : (this.currentX = e.clientX - this.initialX, this.currentY = e.clientY - this.initialY), this.xOffset = this.currentX, this.yOffset = this.currentY, this.img.isDragging = !0, this.dragging = !0, this.setTranslate(this.img, this.currentX, this.currentY)) } }, { key: "onMove", value: function (e) { if (this.zoomedIn) { var t = e.clientX - this.img.naturalWidth / 2, i = e.clientY - this.img.naturalHeight / 2; this.setTranslate(this.img, t, i) } } }, { key: "setTranslate", value: function (e, t, i) { e.style.transform = "translate3d(" + t + "px, " + i + "px, 0)" } }, { key: "widowWidth", value: function () { return window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth } }]), e }(), H = function () { function e() { var i = this, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t(this, e); var s = n.dragEl, r = n.toleranceX, o = void 0 === r ? 40 : r, a = n.toleranceY, l = void 0 === a ? 65 : a, c = n.slide, d = void 0 === c ? null : c, u = n.instance, h = void 0 === u ? null : u; this.el = s, this.active = !1, this.dragging = !1, this.currentX = null, this.currentY = null, this.initialX = null, this.initialY = null, this.xOffset = 0, this.yOffset = 0, this.direction = null, this.lastDirection = null, this.toleranceX = o, this.toleranceY = l, this.toleranceReached = !1, this.dragContainer = this.el, this.slide = d, this.instance = h, this.el.addEventListener("mousedown", (function (e) { return i.dragStart(e) }), !1), this.el.addEventListener("mouseup", (function (e) { return i.dragEnd(e) }), !1), this.el.addEventListener("mousemove", (function (e) { return i.drag(e) }), !1) } return n(e, [{ key: "dragStart", value: function (e) { if (this.slide.classList.contains("zoomed")) this.active = !1; else { "touchstart" === e.type ? (this.initialX = e.touches[0].clientX - this.xOffset, this.initialY = e.touches[0].clientY - this.yOffset) : (this.initialX = e.clientX - this.xOffset, this.initialY = e.clientY - this.yOffset); var t = e.target.nodeName.toLowerCase(); e.target.classList.contains("nodrag") || h(e.target, ".nodrag") || -1 !== ["input", "select", "textarea", "button", "a"].indexOf(t) ? this.active = !1 : (e.preventDefault(), (e.target === this.el || "img" !== t && h(e.target, ".gslide-inline")) && (this.active = !0, this.el.classList.add("dragging"), this.dragContainer = h(e.target, ".ginner-container"))) } } }, { key: "dragEnd", value: function (e) { var t = this; e && e.preventDefault(), this.initialX = 0, this.initialY = 0, this.currentX = null, this.currentY = null, this.initialX = null, this.initialY = null, this.xOffset = 0, this.yOffset = 0, this.active = !1, this.doSlideChange && (this.instance.preventOutsideClick = !0, "right" == this.doSlideChange && this.instance.prevSlide(), "left" == this.doSlideChange && this.instance.nextSlide()), this.doSlideClose && this.instance.close(), this.toleranceReached || this.setTranslate(this.dragContainer, 0, 0, !0), setTimeout((function () { t.instance.preventOutsideClick = !1, t.toleranceReached = !1, t.lastDirection = null, t.dragging = !1, t.el.isDragging = !1, t.el.classList.remove("dragging"), t.slide.classList.remove("dragging-nav"), t.dragContainer.style.transform = "", t.dragContainer.style.transition = "" }), 100) } }, { key: "drag", value: function (e) { if (this.active) { e.preventDefault(), this.slide.classList.add("dragging-nav"), "touchmove" === e.type ? (this.currentX = e.touches[0].clientX - this.initialX, this.currentY = e.touches[0].clientY - this.initialY) : (this.currentX = e.clientX - this.initialX, this.currentY = e.clientY - this.initialY), this.xOffset = this.currentX, this.yOffset = this.currentY, this.el.isDragging = !0, this.dragging = !0, this.doSlideChange = !1, this.doSlideClose = !1; var t = Math.abs(this.currentX), i = Math.abs(this.currentY); if (t > 0 && t >= Math.abs(this.currentY) && (!this.lastDirection || "x" == this.lastDirection)) { this.yOffset = 0, this.lastDirection = "x", this.setTranslate(this.dragContainer, this.currentX, 0); var n = this.shouldChange(); if (!this.instance.settings.dragAutoSnap && n && (this.doSlideChange = n), this.instance.settings.dragAutoSnap && n) return this.instance.preventOutsideClick = !0, this.toleranceReached = !0, this.active = !1, this.instance.preventOutsideClick = !0, this.dragEnd(null), "right" == n && this.instance.prevSlide(), void ("left" == n && this.instance.nextSlide()) } if (this.toleranceY > 0 && i > 0 && i >= t && (!this.lastDirection || "y" == this.lastDirection)) { this.xOffset = 0, this.lastDirection = "y", this.setTranslate(this.dragContainer, 0, this.currentY); var s = this.shouldClose(); return !this.instance.settings.dragAutoSnap && s && (this.doSlideClose = !0), void (this.instance.settings.dragAutoSnap && s && this.instance.close()) } } } }, { key: "shouldChange", value: function () { var e = !1; if (Math.abs(this.currentX) >= this.toleranceX) { var t = this.currentX > 0 ? "right" : "left"; ("left" == t && this.slide !== this.slide.parentNode.lastChild || "right" == t && this.slide !== this.slide.parentNode.firstChild) && (e = t) } return e } }, { key: "shouldClose", value: function () { var e = !1; return Math.abs(this.currentY) >= this.toleranceY && (e = !0), e } }, { key: "setTranslate", value: function (e, t, i) { var n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; e.style.transition = n ? "all .2s ease" : "", e.style.transform = "translate3d(".concat(t, "px, ").concat(i, "px, 0)") } }]), e }(); function q(e, t, i, n) { var s = this, r = e.querySelector(".ginner-container"), o = "gvideo" + i, a = e.querySelector(".gslide-media"), l = this.getAllPlayers(); c(r, "gvideo-container"), a.insertBefore(v('<div class="gvideo-wrapper"></div>'), a.firstChild); var d = e.querySelector(".gvideo-wrapper"); w(this.settings.plyr.css, "Plyr"); var u = t.href, h = null == t ? void 0 : t.videoProvider, p = !1; a.style.maxWidth = t.width, w(this.settings.plyr.js, "Plyr", (function () { if (!h && u.match(/vimeo\.com\/([0-9]*)/) && (h = "vimeo"), !h && (u.match(/(youtube\.com|youtube-nocookie\.com)\/watch\?v=([a-zA-Z0-9\-_]+)/) || u.match(/youtu\.be\/([a-zA-Z0-9\-_]+)/) || u.match(/(youtube\.com|youtube-nocookie\.com)\/embed\/([a-zA-Z0-9\-_]+)/)) && (h = "youtube"), "local" === h || !h) { h = "local"; var r = '<video id="' + o + '" '; r += 'style="background:#000; max-width: '.concat(t.width, ';" '), r += 'preload="metadata" ', r += 'poster="' + t.poster + '" ', r += 'x-webkit-airplay="allow" ', r += "playsinline ", r += "controls ", r += 'class="gvideo-local">', r += '<source src="'.concat(u, '">'), p = v(r += "</video>") } var a = p || v('<div id="'.concat(o, '" data-plyr-provider="').concat(h, '" data-plyr-embed-id="').concat(u, '"></div>')); c(d, "".concat(h, "-video gvideo")), d.appendChild(a), d.setAttribute("data-id", o), d.setAttribute("data-index", i); var f = $(s.settings.plyr, "config") ? s.settings.plyr.config : {}, m = new Plyr("#" + o, f); m.on("ready", (function (e) { l[o] = e.detail.plyr, _(n) && n() })), b((function () { return e.querySelector("iframe") && "true" == e.querySelector("iframe").dataset.ready }), (function () { s.resize(e) })), m.on("enterfullscreen", B), m.on("exitfullscreen", B) })) } function B(e) { var t = h(e.target, ".gslide-media"); "enterfullscreen" === e.type && c(t, "fullscreen"), "exitfullscreen" === e.type && d(t, "fullscreen") } function R(e, t, i, n) { var s, r = this, o = e.querySelector(".gslide-media"), a = !(!$(t, "href") || !t.href) && t.href.split("#").pop().trim(), d = !(!$(t, "content") || !t.content) && t.content; if (d && (T(d) && (s = v('<div class="ginlined-content">'.concat(d, "</div>"))), E(d))) { "none" == d.style.display && (d.style.display = "block"); var u = document.createElement("div"); u.className = "ginlined-content", u.appendChild(d), s = u } if (a) { var h = document.getElementById(a); if (!h) return !1; var p = h.cloneNode(!0); p.style.height = t.height, p.style.maxWidth = t.width, c(p, "ginlined-content"), s = p } if (!s) return console.error("Unable to append inline slide content", t), !1; o.style.height = t.height, o.style.width = t.width, o.appendChild(s), this.events["inlineclose" + a] = l("click", { onElement: o.querySelectorAll(".gtrigger-close"), withCallback: function (e) { e.preventDefault(), r.close() } }), _(n) && n() } function W(e, t, i, n) { var s = e.querySelector(".gslide-media"), r = function (e) { var t = e.url, i = e.allow, n = e.callback, s = e.appendTo, r = document.createElement("iframe"); return r.className = "vimeo-video gvideo", r.src = t, r.style.width = "100%", r.style.height = "100%", i && r.setAttribute("allow", i), r.onload = function () { r.onload = null, c(r, "node-ready"), _(n) && n() }, s && s.appendChild(r), r }({ url: t.href, callback: n }); s.parentNode.style.maxWidth = t.width, s.parentNode.style.height = t.height, s.appendChild(r) } var Y = function () { function e() { var i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t(this, e), this.defaults = { href: "", sizes: "", srcset: "", title: "", type: "", videoProvider: "", description: "", alt: "", descPosition: "bottom", effect: "", width: "", height: "", content: !1, zoomable: !0, draggable: !0 }, k(i) && (this.defaults = r(this.defaults, i)) } return n(e, [{ key: "sourceType", value: function (e) { var t = e; if (null !== (e = e.toLowerCase()).match(/\.(jpeg|jpg|jpe|gif|png|apn|webp|avif|svg)/)) return "image"; if (e.match(/(youtube\.com|youtube-nocookie\.com)\/watch\?v=([a-zA-Z0-9\-_]+)/) || e.match(/youtu\.be\/([a-zA-Z0-9\-_]+)/) || e.match(/(youtube\.com|youtube-nocookie\.com)\/embed\/([a-zA-Z0-9\-_]+)/)) return "video"; if (e.match(/vimeo\.com\/([0-9]*)/)) return "video"; if (null !== e.match(/\.(mp4|ogg|webm|mov)/)) return "video"; if (null !== e.match(/\.(mp3|wav|wma|aac|ogg)/)) return "audio"; if (e.indexOf("#") > -1 && "" !== t.split("#").pop().trim()) return "inline"; return e.indexOf("goajax=true") > -1 ? "ajax" : "external" } }, { key: "parseConfig", value: function (e, t) { var i = this, n = r({ descPosition: t.descPosition }, this.defaults); if (k(e) && !E(e)) { $(e, "type") || ($(e, "content") && e.content ? e.type = "inline" : $(e, "href") && (e.type = this.sourceType(e.href))); var s = r(n, e); return this.setSize(s, t), s } var a = "", l = e.getAttribute("data-glightbox"), c = e.nodeName.toLowerCase(); if ("a" === c && (a = e.href), "img" === c && (a = e.src, n.alt = e.alt), n.href = a, o(n, (function (s, r) { $(t, r) && "width" !== r && (n[r] = t[r]); var o = e.dataset[r]; A(o) || (n[r] = i.sanitizeValue(o)) })), n.content && (n.type = "inline"), !n.type && a && (n.type = this.sourceType(a)), A(l)) { if (!n.title && "a" == c) { var d = e.title; A(d) || "" === d || (n.title = d) } if (!n.title && "img" == c) { var u = e.alt; A(u) || "" === u || (n.title = u) } } else { var h = []; o(n, (function (e, t) { h.push(";\\s?" + t) })), h = h.join("\\s?:|"), "" !== l.trim() && o(n, (function (e, t) { var s = l, r = new RegExp("s?" + t + "s?:s?(.*?)(" + h + "s?:|$)"), o = s.match(r); if (o && o.length && o[1]) { var a = o[1].trim().replace(/;\s*$/, ""); n[t] = i.sanitizeValue(a) } })) } if (n.description && "." === n.description.substring(0, 1)) { var p; try { p = document.querySelector(n.description).innerHTML } catch (e) { if (!(e instanceof DOMException)) throw e } p && (n.description = p) } if (!n.description) { var f = e.querySelector(".glightbox-desc"); f && (n.description = f.innerHTML) } return this.setSize(n, t, e), this.slideConfig = n, n } }, { key: "setSize", value: function (e, t) { var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, n = "video" == e.type ? this.checkSize(t.videosWidth) : this.checkSize(t.width), s = this.checkSize(t.height); return e.width = $(e, "width") && "" !== e.width ? this.checkSize(e.width) : n, e.height = $(e, "height") && "" !== e.height ? this.checkSize(e.height) : s, i && "image" == e.type && (e._hasCustomWidth = !!i.dataset.width, e._hasCustomHeight = !!i.dataset.height), e } }, { key: "checkSize", value: function (e) { return P(e) ? "".concat(e, "px") : e } }, { key: "sanitizeValue", value: function (e) { return "true" !== e && "false" !== e ? e : "true" === e } }]), e }(), X = function () { function e(i, n, s) { t(this, e), this.element = i, this.instance = n, this.index = s } return n(e, [{ key: "setContent", value: function () { var e = this, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (u(t, "loaded")) return !1; var n = this.instance.settings, s = this.slideConfig, r = x(); _(n.beforeSlideLoad) && n.beforeSlideLoad({ index: this.index, slide: t, player: !1 }); var o = s.type, a = s.descPosition, l = t.querySelector(".gslide-media"), d = t.querySelector(".gslide-title"), h = t.querySelector(".gslide-desc"), p = t.querySelector(".gdesc-inner"), f = i, m = "gSlideTitle_" + this.index, g = "gSlideDesc_" + this.index; if (_(n.afterSlideLoad) && (f = function () { _(i) && i(), n.afterSlideLoad({ index: e.index, slide: t, player: e.instance.getSlidePlayerInstance(e.index) }) }), "" == s.title && "" == s.description ? p && p.parentNode.parentNode.removeChild(p.parentNode) : (d && "" !== s.title ? (d.id = m, d.innerHTML = s.title) : d.parentNode.removeChild(d), h && "" !== s.description ? (h.id = g, r && n.moreLength > 0 ? (s.smallDescription = this.slideShortDesc(s.description, n.moreLength, n.moreText), h.innerHTML = s.smallDescription, this.descriptionEvents(h, s)) : h.innerHTML = s.description) : h.parentNode.removeChild(h), c(l.parentNode, "desc-".concat(a)), c(p.parentNode, "description-".concat(a))), c(l, "gslide-".concat(o)), c(t, "loaded"), "video" !== o) { if ("external" !== o) return "inline" === o ? (R.apply(this.instance, [t, s, this.index, f]), void (s.draggable && new H({ dragEl: t.querySelector(".gslide-inline"), toleranceX: n.dragToleranceX, toleranceY: n.dragToleranceY, slide: t, instance: this.instance }))) : void ("image" !== o ? _(f) && f() : function (e, t, i, n) { var s = e.querySelector(".gslide-media"), r = new Image, o = "gSlideTitle_" + i, a = "gSlideDesc_" + i; r.addEventListener("load", (function () { _(n) && n() }), !1), r.src = t.href, "" != t.sizes && "" != t.srcset && (r.sizes = t.sizes, r.srcset = t.srcset), r.alt = "", A(t.alt) || "" === t.alt || (r.alt = t.alt), "" !== t.title && r.setAttribute("aria-labelledby", o), "" !== t.description && r.setAttribute("aria-describedby", a), t.hasOwnProperty("_hasCustomWidth") && t._hasCustomWidth && (r.style.width = t.width), t.hasOwnProperty("_hasCustomHeight") && t._hasCustomHeight && (r.style.height = t.height), s.insertBefore(r, s.firstChild) }(t, s, this.index, (function () { var i = t.querySelector("img"); s.draggable && new H({ dragEl: i, toleranceX: n.dragToleranceX, toleranceY: n.dragToleranceY, slide: t, instance: e.instance }), s.zoomable && i.naturalWidth > i.offsetWidth && (c(i, "zoomable"), new F(i, t, (function () { e.instance.resize() }))), _(f) && f() }))); W.apply(this, [t, s, this.index, f]) } else q.apply(this.instance, [t, s, this.index, f]) } }, { key: "slideShortDesc", value: function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 50, i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n = document.createElement("div"); n.innerHTML = e; var s = i; if ((e = n.innerText.trim()).length <= t) return e; var r = e.substr(0, t - 1); return s ? (n = null, r + '... <a href="#" class="desc-more">' + i + "</a>") : r } }, { key: "descriptionEvents", value: function (e, t) { var i = this, n = e.querySelector(".desc-more"); if (!n) return !1; l("click", { onElement: n, withCallback: function (e, n) { e.preventDefault(); var s = document.body, r = h(n, ".gslide-desc"); if (!r) return !1; r.innerHTML = t.description, c(s, "gdesc-open"); var o = l("click", { onElement: [s, h(r, ".gslide-description")], withCallback: function (e, n) { "a" !== e.target.nodeName.toLowerCase() && (d(s, "gdesc-open"), c(s, "gdesc-closed"), r.innerHTML = t.smallDescription, i.descriptionEvents(r, t), setTimeout((function () { d(s, "gdesc-closed") }), 400), o.destroy()) } }) } }) } }, { key: "create", value: function () { return v(this.instance.settings.slideHTML) } }, { key: "getConfig", value: function () { E(this.element) || this.element.hasOwnProperty("draggable") || (this.element.draggable = this.instance.settings.draggable); var e = new Y(this.instance.settings.slideExtraAttributes); return this.slideConfig = e.parseConfig(this.element, this.instance.settings), this.slideConfig } }]), e }(), V = x(), G = null !== x() || void 0 !== document.createTouch || "ontouchstart" in window || "onmsgesturechange" in window || navigator.msMaxTouchPoints, U = document.getElementsByTagName("html")[0], Q = { selector: ".glightbox", elements: null, skin: "clean", theme: "clean", closeButton: !0, startAt: null, autoplayVideos: !0, autofocusVideos: !0, descPosition: "bottom", width: "900px", height: "506px", videosWidth: "960px", beforeSlideChange: null, afterSlideChange: null, beforeSlideLoad: null, afterSlideLoad: null, slideInserted: null, slideRemoved: null, slideExtraAttributes: null, onOpen: null, onClose: null, loop: !1, zoomable: !0, draggable: !0, dragAutoSnap: !1, dragToleranceX: 40, dragToleranceY: 65, preload: !0, oneSlidePerOpen: !1, touchNavigation: !0, touchFollowAxis: !0, keyboardNavigation: !0, closeOnOutsideClick: !0, plugins: !1, plyr: { css: "https://cdn.plyr.io/3.6.12/plyr.css", js: "https://cdn.plyr.io/3.6.12/plyr.js", config: { ratio: "16:9", fullscreen: { enabled: !0, iosNative: !0 }, youtube: { noCookie: !0, rel: 0, showinfo: 0, iv_load_policy: 3 }, vimeo: { byline: !1, portrait: !1, title: !1, transparent: !1 } } }, openEffect: "zoom", closeEffect: "zoom", slideEffect: "slide", moreText: "See more", moreLength: 60, cssEfects: { fade: { in: "fadeIn", out: "fadeOut" }, zoom: { in: "zoomIn", out: "zoomOut" }, slide: { in: "slideInRight", out: "slideOutLeft" }, slideBack: { in: "slideInLeft", out: "slideOutRight" }, none: { in: "none", out: "none" } }, svg: { close: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 512 512" xml:space="preserve"><g><g><path d="M505.943,6.058c-8.077-8.077-21.172-8.077-29.249,0L6.058,476.693c-8.077,8.077-8.077,21.172,0,29.249C10.096,509.982,15.39,512,20.683,512c5.293,0,10.586-2.019,14.625-6.059L505.943,35.306C514.019,27.23,514.019,14.135,505.943,6.058z"/></g></g><g><g><path d="M505.942,476.694L35.306,6.059c-8.076-8.077-21.172-8.077-29.248,0c-8.077,8.076-8.077,21.171,0,29.248l470.636,470.636c4.038,4.039,9.332,6.058,14.625,6.058c5.293,0,10.587-2.019,14.624-6.057C514.018,497.866,514.018,484.771,505.942,476.694z"/></g></g></svg>', next: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 477.175 477.175" xml:space="preserve"> <g><path d="M360.731,229.075l-225.1-225.1c-5.3-5.3-13.8-5.3-19.1,0s-5.3,13.8,0,19.1l215.5,215.5l-215.5,215.5c-5.3,5.3-5.3,13.8,0,19.1c2.6,2.6,6.1,4,9.5,4c3.4,0,6.9-1.3,9.5-4l225.1-225.1C365.931,242.875,365.931,234.275,360.731,229.075z"/></g></svg>', prev: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 477.175 477.175" xml:space="preserve"><g><path d="M145.188,238.575l215.5-215.5c5.3-5.3,5.3-13.8,0-19.1s-13.8-5.3-19.1,0l-225.1,225.1c-5.3,5.3-5.3,13.8,0,19.1l225.1,225c2.6,2.6,6.1,4,9.5,4s6.9-1.3,9.5-4c5.3-5.3,5.3-13.8,0-19.1L145.188,238.575z"/></g></svg>' }, slideHTML: '<div class="gslide">\n    <div class="gslide-inner-content">\n        <div class="ginner-container">\n            <div class="gslide-media">\n            </div>\n            <div class="gslide-description">\n                <div class="gdesc-inner">\n                    <h4 class="gslide-title"></h4>\n                    <div class="gslide-desc"></div>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>', lightboxHTML: '<div id="glightbox-body" class="glightbox-container" tabindex="-1" role="dialog" aria-hidden="false">\n    <div class="gloader visible"></div>\n    <div class="goverlay"></div>\n    <div class="gcontainer">\n    <div id="glightbox-slider" class="gslider"></div>\n    <button class="gclose gbtn" aria-label="Close" data-taborder="3">{closeSVG}</button>\n    <button class="gprev gbtn" aria-label="Previous" data-taborder="2">{prevSVG}</button>\n    <button class="gnext gbtn" aria-label="Next" data-taborder="1">{nextSVG}</button>\n</div>\n</div>' }, K = function () { function e() { var i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t(this, e), this.customOptions = i, this.settings = r(Q, i), this.effectsClasses = this.getAnimationClasses(), this.videoPlayers = {}, this.apiEvents = [], this.fullElementsList = !1 } return n(e, [{ key: "init", value: function () { var e = this, t = this.getSelector(); t && (this.baseEvents = l("click", { onElement: t, withCallback: function (t, i) { t.preventDefault(), e.open(i) } })), this.elements = this.getElements() } }, { key: "open", value: function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; if (0 === this.elements.length) return !1; this.activeSlide = null, this.prevActiveSlideIndex = null, this.prevActiveSlide = null; var i = P(t) ? t : this.settings.startAt; if (E(e)) { var n = e.getAttribute("data-gallery"); n && (this.fullElementsList = this.elements, this.elements = this.getGalleryElements(this.elements, n)), A(i) && (i = this.getElementIndex(e)) < 0 && (i = 0) } P(i) || (i = 0), this.build(), p(this.overlay, "none" === this.settings.openEffect ? "none" : this.settings.cssEfects.fade.in); var s = document.body; if (window.innerWidth - document.documentElement.clientWidth > 0) { var r = document.createElement("style"); r.type = "text/css", r.className = "gcss-styles", document.head.appendChild(r), c(s, "gscrollbar-fixer") } c(s, "glightbox-open"), c(U, "glightbox-open"), V && (c(document.body, "glightbox-mobile"), this.settings.slideEffect = "slide", this.settings.autoplayVideos = !1), this.showSlide(i, !0), 1 === this.elements.length ? (c(this.prevButton, "glightbox-button-hidden"), c(this.nextButton, "glightbox-button-hidden")) : (d(this.prevButton, "glightbox-button-hidden"), d(this.nextButton, "glightbox-button-hidden")), this.lightboxOpen = !0, this.trigger("open"), _(this.settings.onOpen) && this.settings.onOpen(), G && this.settings.touchNavigation && function (e) { if (e.events.hasOwnProperty("touch")) return !1; var t, i, n, s = y(), r = s.width, o = s.height, a = !1, l = null, p = null, m = null, g = !1, v = 1, b = 1, w = !1, x = !1, _ = null, T = null, E = null, S = null, C = 0, k = 0, A = !1, $ = !1, M = {}, P = {}, I = 0, L = 0, O = document.getElementById("glightbox-slider"), z = document.querySelector(".goverlay"), D = new N(O, { touchStart: function (t) { if (a = !0, (u(t.targetTouches[0].target, "ginner-container") || h(t.targetTouches[0].target, ".gslide-desc") || "a" == t.targetTouches[0].target.nodeName.toLowerCase()) && (a = !1), h(t.targetTouches[0].target, ".gslide-inline") && !u(t.targetTouches[0].target.parentNode, "gslide-inline") && (a = !1), a) { if (P = t.targetTouches[0], M.pageX = t.targetTouches[0].pageX, M.pageY = t.targetTouches[0].pageY, I = t.targetTouches[0].clientX, L = t.targetTouches[0].clientY, l = e.activeSlide, p = l.querySelector(".gslide-media"), n = l.querySelector(".gslide-inline"), m = null, u(p, "gslide-image") && (m = p.querySelector("img")), (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth) > 769 && (p = l.querySelector(".ginner-container")), d(z, "greset"), t.pageX > 20 && t.pageX < window.innerWidth - 20) return; t.preventDefault() } }, touchMove: function (s) { if (a && (P = s.targetTouches[0], !w && !x)) { if (n && n.offsetHeight > o) { var l = M.pageX - P.pageX; if (Math.abs(l) <= 13) return !1 } g = !0; var c, d = s.targetTouches[0].clientX, u = s.targetTouches[0].clientY, h = I - d, v = L - u; if (Math.abs(h) > Math.abs(v) ? (A = !1, $ = !0) : ($ = !1, A = !0), t = P.pageX - M.pageX, C = 100 * t / r, i = P.pageY - M.pageY, k = 100 * i / o, A && m && (c = 1 - Math.abs(i) / o, z.style.opacity = c, e.settings.touchFollowAxis && (C = 0)), $ && (c = 1 - Math.abs(t) / r, p.style.opacity = c, e.settings.touchFollowAxis && (k = 0)), !m) return f(p, "translate3d(".concat(C, "%, 0, 0)")); f(p, "translate3d(".concat(C, "%, ").concat(k, "%, 0)")) } }, touchEnd: function () { if (a) { if (g = !1, x || w) return E = _, void (S = T); var t = Math.abs(parseInt(k)), i = Math.abs(parseInt(C)); if (!(t > 29 && m)) return t < 29 && i < 25 ? (c(z, "greset"), z.style.opacity = 1, j(p)) : void 0; e.close() } }, multipointEnd: function () { setTimeout((function () { w = !1 }), 50) }, multipointStart: function () { w = !0, v = b || 1 }, pinch: function (e) { if (!m || g) return !1; w = !0, m.scaleX = m.scaleY = v * e.zoom; var t = v * e.zoom; if (x = !0, t <= 1) return x = !1, t = 1, S = null, E = null, _ = null, T = null, void m.setAttribute("style", ""); t > 4.5 && (t = 4.5), m.style.transform = "scale3d(".concat(t, ", ").concat(t, ", 1)"), b = t }, pressMove: function (e) { if (x && !w) { var t = P.pageX - M.pageX, i = P.pageY - M.pageY; E && (t += E), S && (i += S), _ = t, T = i; var n = "translate3d(".concat(t, "px, ").concat(i, "px, 0)"); b && (n += " scale3d(".concat(b, ", ").concat(b, ", 1)")), f(m, n) } }, swipe: function (t) { if (!x) if (w) w = !1; else { if ("Left" == t.direction) { if (e.index == e.elements.length - 1) return j(p); e.nextSlide() } if ("Right" == t.direction) { if (0 == e.index) return j(p); e.prevSlide() } } } }); e.events.touch = D }(this), this.settings.keyboardNavigation && function (e) { if (e.events.hasOwnProperty("keyboard")) return !1; e.events.keyboard = l("keydown", { onElement: window, withCallback: function (t, i) { var n = (t = t || window.event).keyCode; if (9 == n) { var s = document.querySelector(".gbtn.focused"); if (!s) { var r = !(!document.activeElement || !document.activeElement.nodeName) && document.activeElement.nodeName.toLocaleLowerCase(); if ("input" == r || "textarea" == r || "button" == r) return } t.preventDefault(); var o = document.querySelectorAll(".gbtn[data-taborder]"); if (!o || o.length <= 0) return; if (!s) { var a = I(); return void (a && (a.focus(), c(a, "focused"))) } var l = I(s.getAttribute("data-taborder")); d(s, "focused"), l && (l.focus(), c(l, "focused")) } 39 == n && e.nextSlide(), 37 == n && e.prevSlide(), 27 == n && e.close() } }) }(this) } }, { key: "openAt", value: function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; this.open(null, e) } }, { key: "showSlide", value: function () { var e = this, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; m(this.loader), this.index = parseInt(t); var n = this.slidesContainer.querySelector(".current"); n && d(n, "current"), this.slideAnimateOut(); var s = this.slidesContainer.querySelectorAll(".gslide")[t]; if (u(s, "loaded")) this.slideAnimateIn(s, i), g(this.loader); else { m(this.loader); var r = this.elements[t], o = { index: this.index, slide: s, slideNode: s, slideConfig: r.slideConfig, slideIndex: this.index, trigger: r.node, player: null }; this.trigger("slide_before_load", o), r.instance.setContent(s, (function () { g(e.loader), e.resize(), e.slideAnimateIn(s, i), e.trigger("slide_after_load", o) })) } this.slideDescription = s.querySelector(".gslide-description"), this.slideDescriptionContained = this.slideDescription && u(this.slideDescription.parentNode, "gslide-media"), this.settings.preload && (this.preloadSlide(t + 1), this.preloadSlide(t - 1)), this.updateNavigationClasses(), this.activeSlide = s } }, { key: "preloadSlide", value: function (e) { var t = this; if (e < 0 || e > this.elements.length - 1) return !1; if (A(this.elements[e])) return !1; var i = this.slidesContainer.querySelectorAll(".gslide")[e]; if (u(i, "loaded")) return !1; var n = this.elements[e], s = n.type, r = { index: e, slide: i, slideNode: i, slideConfig: n.slideConfig, slideIndex: e, trigger: n.node, player: null }; this.trigger("slide_before_load", r), "video" === s || "external" === s ? setTimeout((function () { n.instance.setContent(i, (function () { t.trigger("slide_after_load", r) })) }), 200) : n.instance.setContent(i, (function () { t.trigger("slide_after_load", r) })) } }, { key: "prevSlide", value: function () { this.goToSlide(this.index - 1) } }, { key: "nextSlide", value: function () { this.goToSlide(this.index + 1) } }, { key: "goToSlide", value: function () { var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; if (this.prevActiveSlide = this.activeSlide, this.prevActiveSlideIndex = this.index, !this.loop() && (e < 0 || e > this.elements.length - 1)) return !1; e < 0 ? e = this.elements.length - 1 : e >= this.elements.length && (e = 0), this.showSlide(e) } }, { key: "insertSlide", value: function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1; t < 0 && (t = this.elements.length); var i = new X(e, this, t), n = i.getConfig(), s = r({}, n), o = i.create(), a = this.elements.length - 1; s.index = t, s.node = !1, s.instance = i, s.slideConfig = n, this.elements.splice(t, 0, s); var l = null, c = null; if (this.slidesContainer) { if (t > a) this.slidesContainer.appendChild(o); else { var d = this.slidesContainer.querySelectorAll(".gslide")[t]; this.slidesContainer.insertBefore(o, d) } (this.settings.preload && 0 == this.index && 0 == t || this.index - 1 == t || this.index + 1 == t) && this.preloadSlide(t), 0 === this.index && 0 === t && (this.index = 1), this.updateNavigationClasses(), l = this.slidesContainer.querySelectorAll(".gslide")[t], c = this.getSlidePlayerInstance(t), s.slideNode = l } this.trigger("slide_inserted", { index: t, slide: l, slideNode: l, slideConfig: n, slideIndex: t, trigger: null, player: c }), _(this.settings.slideInserted) && this.settings.slideInserted({ index: t, slide: l, player: c }) } }, { key: "removeSlide", value: function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1; if (e < 0 || e > this.elements.length - 1) return !1; var t = this.slidesContainer && this.slidesContainer.querySelectorAll(".gslide")[e]; t && (this.getActiveSlideIndex() == e && (e == this.elements.length - 1 ? this.prevSlide() : this.nextSlide()), t.parentNode.removeChild(t)), this.elements.splice(e, 1), this.trigger("slide_removed", e), _(this.settings.slideRemoved) && this.settings.slideRemoved(e) } }, { key: "slideAnimateIn", value: function (e, t) { var i = this, n = e.querySelector(".gslide-media"), s = e.querySelector(".gslide-description"), r = { index: this.prevActiveSlideIndex, slide: this.prevActiveSlide, slideNode: this.prevActiveSlide, slideIndex: this.prevActiveSlide, slideConfig: A(this.prevActiveSlideIndex) ? null : this.elements[this.prevActiveSlideIndex].slideConfig, trigger: A(this.prevActiveSlideIndex) ? null : this.elements[this.prevActiveSlideIndex].node, player: this.getSlidePlayerInstance(this.prevActiveSlideIndex) }, o = { index: this.index, slide: this.activeSlide, slideNode: this.activeSlide, slideConfig: this.elements[this.index].slideConfig, slideIndex: this.index, trigger: this.elements[this.index].node, player: this.getSlidePlayerInstance(this.index) }; if (n.offsetWidth > 0 && s && (g(s), s.style.display = ""), d(e, this.effectsClasses), t) p(e, this.settings.cssEfects[this.settings.openEffect].in, (function () { i.settings.autoplayVideos && i.slidePlayerPlay(e), i.trigger("slide_changed", { prev: r, current: o }), _(i.settings.afterSlideChange) && i.settings.afterSlideChange.apply(i, [r, o]) })); else { var a = this.settings.slideEffect, l = "none" !== a ? this.settings.cssEfects[a].in : a; this.prevActiveSlideIndex > this.index && "slide" == this.settings.slideEffect && (l = this.settings.cssEfects.slideBack.in), p(e, l, (function () { i.settings.autoplayVideos && i.slidePlayerPlay(e), i.trigger("slide_changed", { prev: r, current: o }), _(i.settings.afterSlideChange) && i.settings.afterSlideChange.apply(i, [r, o]) })) } setTimeout((function () { i.resize(e) }), 100), c(e, "current") } }, { key: "slideAnimateOut", value: function () { if (!this.prevActiveSlide) return !1; var e = this.prevActiveSlide; d(e, this.effectsClasses), c(e, "prev"); var t = this.settings.slideEffect, i = "none" !== t ? this.settings.cssEfects[t].out : t; this.slidePlayerPause(e), this.trigger("slide_before_change", { prev: { index: this.prevActiveSlideIndex, slide: this.prevActiveSlide, slideNode: this.prevActiveSlide, slideIndex: this.prevActiveSlideIndex, slideConfig: A(this.prevActiveSlideIndex) ? null : this.elements[this.prevActiveSlideIndex].slideConfig, trigger: A(this.prevActiveSlideIndex) ? null : this.elements[this.prevActiveSlideIndex].node, player: this.getSlidePlayerInstance(this.prevActiveSlideIndex) }, current: { index: this.index, slide: this.activeSlide, slideNode: this.activeSlide, slideIndex: this.index, slideConfig: this.elements[this.index].slideConfig, trigger: this.elements[this.index].node, player: this.getSlidePlayerInstance(this.index) } }), _(this.settings.beforeSlideChange) && this.settings.beforeSlideChange.apply(this, [{ index: this.prevActiveSlideIndex, slide: this.prevActiveSlide, player: this.getSlidePlayerInstance(this.prevActiveSlideIndex) }, { index: this.index, slide: this.activeSlide, player: this.getSlidePlayerInstance(this.index) }]), this.prevActiveSlideIndex > this.index && "slide" == this.settings.slideEffect && (i = this.settings.cssEfects.slideBack.out), p(e, i, (function () { var t = e.querySelector(".ginner-container"), i = e.querySelector(".gslide-media"), n = e.querySelector(".gslide-description"); t.style.transform = "", i.style.transform = "", d(i, "greset"), i.style.opacity = "", n && (n.style.opacity = ""), d(e, "prev") })) } }, { key: "getAllPlayers", value: function () { return this.videoPlayers } }, { key: "getSlidePlayerInstance", value: function (e) { var t = "gvideo" + e, i = this.getAllPlayers(); return !(!$(i, t) || !i[t]) && i[t] } }, { key: "stopSlideVideo", value: function (e) { if (E(e)) { var t = e.querySelector(".gvideo-wrapper"); t && (e = t.getAttribute("data-index")) } console.log("stopSlideVideo is deprecated, use slidePlayerPause"); var i = this.getSlidePlayerInstance(e); i && i.playing && i.pause() } }, { key: "slidePlayerPause", value: function (e) { if (E(e)) { var t = e.querySelector(".gvideo-wrapper"); t && (e = t.getAttribute("data-index")) } var i = this.getSlidePlayerInstance(e); i && i.playing && i.pause() } }, { key: "playSlideVideo", value: function (e) { if (E(e)) { var t = e.querySelector(".gvideo-wrapper"); t && (e = t.getAttribute("data-index")) } console.log("playSlideVideo is deprecated, use slidePlayerPlay"); var i = this.getSlidePlayerInstance(e); i && !i.playing && i.play() } }, { key: "slidePlayerPlay", value: function (e) { var t; if (!V || null !== (t = this.settings.plyr.config) && void 0 !== t && t.muted) { if (E(e)) { var i = e.querySelector(".gvideo-wrapper"); i && (e = i.getAttribute("data-index")) } var n = this.getSlidePlayerInstance(e); n && !n.playing && (n.play(), this.settings.autofocusVideos && n.elements.container.focus()) } } }, { key: "setElements", value: function (e) { var t = this; this.settings.elements = !1; var i = []; e && e.length && o(e, (function (e, n) { var s = new X(e, t, n), o = s.getConfig(), a = r({}, o); a.slideConfig = o, a.instance = s, a.index = n, i.push(a) })), this.elements = i, this.lightboxOpen && (this.slidesContainer.innerHTML = "", this.elements.length && (o(this.elements, (function () { var e = v(t.settings.slideHTML); t.slidesContainer.appendChild(e) })), this.showSlide(0, !0))) } }, { key: "getElementIndex", value: function (e) { var t = !1; return o(this.elements, (function (i, n) { if ($(i, "node") && i.node == e) return t = n, !0 })), t } }, { key: "getElements", value: function () { var e = this, t = []; this.elements = this.elements ? this.elements : [], !A(this.settings.elements) && S(this.settings.elements) && this.settings.elements.length && o(this.settings.elements, (function (i, n) { var s = new X(i, e, n), o = s.getConfig(), a = r({}, o); a.node = !1, a.index = n, a.instance = s, a.slideConfig = o, t.push(a) })); var i = !1; return this.getSelector() && (i = document.querySelectorAll(this.getSelector())), i ? (o(i, (function (i, n) { var s = new X(i, e, n), o = s.getConfig(), a = r({}, o); a.node = i, a.index = n, a.instance = s, a.slideConfig = o, a.gallery = i.getAttribute("data-gallery"), t.push(a) })), t) : t } }, { key: "getGalleryElements", value: function (e, t) { return e.filter((function (e) { return e.gallery == t })) } }, { key: "getSelector", value: function () { return !this.settings.elements && (this.settings.selector && "data-" == this.settings.selector.substring(0, 5) ? "*[".concat(this.settings.selector, "]") : this.settings.selector) } }, { key: "getActiveSlide", value: function () { return this.slidesContainer.querySelectorAll(".gslide")[this.index] } }, { key: "getActiveSlideIndex", value: function () { return this.index } }, { key: "getAnimationClasses", value: function () { var e = []; for (var t in this.settings.cssEfects) if (this.settings.cssEfects.hasOwnProperty(t)) { var i = this.settings.cssEfects[t]; e.push("g".concat(i.in)), e.push("g".concat(i.out)) } return e.join(" ") } }, { key: "build", value: function () { var e = this; if (this.built) return !1; var t = document.body.childNodes, i = []; o(t, (function (e) { e.parentNode == document.body && "#" !== e.nodeName.charAt(0) && e.hasAttribute && !e.hasAttribute("aria-hidden") && (i.push(e), e.setAttribute("aria-hidden", "true")) })); var n = $(this.settings.svg, "next") ? this.settings.svg.next : "", s = $(this.settings.svg, "prev") ? this.settings.svg.prev : "", r = $(this.settings.svg, "close") ? this.settings.svg.close : "", a = this.settings.lightboxHTML; a = v(a = (a = (a = a.replace(/{nextSVG}/g, n)).replace(/{prevSVG}/g, s)).replace(/{closeSVG}/g, r)), document.body.appendChild(a); var d = document.getElementById("glightbox-body"); this.modal = d; var p = d.querySelector(".gclose"); this.prevButton = d.querySelector(".gprev"), this.nextButton = d.querySelector(".gnext"), this.overlay = d.querySelector(".goverlay"), this.loader = d.querySelector(".gloader"), this.slidesContainer = document.getElementById("glightbox-slider"), this.bodyHiddenChildElms = i, this.events = {}, c(this.modal, "glightbox-" + this.settings.skin), this.settings.closeButton && p && (this.events.close = l("click", { onElement: p, withCallback: function (t, i) { t.preventDefault(), e.close() } })), p && !this.settings.closeButton && p.parentNode.removeChild(p), this.nextButton && (this.events.next = l("click", { onElement: this.nextButton, withCallback: function (t, i) { t.preventDefault(), e.nextSlide() } })), this.prevButton && (this.events.prev = l("click", { onElement: this.prevButton, withCallback: function (t, i) { t.preventDefault(), e.prevSlide() } })), this.settings.closeOnOutsideClick && (this.events.outClose = l("click", { onElement: d, withCallback: function (t, i) { e.preventOutsideClick || u(document.body, "glightbox-mobile") || h(t.target, ".ginner-container") || h(t.target, ".gbtn") || u(t.target, "gnext") || u(t.target, "gprev") || e.close() } })), o(this.elements, (function (t, i) { e.slidesContainer.appendChild(t.instance.create()), t.slideNode = e.slidesContainer.querySelectorAll(".gslide")[i] })), G && (c(document.body, "glightbox-touch"), this.settings.autoplayVideos = !1), this.events.resize = l("resize", { onElement: window, withCallback: function () { e.resize() } }), this.built = !0 } }, { key: "resize", value: function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; if ((e = e || this.activeSlide) && !u(e, "zoomed")) { var t = y(), i = e.querySelector(".gvideo-wrapper"), n = e.querySelector(".gslide-image"), s = this.slideDescription, r = t.width, o = t.height; if (r <= 768 ? c(document.body, "glightbox-mobile") : d(document.body, "glightbox-mobile"), i || n) { var a = !1; if (s && (u(s, "description-bottom") || u(s, "description-top")) && !u(s, "gabsolute") && (a = !0), n) if (r <= 768) n.querySelector("img"); else if (a) { var l = s.offsetHeight, h = n.querySelector("img"); h.setAttribute("style", "max-height: calc(100vh - ".concat(l, "px)")), s.setAttribute("style", "max-width: ".concat(h.offsetWidth, "px;")) } if (i) { var p = $(this.settings.plyr.config, "ratio") ? this.settings.plyr.config.ratio : ""; if (!p) { var f = i.clientWidth, m = i.clientHeight, g = f / m; p = "".concat(f / g, ":").concat(m / g) } var v = p.split(":"), b = this.settings.videosWidth, w = this.settings.videosWidth, x = (w = P(b) || -1 !== b.indexOf("px") ? parseInt(b) : -1 !== b.indexOf("vw") ? r * parseInt(b) / 100 : -1 !== b.indexOf("vh") ? o * parseInt(b) / 100 : -1 !== b.indexOf("%") ? r * parseInt(b) / 100 : parseInt(i.clientWidth)) / (parseInt(v[0]) / parseInt(v[1])); if (x = Math.floor(x), a && (o -= s.offsetHeight), w > r || x > o || o < x && r > w) { var _ = i.offsetWidth, T = i.offsetHeight, E = o / T, S = { width: _ * E, height: T * E }; i.parentNode.setAttribute("style", "max-width: ".concat(S.width, "px")), a && s.setAttribute("style", "max-width: ".concat(S.width, "px;")) } else i.parentNode.style.maxWidth = "".concat(b), a && s.setAttribute("style", "max-width: ".concat(b, ";")) } } } } }, { key: "reload", value: function () { this.init() } }, { key: "updateNavigationClasses", value: function () { var e = this.loop(); d(this.nextButton, "disabled"), d(this.prevButton, "disabled"), 0 == this.index && this.elements.length - 1 == 0 ? (c(this.prevButton, "disabled"), c(this.nextButton, "disabled")) : 0 !== this.index || e ? this.index !== this.elements.length - 1 || e || c(this.nextButton, "disabled") : c(this.prevButton, "disabled") } }, { key: "loop", value: function () { var e = $(this.settings, "loopAtEnd") ? this.settings.loopAtEnd : null; return e = $(this.settings, "loop") ? this.settings.loop : e, e } }, { key: "close", value: function () { var e = this; if (!this.lightboxOpen) { if (this.events) { for (var t in this.events) this.events.hasOwnProperty(t) && this.events[t].destroy(); this.events = null } return !1 } if (this.closing) return !1; this.closing = !0, this.slidePlayerPause(this.activeSlide), this.fullElementsList && (this.elements = this.fullElementsList), this.bodyHiddenChildElms.length && o(this.bodyHiddenChildElms, (function (e) { e.removeAttribute("aria-hidden") })), c(this.modal, "glightbox-closing"), p(this.overlay, "none" == this.settings.openEffect ? "none" : this.settings.cssEfects.fade.out), p(this.activeSlide, this.settings.cssEfects[this.settings.closeEffect].out, (function () { if (e.activeSlide = null, e.prevActiveSlideIndex = null, e.prevActiveSlide = null, e.built = !1, e.events) { for (var t in e.events) e.events.hasOwnProperty(t) && e.events[t].destroy(); e.events = null } var i = document.body; d(U, "glightbox-open"), d(i, "glightbox-open touching gdesc-open glightbox-touch glightbox-mobile gscrollbar-fixer"), e.modal.parentNode.removeChild(e.modal), e.trigger("close"), _(e.settings.onClose) && e.settings.onClose(); var n = document.querySelector(".gcss-styles"); n && n.parentNode.removeChild(n), e.lightboxOpen = !1, e.closing = null })) } }, { key: "destroy", value: function () { this.close(), this.clearAllEvents(), this.baseEvents && this.baseEvents.destroy() } }, { key: "on", value: function (e, t) { var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; if (!e || !_(t)) throw new TypeError("Event name and callback must be defined"); this.apiEvents.push({ evt: e, once: i, callback: t }) } }, { key: "once", value: function (e, t) { this.on(e, t, !0) } }, { key: "trigger", value: function (e) { var t = this, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = []; o(this.apiEvents, (function (t, s) { var r = t.evt, o = t.once, a = t.callback; r == e && (a(i), o && n.push(s)) })), n.length && o(n, (function (e) { return t.apiEvents.splice(e, 1) })) } }, { key: "clearAllEvents", value: function () { this.apiEvents.splice(0, this.apiEvents.length) } }, { key: "version", value: function () { return "3.1.0" } }]), e }(); return function () { var e = new K(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}); return e.init(), e } })), function (e, t) { "function" == typeof define && define.amd ? define([], (function () { return t() })) : "object" == typeof exports ? module.exports = t() : e.Headhesive = t() }(this, (function () { "use strict"; var e = function (t, i) { for (var n in i) i.hasOwnProperty(n) && (t[n] = "object" == typeof i[n] ? e(t[n], i[n]) : i[n]); return t }, t = function (e, t) { var i, n, s, r = Date.now || function () { return (new Date).getTime() }, o = null, a = 0, l = function () { a = r(), o = null, s = e.apply(i, n), i = n = null }; return function () { var c = r(), d = t - (c - a); return i = this, n = arguments, 0 >= d ? (clearTimeout(o), o = null, a = c, s = e.apply(i, n), i = n = null) : o || (o = setTimeout(l, d)), s } }, i = function (t, i) { "querySelector" in document && "addEventListener" in window && (this.visible = !1, this.options = { offset: 300, offsetSide: "top", classes: { clone: "headhesive", stick: "headhesive--stick", unstick: "headhesive--unstick" }, throttle: 250, onInit: function () { }, onStick: function () { }, onUnstick: function () { }, onDestroy: function () { } }, this.elem = "string" == typeof t ? document.querySelector(t) : t, this.options = e(this.options, i), this.init()) }; return i.prototype = { constructor: i, init: function () { if (this.clonedElem = this.elem.cloneNode(!0), this.clonedElem.className += " " + this.options.classes.clone, document.body.insertBefore(this.clonedElem, document.body.firstChild), "number" == typeof this.options.offset) this.scrollOffset = this.options.offset; else { if ("string" != typeof this.options.offset) throw new Error("Invalid offset: " + this.options.offset); this._setScrollOffset() } this._throttleUpdate = t(this.update.bind(this), this.options.throttle), this._throttleScrollOffset = t(this._setScrollOffset.bind(this), this.options.throttle), window.addEventListener("scroll", this._throttleUpdate, !1), window.addEventListener("resize", this._throttleScrollOffset, !1), this.options.onInit.call(this) }, _setScrollOffset: function () { "string" == typeof this.options.offset && (this.scrollOffset = function (e, t) { for (var i = 0, n = e.offsetHeight; e;)i += e.offsetTop, e = e.offsetParent; return "bottom" === t && (i += n), i }(document.querySelector(this.options.offset), this.options.offsetSide)) }, destroy: function () { document.body.removeChild(this.clonedElem), window.removeEventListener("scroll", this._throttleUpdate), window.removeEventListener("resize", this._throttleScrollOffset), this.options.onDestroy.call(this) }, stick: function () { this.visible || (this.clonedElem.className = this.clonedElem.className.replace(new RegExp("(^|\\s)*" + this.options.classes.unstick + "(\\s|$)*", "g"), ""), this.clonedElem.className += " " + this.options.classes.stick, this.visible = !0, this.options.onStick.call(this)) }, unstick: function () { this.visible && (this.clonedElem.className = this.clonedElem.className.replace(new RegExp("(^|\\s)*" + this.options.classes.stick + "(\\s|$)*", "g"), ""), this.clonedElem.className += " " + this.options.classes.unstick, this.visible = !1, this.options.onUnstick.call(this)) }, update: function () { (void 0 !== window.pageYOffset ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop) > this.scrollOffset ? this.stick() : this.unstick() } }, i })), function (e, t) { "function" == typeof define && define.amd ? define("ev-emitter/ev-emitter", t) : "object" == typeof module && module.exports ? module.exports = t() : e.EvEmitter = t() }("undefined" != typeof window ? window : this, (function () { function e() { } var t = e.prototype; return t.on = function (e, t) { if (e && t) { var i = this._events = this._events || {}, n = i[e] = i[e] || []; return -1 == n.indexOf(t) && n.push(t), this } }, t.once = function (e, t) { if (e && t) { this.on(e, t); var i = this._onceEvents = this._onceEvents || {}; return (i[e] = i[e] || {})[t] = !0, this } }, t.off = function (e, t) { var i = this._events && this._events[e]; if (i && i.length) { var n = i.indexOf(t); return -1 != n && i.splice(n, 1), this } }, t.emitEvent = function (e, t) { var i = this._events && this._events[e]; if (i && i.length) { i = i.slice(0), t = t || []; for (var n = this._onceEvents && this._onceEvents[e], s = 0; s < i.length; s++) { var r = i[s]; n && n[r] && (this.off(e, r), delete n[r]), r.apply(this, t) } return this } }, t.allOff = function () { delete this._events, delete this._onceEvents }, e })), function (e, t) { "use strict"; "function" == typeof define && define.amd ? define(["ev-emitter/ev-emitter"], (function (i) { return t(e, i) })) : "object" == typeof module && module.exports ? module.exports = t(e, require("ev-emitter")) : e.imagesLoaded = t(e, e.EvEmitter) }("undefined" != typeof window ? window : this, (function (e, t) { function i(e, t) { for (var i in t) e[i] = t[i]; return e } function n(e, t, s) { if (!(this instanceof n)) return new n(e, t, s); var r = e; return "string" == typeof e && (r = document.querySelectorAll(e)), r ? (this.elements = function (e) { return Array.isArray(e) ? e : "object" == typeof e && "number" == typeof e.length ? l.call(e) : [e] }(r), this.options = i({}, this.options), "function" == typeof t ? s = t : i(this.options, t), s && this.on("always", s), this.getImages(), o && (this.jqDeferred = new o.Deferred), void setTimeout(this.check.bind(this))) : void a.error("Bad element for imagesLoaded " + (r || e)) } function s(e) { this.img = e } function r(e, t) { this.url = e, this.element = t, this.img = new Image } var o = e.jQuery, a = e.console, l = Array.prototype.slice; n.prototype = Object.create(t.prototype), n.prototype.options = {}, n.prototype.getImages = function () { this.images = [], this.elements.forEach(this.addElementImages, this) }, n.prototype.addElementImages = function (e) { "IMG" == e.nodeName && this.addImage(e), !0 === this.options.background && this.addElementBackgroundImages(e); var t = e.nodeType; if (t && c[t]) { for (var i = e.querySelectorAll("img"), n = 0; n < i.length; n++) { var s = i[n]; this.addImage(s) } if ("string" == typeof this.options.background) { var r = e.querySelectorAll(this.options.background); for (n = 0; n < r.length; n++) { var o = r[n]; this.addElementBackgroundImages(o) } } } }; var c = { 1: !0, 9: !0, 11: !0 }; return n.prototype.addElementBackgroundImages = function (e) { var t = getComputedStyle(e); if (t) for (var i = /url\((['"])?(.*?)\1\)/gi, n = i.exec(t.backgroundImage); null !== n;) { var s = n && n[2]; s && this.addBackground(s, e), n = i.exec(t.backgroundImage) } }, n.prototype.addImage = function (e) { var t = new s(e); this.images.push(t) }, n.prototype.addBackground = function (e, t) { var i = new r(e, t); this.images.push(i) }, n.prototype.check = function () { function e(e, i, n) { setTimeout((function () { t.progress(e, i, n) })) } var t = this; return this.progressedCount = 0, this.hasAnyBroken = !1, this.images.length ? void this.images.forEach((function (t) { t.once("progress", e), t.check() })) : void this.complete() }, n.prototype.progress = function (e, t, i) { this.progressedCount++, this.hasAnyBroken = this.hasAnyBroken || !e.isLoaded, this.emitEvent("progress", [this, e, t]), this.jqDeferred && this.jqDeferred.notify && this.jqDeferred.notify(this, e), this.progressedCount == this.images.length && this.complete(), this.options.debug && a && a.log("progress: " + i, e, t) }, n.prototype.complete = function () { var e = this.hasAnyBroken ? "fail" : "done"; if (this.isComplete = !0, this.emitEvent(e, [this]), this.emitEvent("always", [this]), this.jqDeferred) { var t = this.hasAnyBroken ? "reject" : "resolve"; this.jqDeferred[t](this) } }, s.prototype = Object.create(t.prototype), s.prototype.check = function () { return this.getIsImageComplete() ? void this.confirm(0 !== this.img.naturalWidth, "naturalWidth") : (this.proxyImage = new Image, this.proxyImage.addEventListener("load", this), this.proxyImage.addEventListener("error", this), this.img.addEventListener("load", this), this.img.addEventListener("error", this), void (this.proxyImage.src = this.img.src)) }, s.prototype.getIsImageComplete = function () { return this.img.complete && this.img.naturalWidth }, s.prototype.confirm = function (e, t) { this.isLoaded = e, this.emitEvent("progress", [this, this.img, t]) }, s.prototype.handleEvent = function (e) { var t = "on" + e.type; this[t] && this[t](e) }, s.prototype.onload = function () { this.confirm(!0, "onload"), this.unbindEvents() }, s.prototype.onerror = function () { this.confirm(!1, "onerror"), this.unbindEvents() }, s.prototype.unbindEvents = function () { this.proxyImage.removeEventListener("load", this), this.proxyImage.removeEventListener("error", this), this.img.removeEventListener("load", this), this.img.removeEventListener("error", this) }, r.prototype = Object.create(s.prototype), r.prototype.check = function () { this.img.addEventListener("load", this), this.img.addEventListener("error", this), this.img.src = this.url, this.getIsImageComplete() && (this.confirm(0 !== this.img.naturalWidth, "naturalWidth"), this.unbindEvents()) }, r.prototype.unbindEvents = function () { this.img.removeEventListener("load", this), this.img.removeEventListener("error", this) }, r.prototype.confirm = function (e, t) { this.isLoaded = e, this.emitEvent("progress", [this, this.element, t]) }, n.makeJQueryPlugin = function (t) { (t = t || e.jQuery) && ((o = t).fn.imagesLoaded = function (e, t) { return new n(this, e, t).jqDeferred.promise(o(this)) }) }, n.makeJQueryPlugin(), n })), function (e, t) { "function" == typeof define && define.amd ? define("jquery-bridget/jquery-bridget", ["jquery"], (function (i) { return t(e, i) })) : "object" == typeof module && module.exports ? module.exports = t(e, require("jquery")) : e.jQueryBridget = t(e, e.jQuery) }(window, (function (e, t) { "use strict"; function i(i, r, a) { (a = a || t || e.jQuery) && (r.prototype.option || (r.prototype.option = function (e) { a.isPlainObject(e) && (this.options = a.extend(!0, this.options, e)) }), a.fn[i] = function (e) { return "string" == typeof e ? function (e, t, n) { var s, r = "$()." + i + '("' + t + '")'; return e.each((function (e, l) { var c = a.data(l, i); if (c) { var d = c[t]; if (d && "_" != t.charAt(0)) { var u = d.apply(c, n); s = void 0 === s ? u : s } else o(r + " is not a valid method") } else o(i + " not initialized. Cannot call methods, i.e. " + r) })), void 0 !== s ? s : e }(this, e, s.call(arguments, 1)) : (function (e, t) { e.each((function (e, n) { var s = a.data(n, i); s ? (s.option(t), s._init()) : (s = new r(n, t), a.data(n, i, s)) })) }(this, e), this) }, n(a)) } function n(e) { !e || e && e.bridget || (e.bridget = i) } var s = Array.prototype.slice, r = e.console, o = void 0 === r ? function () { } : function (e) { r.error(e) }; return n(t || e.jQuery), i })), function (e, t) { "function" == typeof define && define.amd ? define("ev-emitter/ev-emitter", t) : "object" == typeof module && module.exports ? module.exports = t() : e.EvEmitter = t() }("undefined" != typeof window ? window : this, (function () { function e() { } var t = e.prototype; return t.on = function (e, t) { if (e && t) { var i = this._events = this._events || {}, n = i[e] = i[e] || []; return -1 == n.indexOf(t) && n.push(t), this } }, t.once = function (e, t) { if (e && t) { this.on(e, t); var i = this._onceEvents = this._onceEvents || {}; return (i[e] = i[e] || {})[t] = !0, this } }, t.off = function (e, t) { var i = this._events && this._events[e]; if (i && i.length) { var n = i.indexOf(t); return -1 != n && i.splice(n, 1), this } }, t.emitEvent = function (e, t) { var i = this._events && this._events[e]; if (i && i.length) { i = i.slice(0), t = t || []; for (var n = this._onceEvents && this._onceEvents[e], s = 0; s < i.length; s++) { var r = i[s]; n && n[r] && (this.off(e, r), delete n[r]), r.apply(this, t) } return this } }, t.allOff = function () { delete this._events, delete this._onceEvents }, e })), function (e, t) { "function" == typeof define && define.amd ? define("get-size/get-size", t) : "object" == typeof module && module.exports ? module.exports = t() : e.getSize = t() }(window, (function () { "use strict"; function e(e) { var t = parseFloat(e); return -1 == e.indexOf("%") && !isNaN(t) && t } function t(e) { var t = getComputedStyle(e); return t || r("Style returned " + t + ". Are you running this code in a hidden iframe on Firefox? See https://bit.ly/getsizebug1"), t } function i() { if (!l) { l = !0; var i = document.createElement("div"); i.style.width = "200px", i.style.padding = "1px 2px 3px 4px", i.style.borderStyle = "solid", i.style.borderWidth = "1px 2px 3px 4px", i.style.boxSizing = "border-box"; var r = document.body || document.documentElement; r.appendChild(i); var o = t(i); s = 200 == Math.round(e(o.width)), n.isBoxSizeOuter = s, r.removeChild(i) } } function n(n) { if (i(), "string" == typeof n && (n = document.querySelector(n)), n && "object" == typeof n && n.nodeType) { var r = t(n); if ("none" == r.display) return function () { for (var e = { width: 0, height: 0, innerWidth: 0, innerHeight: 0, outerWidth: 0, outerHeight: 0 }, t = 0; t < a; t++)e[o[t]] = 0; return e }(); var l = {}; l.width = n.offsetWidth, l.height = n.offsetHeight; for (var c = l.isBorderBox = "border-box" == r.boxSizing, d = 0; d < a; d++) { var u = o[d], h = r[u], p = parseFloat(h); l[u] = isNaN(p) ? 0 : p } var f = l.paddingLeft + l.paddingRight, m = l.paddingTop + l.paddingBottom, g = l.marginLeft + l.marginRight, v = l.marginTop + l.marginBottom, y = l.borderLeftWidth + l.borderRightWidth, b = l.borderTopWidth + l.borderBottomWidth, w = c && s, x = e(r.width); !1 !== x && (l.width = x + (w ? 0 : f + y)); var _ = e(r.height); return !1 !== _ && (l.height = _ + (w ? 0 : m + b)), l.innerWidth = l.width - (f + y), l.innerHeight = l.height - (m + b), l.outerWidth = l.width + g, l.outerHeight = l.height + v, l } } var s, r = "undefined" == typeof console ? function () { } : function (e) { console.error(e) }, o = ["paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth"], a = o.length, l = !1; return n })), function (e, t) { "use strict"; "function" == typeof define && define.amd ? define("desandro-matches-selector/matches-selector", t) : "object" == typeof module && module.exports ? module.exports = t() : e.matchesSelector = t() }(window, (function () { "use strict"; var e = function () { var e = window.Element.prototype; if (e.matches) return "matches"; if (e.matchesSelector) return "matchesSelector"; for (var t = ["webkit", "moz", "ms", "o"], i = 0; i < t.length; i++) { var n = t[i] + "MatchesSelector"; if (e[n]) return n } }(); return function (t, i) { return t[e](i) } })), function (e, t) { "function" == typeof define && define.amd ? define("fizzy-ui-utils/utils", ["desandro-matches-selector/matches-selector"], (function (i) { return t(e, i) })) : "object" == typeof module && module.exports ? module.exports = t(e, require("desandro-matches-selector")) : e.fizzyUIUtils = t(e, e.matchesSelector) }(window, (function (e, t) { var i = { extend: function (e, t) { for (var i in t) e[i] = t[i]; return e }, modulo: function (e, t) { return (e % t + t) % t } }, n = Array.prototype.slice; i.makeArray = function (e) { return Array.isArray(e) ? e : null == e ? [] : "object" == typeof e && "number" == typeof e.length ? n.call(e) : [e] }, i.removeFrom = function (e, t) { var i = e.indexOf(t); -1 != i && e.splice(i, 1) }, i.getParent = function (e, i) { for (; e.parentNode && e != document.body;)if (e = e.parentNode, t(e, i)) return e }, i.getQueryElement = function (e) { return "string" == typeof e ? document.querySelector(e) : e }, i.handleEvent = function (e) { var t = "on" + e.type; this[t] && this[t](e) }, i.filterFindElements = function (e, n) { e = i.makeArray(e); var s = []; return e.forEach((function (e) { if (e instanceof HTMLElement) { if (!n) return void s.push(e); t(e, n) && s.push(e); for (var i = e.querySelectorAll(n), r = 0; r < i.length; r++)s.push(i[r]) } })), s }, i.debounceMethod = function (e, t, i) { i = i || 100; var n = e.prototype[t], s = t + "Timeout"; e.prototype[t] = function () { var e = this[s]; clearTimeout(e); var t = arguments, r = this; this[s] = setTimeout((function () { n.apply(r, t), delete r[s] }), i) } }, i.docReady = function (e) { var t = document.readyState; "complete" == t || "interactive" == t ? setTimeout(e) : document.addEventListener("DOMContentLoaded", e) }, i.toDashed = function (e) { return e.replace(/(.)([A-Z])/g, (function (e, t, i) { return t + "-" + i })).toLowerCase() }; var s = e.console; return i.htmlInit = function (t, n) { i.docReady((function () { var r = i.toDashed(n), o = "data-" + r, a = document.querySelectorAll("[" + o + "]"), l = document.querySelectorAll(".js-" + r), c = i.makeArray(a).concat(i.makeArray(l)), d = o + "-options", u = e.jQuery; c.forEach((function (e) { var i, r = e.getAttribute(o) || e.getAttribute(d); try { i = r && JSON.parse(r) } catch (t) { return void (s && s.error("Error parsing " + o + " on " + e.className + ": " + t)) } var a = new t(e, i); u && u.data(e, n, a) })) })) }, i })), function (e, t) { "function" == typeof define && define.amd ? define("outlayer/item", ["ev-emitter/ev-emitter", "get-size/get-size"], t) : "object" == typeof module && module.exports ? module.exports = t(require("ev-emitter"), require("get-size")) : (e.Outlayer = {}, e.Outlayer.Item = t(e.EvEmitter, e.getSize)) }(window, (function (e, t) { "use strict"; function i(e, t) { e && (this.element = e, this.layout = t, this.position = { x: 0, y: 0 }, this._create()) } var n = document.documentElement.style, s = "string" == typeof n.transition ? "transition" : "WebkitTransition", r = "string" == typeof n.transform ? "transform" : "WebkitTransform", o = { WebkitTransition: "webkitTransitionEnd", transition: "transitionend" }[s], a = { transform: r, transition: s, transitionDuration: s + "Duration", transitionProperty: s + "Property", transitionDelay: s + "Delay" }, l = i.prototype = Object.create(e.prototype); l.constructor = i, l._create = function () { this._transn = { ingProperties: {}, clean: {}, onEnd: {} }, this.css({ position: "absolute" }) }, l.handleEvent = function (e) { var t = "on" + e.type; this[t] && this[t](e) }, l.getSize = function () { this.size = t(this.element) }, l.css = function (e) { var t = this.element.style; for (var i in e) { t[a[i] || i] = e[i] } }, l.getPosition = function () { var e = getComputedStyle(this.element), t = this.layout._getOption("originLeft"), i = this.layout._getOption("originTop"), n = e[t ? "left" : "right"], s = e[i ? "top" : "bottom"], r = parseFloat(n), o = parseFloat(s), a = this.layout.size; -1 != n.indexOf("%") && (r = r / 100 * a.width), -1 != s.indexOf("%") && (o = o / 100 * a.height), r = isNaN(r) ? 0 : r, o = isNaN(o) ? 0 : o, r -= t ? a.paddingLeft : a.paddingRight, o -= i ? a.paddingTop : a.paddingBottom, this.position.x = r, this.position.y = o }, l.layoutPosition = function () { var e = this.layout.size, t = {}, i = this.layout._getOption("originLeft"), n = this.layout._getOption("originTop"), s = i ? "paddingLeft" : "paddingRight", r = i ? "left" : "right", o = i ? "right" : "left", a = this.position.x + e[s]; t[r] = this.getXValue(a), t[o] = ""; var l = n ? "paddingTop" : "paddingBottom", c = n ? "top" : "bottom", d = n ? "bottom" : "top", u = this.position.y + e[l]; t[c] = this.getYValue(u), t[d] = "", this.css(t), this.emitEvent("layout", [this]) }, l.getXValue = function (e) { var t = this.layout._getOption("horizontal"); return this.layout.options.percentPosition && !t ? e / this.layout.size.width * 100 + "%" : e + "px" }, l.getYValue = function (e) { var t = this.layout._getOption("horizontal"); return this.layout.options.percentPosition && t ? e / this.layout.size.height * 100 + "%" : e + "px" }, l._transitionTo = function (e, t) { this.getPosition(); var i = this.position.x, n = this.position.y, s = e == this.position.x && t == this.position.y; if (this.setPosition(e, t), !s || this.isTransitioning) { var r = e - i, o = t - n, a = {}; a.transform = this.getTranslate(r, o), this.transition({ to: a, onTransitionEnd: { transform: this.layoutPosition }, isCleaning: !0 }) } else this.layoutPosition() }, l.getTranslate = function (e, t) { return "translate3d(" + (e = this.layout._getOption("originLeft") ? e : -e) + "px, " + (t = this.layout._getOption("originTop") ? t : -t) + "px, 0)" }, l.goTo = function (e, t) { this.setPosition(e, t), this.layoutPosition() }, l.moveTo = l._transitionTo, l.setPosition = function (e, t) { this.position.x = parseFloat(e), this.position.y = parseFloat(t) }, l._nonTransition = function (e) { for (var t in this.css(e.to), e.isCleaning && this._removeStyles(e.to), e.onTransitionEnd) e.onTransitionEnd[t].call(this) }, l.transition = function (e) { if (parseFloat(this.layout.options.transitionDuration)) { var t = this._transn; for (var i in e.onTransitionEnd) t.onEnd[i] = e.onTransitionEnd[i]; for (i in e.to) t.ingProperties[i] = !0, e.isCleaning && (t.clean[i] = !0); if (e.from) { this.css(e.from); this.element.offsetHeight; null } this.enableTransition(e.to), this.css(e.to), this.isTransitioning = !0 } else this._nonTransition(e) }; var c = "opacity," + function (e) { return e.replace(/([A-Z])/g, (function (e) { return "-" + e.toLowerCase() })) }(r); l.enableTransition = function () { if (!this.isTransitioning) { var e = this.layout.options.transitionDuration; e = "number" == typeof e ? e + "ms" : e, this.css({ transitionProperty: c, transitionDuration: e, transitionDelay: this.staggerDelay || 0 }), this.element.addEventListener(o, this, !1) } }, l.onwebkitTransitionEnd = function (e) { this.ontransitionend(e) }, l.onotransitionend = function (e) { this.ontransitionend(e) }; var d = { "-webkit-transform": "transform" }; l.ontransitionend = function (e) { if (e.target === this.element) { var t = this._transn, i = d[e.propertyName] || e.propertyName; if (delete t.ingProperties[i], function (e) { for (var t in e) return !1; return !0 }(t.ingProperties) && this.disableTransition(), i in t.clean && (this.element.style[e.propertyName] = "", delete t.clean[i]), i in t.onEnd) t.onEnd[i].call(this), delete t.onEnd[i]; this.emitEvent("transitionEnd", [this]) } }, l.disableTransition = function () { this.removeTransitionStyles(), this.element.removeEventListener(o, this, !1), this.isTransitioning = !1 }, l._removeStyles = function (e) { var t = {}; for (var i in e) t[i] = ""; this.css(t) }; var u = { transitionProperty: "", transitionDuration: "", transitionDelay: "" }; return l.removeTransitionStyles = function () { this.css(u) }, l.stagger = function (e) { e = isNaN(e) ? 0 : e, this.staggerDelay = e + "ms" }, l.removeElem = function () { this.element.parentNode.removeChild(this.element), this.css({ display: "" }), this.emitEvent("remove", [this]) }, l.remove = function () { return s && parseFloat(this.layout.options.transitionDuration) ? (this.once("transitionEnd", (function () { this.removeElem() })), void this.hide()) : void this.removeElem() }, l.reveal = function () { delete this.isHidden, this.css({ display: "" }); var e = this.layout.options, t = {}; t[this.getHideRevealTransitionEndProperty("visibleStyle")] = this.onRevealTransitionEnd, this.transition({ from: e.hiddenStyle, to: e.visibleStyle, isCleaning: !0, onTransitionEnd: t }) }, l.onRevealTransitionEnd = function () { this.isHidden || this.emitEvent("reveal") }, l.getHideRevealTransitionEndProperty = function (e) { var t = this.layout.options[e]; if (t.opacity) return "opacity"; for (var i in t) return i }, l.hide = function () { this.isHidden = !0, this.css({ display: "" }); var e = this.layout.options, t = {}; t[this.getHideRevealTransitionEndProperty("hiddenStyle")] = this.onHideTransitionEnd, this.transition({ from: e.visibleStyle, to: e.hiddenStyle, isCleaning: !0, onTransitionEnd: t }) }, l.onHideTransitionEnd = function () { this.isHidden && (this.css({ display: "none" }), this.emitEvent("hide")) }, l.destroy = function () { this.css({ position: "", left: "", right: "", top: "", bottom: "", transition: "", transform: "" }) }, i })), function (e, t) { "use strict"; "function" == typeof define && define.amd ? define("outlayer/outlayer", ["ev-emitter/ev-emitter", "get-size/get-size", "fizzy-ui-utils/utils", "./item"], (function (i, n, s, r) { return t(e, i, n, s, r) })) : "object" == typeof module && module.exports ? module.exports = t(e, require("ev-emitter"), require("get-size"), require("fizzy-ui-utils"), require("./item")) : e.Outlayer = t(e, e.EvEmitter, e.getSize, e.fizzyUIUtils, e.Outlayer.Item) }(window, (function (e, t, i, n, s) { "use strict"; function r(e, t) { var i = n.getQueryElement(e); if (i) { this.element = i, l && (this.$element = l(this.element)), this.options = n.extend({}, this.constructor.defaults), this.option(t); var s = ++d; this.element.outlayerGUID = s, u[s] = this, this._create(), this._getOption("initLayout") && this.layout() } else a && a.error("Bad element for " + this.constructor.namespace + ": " + (i || e)) } function o(e) { function t() { e.apply(this, arguments) } return t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t } var a = e.console, l = e.jQuery, c = function () { }, d = 0, u = {}; r.namespace = "outlayer", r.Item = s, r.defaults = { containerStyle: { position: "relative" }, initLayout: !0, originLeft: !0, originTop: !0, resize: !0, resizeContainer: !0, transitionDuration: "0.4s", hiddenStyle: { opacity: 0, transform: "scale(0.001)" }, visibleStyle: { opacity: 1, transform: "scale(1)" } }; var h = r.prototype; n.extend(h, t.prototype), h.option = function (e) { n.extend(this.options, e) }, h._getOption = function (e) { var t = this.constructor.compatOptions[e]; return t && void 0 !== this.options[t] ? this.options[t] : this.options[e] }, r.compatOptions = { initLayout: "isInitLayout", horizontal: "isHorizontal", layoutInstant: "isLayoutInstant", originLeft: "isOriginLeft", originTop: "isOriginTop", resize: "isResizeBound", resizeContainer: "isResizingContainer" }, h._create = function () { this.reloadItems(), this.stamps = [], this.stamp(this.options.stamp), n.extend(this.element.style, this.options.containerStyle), this._getOption("resize") && this.bindResize() }, h.reloadItems = function () { this.items = this._itemize(this.element.children) }, h._itemize = function (e) { for (var t = this._filterFindItemElements(e), i = this.constructor.Item, n = [], s = 0; s < t.length; s++) { var r = new i(t[s], this); n.push(r) } return n }, h._filterFindItemElements = function (e) { return n.filterFindElements(e, this.options.itemSelector) }, h.getItemElements = function () { return this.items.map((function (e) { return e.element })) }, h.layout = function () { this._resetLayout(), this._manageStamps(); var e = this._getOption("layoutInstant"), t = void 0 !== e ? e : !this._isLayoutInited; this.layoutItems(this.items, t), this._isLayoutInited = !0 }, h._init = h.layout, h._resetLayout = function () { this.getSize() }, h.getSize = function () { this.size = i(this.element) }, h._getMeasurement = function (e, t) { var n, s = this.options[e]; s ? ("string" == typeof s ? n = this.element.querySelector(s) : s instanceof HTMLElement && (n = s), this[e] = n ? i(n)[t] : s) : this[e] = 0 }, h.layoutItems = function (e, t) { e = this._getItemsForLayout(e), this._layoutItems(e, t), this._postLayout() }, h._getItemsForLayout = function (e) { return e.filter((function (e) { return !e.isIgnored })) }, h._layoutItems = function (e, t) { if (this._emitCompleteOnItems("layout", e), e && e.length) { var i = []; e.forEach((function (e) { var n = this._getItemLayoutPosition(e); n.item = e, n.isInstant = t || e.isLayoutInstant, i.push(n) }), this), this._processLayoutQueue(i) } }, h._getItemLayoutPosition = function () { return { x: 0, y: 0 } }, h._processLayoutQueue = function (e) { this.updateStagger(), e.forEach((function (e, t) { this._positionItem(e.item, e.x, e.y, e.isInstant, t) }), this) }, h.updateStagger = function () { var e = this.options.stagger; return null == e ? void (this.stagger = 0) : (this.stagger = function (e) { if ("number" == typeof e) return e; var t = e.match(/(^\d*\.?\d*)(\w*)/), i = t && t[1], n = t && t[2]; return i.length ? (i = parseFloat(i)) * (p[n] || 1) : 0 }(e), this.stagger) }, h._positionItem = function (e, t, i, n, s) { n ? e.goTo(t, i) : (e.stagger(s * this.stagger), e.moveTo(t, i)) }, h._postLayout = function () { this.resizeContainer() }, h.resizeContainer = function () { if (this._getOption("resizeContainer")) { var e = this._getContainerSize(); e && (this._setContainerMeasure(e.width, !0), this._setContainerMeasure(e.height, !1)) } }, h._getContainerSize = c, h._setContainerMeasure = function (e, t) { if (void 0 !== e) { var i = this.size; i.isBorderBox && (e += t ? i.paddingLeft + i.paddingRight + i.borderLeftWidth + i.borderRightWidth : i.paddingBottom + i.paddingTop + i.borderTopWidth + i.borderBottomWidth), e = Math.max(e, 0), this.element.style[t ? "width" : "height"] = e + "px" } }, h._emitCompleteOnItems = function (e, t) { function i() { s.dispatchEvent(e + "Complete", null, [t]) } function n() { ++o == r && i() } var s = this, r = t.length; if (t && r) { var o = 0; t.forEach((function (t) { t.once(e, n) })) } else i() }, h.dispatchEvent = function (e, t, i) { var n = t ? [t].concat(i) : i; if (this.emitEvent(e, n), l) if (this.$element = this.$element || l(this.element), t) { var s = l.Event(t); s.type = e, this.$element.trigger(s, i) } else this.$element.trigger(e, i) }, h.ignore = function (e) { var t = this.getItem(e); t && (t.isIgnored = !0) }, h.unignore = function (e) { var t = this.getItem(e); t && delete t.isIgnored }, h.stamp = function (e) { (e = this._find(e)) && (this.stamps = this.stamps.concat(e), e.forEach(this.ignore, this)) }, h.unstamp = function (e) { (e = this._find(e)) && e.forEach((function (e) { n.removeFrom(this.stamps, e), this.unignore(e) }), this) }, h._find = function (e) { if (e) return "string" == typeof e && (e = this.element.querySelectorAll(e)), n.makeArray(e) }, h._manageStamps = function () { this.stamps && this.stamps.length && (this._getBoundingRect(), this.stamps.forEach(this._manageStamp, this)) }, h._getBoundingRect = function () { var e = this.element.getBoundingClientRect(), t = this.size; this._boundingRect = { left: e.left + t.paddingLeft + t.borderLeftWidth, top: e.top + t.paddingTop + t.borderTopWidth, right: e.right - (t.paddingRight + t.borderRightWidth), bottom: e.bottom - (t.paddingBottom + t.borderBottomWidth) } }, h._manageStamp = c, h._getElementOffset = function (e) { var t = e.getBoundingClientRect(), n = this._boundingRect, s = i(e); return { left: t.left - n.left - s.marginLeft, top: t.top - n.top - s.marginTop, right: n.right - t.right - s.marginRight, bottom: n.bottom - t.bottom - s.marginBottom } }, h.handleEvent = n.handleEvent, h.bindResize = function () { e.addEventListener("resize", this), this.isResizeBound = !0 }, h.unbindResize = function () { e.removeEventListener("resize", this), this.isResizeBound = !1 }, h.onresize = function () { this.resize() }, n.debounceMethod(r, "onresize", 100), h.resize = function () { this.isResizeBound && this.needsResizeLayout() && this.layout() }, h.needsResizeLayout = function () { var e = i(this.element); return this.size && e && e.innerWidth !== this.size.innerWidth }, h.addItems = function (e) { var t = this._itemize(e); return t.length && (this.items = this.items.concat(t)), t }, h.appended = function (e) { var t = this.addItems(e); t.length && (this.layoutItems(t, !0), this.reveal(t)) }, h.prepended = function (e) { var t = this._itemize(e); if (t.length) { var i = this.items.slice(0); this.items = t.concat(i), this._resetLayout(), this._manageStamps(), this.layoutItems(t, !0), this.reveal(t), this.layoutItems(i) } }, h.reveal = function (e) { if (this._emitCompleteOnItems("reveal", e), e && e.length) { var t = this.updateStagger(); e.forEach((function (e, i) { e.stagger(i * t), e.reveal() })) } }, h.hide = function (e) { if (this._emitCompleteOnItems("hide", e), e && e.length) { var t = this.updateStagger(); e.forEach((function (e, i) { e.stagger(i * t), e.hide() })) } }, h.revealItemElements = function (e) { var t = this.getItems(e); this.reveal(t) }, h.hideItemElements = function (e) { var t = this.getItems(e); this.hide(t) }, h.getItem = function (e) { for (var t = 0; t < this.items.length; t++) { var i = this.items[t]; if (i.element == e) return i } }, h.getItems = function (e) { e = n.makeArray(e); var t = []; return e.forEach((function (e) { var i = this.getItem(e); i && t.push(i) }), this), t }, h.remove = function (e) { var t = this.getItems(e); this._emitCompleteOnItems("remove", t), t && t.length && t.forEach((function (e) { e.remove(), n.removeFrom(this.items, e) }), this) }, h.destroy = function () { var e = this.element.style; e.height = "", e.position = "", e.width = "", this.items.forEach((function (e) { e.destroy() })), this.unbindResize(); var t = this.element.outlayerGUID; delete u[t], delete this.element.outlayerGUID, l && l.removeData(this.element, this.constructor.namespace) }, r.data = function (e) { var t = (e = n.getQueryElement(e)) && e.outlayerGUID; return t && u[t] }, r.create = function (e, t) { var i = o(r); return i.defaults = n.extend({}, r.defaults), n.extend(i.defaults, t), i.compatOptions = n.extend({}, r.compatOptions), i.namespace = e, i.data = r.data, i.Item = o(s), n.htmlInit(i, e), l && l.bridget && l.bridget(e, i), i }; var p = { ms: 1, s: 1e3 }; return r.Item = s, r })), function (e, t) { "function" == typeof define && define.amd ? define("isotope-layout/js/item", ["outlayer/outlayer"], t) : "object" == typeof module && module.exports ? module.exports = t(require("outlayer")) : (e.Isotope = e.Isotope || {}, e.Isotope.Item = t(e.Outlayer)) }(window, (function (e) { "use strict"; function t() { e.Item.apply(this, arguments) } var i = t.prototype = Object.create(e.Item.prototype), n = i._create; i._create = function () { this.id = this.layout.itemGUID++, n.call(this), this.sortData = {} }, i.updateSortData = function () { if (!this.isIgnored) { this.sortData.id = this.id, this.sortData["original-order"] = this.id, this.sortData.random = Math.random(); var e = this.layout.options.getSortData, t = this.layout._sorters; for (var i in e) { var n = t[i]; this.sortData[i] = n(this.element, this) } } }; var s = i.destroy; return i.destroy = function () { s.apply(this, arguments), this.css({ display: "" }) }, t })), function (e, t) { "function" == typeof define && define.amd ? define("isotope-layout/js/layout-mode", ["get-size/get-size", "outlayer/outlayer"], t) : "object" == typeof module && module.exports ? module.exports = t(require("get-size"), require("outlayer")) : (e.Isotope = e.Isotope || {}, e.Isotope.LayoutMode = t(e.getSize, e.Outlayer)) }(window, (function (e, t) { "use strict"; function i(e) { this.isotope = e, e && (this.options = e.options[this.namespace], this.element = e.element, this.items = e.filteredItems, this.size = e.size) } var n = i.prototype; return ["_resetLayout", "_getItemLayoutPosition", "_manageStamp", "_getContainerSize", "_getElementOffset", "needsResizeLayout", "_getOption"].forEach((function (e) { n[e] = function () { return t.prototype[e].apply(this.isotope, arguments) } })), n.needsVerticalResizeLayout = function () { var t = e(this.isotope.element); return this.isotope.size && t && t.innerHeight != this.isotope.size.innerHeight }, n._getMeasurement = function () { this.isotope._getMeasurement.apply(this, arguments) }, n.getColumnWidth = function () { this.getSegmentSize("column", "Width") }, n.getRowHeight = function () { this.getSegmentSize("row", "Height") }, n.getSegmentSize = function (e, t) { var i = e + t, n = "outer" + t; if (this._getMeasurement(i, n), !this[i]) { var s = this.getFirstItemSize(); this[i] = s && s[n] || this.isotope.size["inner" + t] } }, n.getFirstItemSize = function () { var t = this.isotope.filteredItems[0]; return t && t.element && e(t.element) }, n.layout = function () { this.isotope.layout.apply(this.isotope, arguments) }, n.getSize = function () { this.isotope.getSize(), this.size = this.isotope.size }, i.modes = {}, i.create = function (e, t) { function s() { i.apply(this, arguments) } return s.prototype = Object.create(n), s.prototype.constructor = s, t && (s.options = t), s.prototype.namespace = e, i.modes[e] = s, s }, i })), function (e, t) { "function" == typeof define && define.amd ? define("masonry-layout/masonry", ["outlayer/outlayer", "get-size/get-size"], t) : "object" == typeof module && module.exports ? module.exports = t(require("outlayer"), require("get-size")) : e.Masonry = t(e.Outlayer, e.getSize) }(window, (function (e, t) { var i = e.create("masonry"); i.compatOptions.fitWidth = "isFitWidth"; var n = i.prototype; return n._resetLayout = function () { this.getSize(), this._getMeasurement("columnWidth", "outerWidth"), this._getMeasurement("gutter", "outerWidth"), this.measureColumns(), this.colYs = []; for (var e = 0; e < this.cols; e++)this.colYs.push(0); this.maxY = 0, this.horizontalColIndex = 0 }, n.measureColumns = function () { if (this.getContainerWidth(), !this.columnWidth) { var e = this.items[0], i = e && e.element; this.columnWidth = i && t(i).outerWidth || this.containerWidth } var n = this.columnWidth += this.gutter, s = this.containerWidth + this.gutter, r = s / n, o = n - s % n; r = Math[o && o < 1 ? "round" : "floor"](r), this.cols = Math.max(r, 1) }, n.getContainerWidth = function () { var e = this._getOption("fitWidth") ? this.element.parentNode : this.element, i = t(e); this.containerWidth = i && i.innerWidth }, n._getItemLayoutPosition = function (e) { e.getSize(); var t = e.size.outerWidth % this.columnWidth, i = Math[t && t < 1 ? "round" : "ceil"](e.size.outerWidth / this.columnWidth); i = Math.min(i, this.cols); for (var n = this[this.options.horizontalOrder ? "_getHorizontalColPosition" : "_getTopColPosition"](i, e), s = { x: this.columnWidth * n.col, y: n.y }, r = n.y + e.size.outerHeight, o = i + n.col, a = n.col; a < o; a++)this.colYs[a] = r; return s }, n._getTopColPosition = function (e) { var t = this._getTopColGroup(e), i = Math.min.apply(Math, t); return { col: t.indexOf(i), y: i } }, n._getTopColGroup = function (e) { if (e < 2) return this.colYs; for (var t = [], i = this.cols + 1 - e, n = 0; n < i; n++)t[n] = this._getColGroupY(n, e); return t }, n._getColGroupY = function (e, t) { if (t < 2) return this.colYs[e]; var i = this.colYs.slice(e, e + t); return Math.max.apply(Math, i) }, n._getHorizontalColPosition = function (e, t) { var i = this.horizontalColIndex % this.cols; i = e > 1 && i + e > this.cols ? 0 : i; var n = t.size.outerWidth && t.size.outerHeight; return this.horizontalColIndex = n ? i + e : this.horizontalColIndex, { col: i, y: this._getColGroupY(i, e) } }, n._manageStamp = function (e) { var i = t(e), n = this._getElementOffset(e), s = this._getOption("originLeft") ? n.left : n.right, r = s + i.outerWidth, o = Math.floor(s / this.columnWidth); o = Math.max(0, o); var a = Math.floor(r / this.columnWidth); a -= r % this.columnWidth ? 0 : 1, a = Math.min(this.cols - 1, a); for (var l = (this._getOption("originTop") ? n.top : n.bottom) + i.outerHeight, c = o; c <= a; c++)this.colYs[c] = Math.max(l, this.colYs[c]) }, n._getContainerSize = function () { this.maxY = Math.max.apply(Math, this.colYs); var e = { height: this.maxY }; return this._getOption("fitWidth") && (e.width = this._getContainerFitWidth()), e }, n._getContainerFitWidth = function () { for (var e = 0, t = this.cols; --t && 0 === this.colYs[t];)e++; return (this.cols - e) * this.columnWidth - this.gutter }, n.needsResizeLayout = function () { var e = this.containerWidth; return this.getContainerWidth(), e != this.containerWidth }, i })), function (e, t) { "function" == typeof define && define.amd ? define("isotope-layout/js/layout-modes/masonry", ["../layout-mode", "masonry-layout/masonry"], t) : "object" == typeof module && module.exports ? module.exports = t(require("../layout-mode"), require("masonry-layout")) : t(e.Isotope.LayoutMode, e.Masonry) }(window, (function (e, t) { "use strict"; var i = e.create("masonry"), n = i.prototype, s = { _getElementOffset: !0, layout: !0, _getMeasurement: !0 }; for (var r in t.prototype) s[r] || (n[r] = t.prototype[r]); var o = n.measureColumns; n.measureColumns = function () { this.items = this.isotope.filteredItems, o.call(this) }; var a = n._getOption; return n._getOption = function (e) { return "fitWidth" == e ? void 0 !== this.options.isFitWidth ? this.options.isFitWidth : this.options.fitWidth : a.apply(this.isotope, arguments) }, i })), function (e, t) { "function" == typeof define && define.amd ? define("isotope-layout/js/layout-modes/fit-rows", ["../layout-mode"], t) : "object" == typeof exports ? module.exports = t(require("../layout-mode")) : t(e.Isotope.LayoutMode) }(window, (function (e) { "use strict"; var t = e.create("fitRows"), i = t.prototype; return i._resetLayout = function () { this.x = 0, this.y = 0, this.maxY = 0, this._getMeasurement("gutter", "outerWidth") }, i._getItemLayoutPosition = function (e) { e.getSize(); var t = e.size.outerWidth + this.gutter, i = this.isotope.size.innerWidth + this.gutter; 0 !== this.x && t + this.x > i && (this.x = 0, this.y = this.maxY); var n = { x: this.x, y: this.y }; return this.maxY = Math.max(this.maxY, this.y + e.size.outerHeight), this.x += t, n }, i._getContainerSize = function () { return { height: this.maxY } }, t })), function (e, t) { "function" == typeof define && define.amd ? define("isotope-layout/js/layout-modes/vertical", ["../layout-mode"], t) : "object" == typeof module && module.exports ? module.exports = t(require("../layout-mode")) : t(e.Isotope.LayoutMode) }(window, (function (e) { "use strict"; var t = e.create("vertical", { horizontalAlignment: 0 }), i = t.prototype; return i._resetLayout = function () { this.y = 0 }, i._getItemLayoutPosition = function (e) { e.getSize(); var t = (this.isotope.size.innerWidth - e.size.outerWidth) * this.options.horizontalAlignment, i = this.y; return this.y += e.size.outerHeight, { x: t, y: i } }, i._getContainerSize = function () { return { height: this.y } }, t })), function (e, t) { "function" == typeof define && define.amd ? define(["outlayer/outlayer", "get-size/get-size", "desandro-matches-selector/matches-selector", "fizzy-ui-utils/utils", "isotope-layout/js/item", "isotope-layout/js/layout-mode", "isotope-layout/js/layout-modes/masonry", "isotope-layout/js/layout-modes/fit-rows", "isotope-layout/js/layout-modes/vertical"], (function (i, n, s, r, o, a) { return t(e, i, n, s, r, o, a) })) : "object" == typeof module && module.exports ? module.exports = t(e, require("outlayer"), require("get-size"), require("desandro-matches-selector"), require("fizzy-ui-utils"), require("isotope-layout/js/item"), require("isotope-layout/js/layout-mode"), require("isotope-layout/js/layout-modes/masonry"), require("isotope-layout/js/layout-modes/fit-rows"), require("isotope-layout/js/layout-modes/vertical")) : e.Isotope = t(e, e.Outlayer, e.getSize, e.matchesSelector, e.fizzyUIUtils, e.Isotope.Item, e.Isotope.LayoutMode) }(window, (function (e, t, i, n, s, r, o) { var a = e.jQuery, l = String.prototype.trim ? function (e) { return e.trim() } : function (e) { return e.replace(/^\s+|\s+$/g, "") }, c = t.create("isotope", { layoutMode: "masonry", isJQueryFiltering: !0, sortAscending: !0 }); c.Item = r, c.LayoutMode = o; var d = c.prototype; d._create = function () { for (var e in this.itemGUID = 0, this._sorters = {}, this._getSorters(), t.prototype._create.call(this), this.modes = {}, this.filteredItems = this.items, this.sortHistory = ["original-order"], o.modes) this._initLayoutMode(e) }, d.reloadItems = function () { this.itemGUID = 0, t.prototype.reloadItems.call(this) }, d._itemize = function () { for (var e = t.prototype._itemize.apply(this, arguments), i = 0; i < e.length; i++) { e[i].id = this.itemGUID++ } return this._updateItemsSortData(e), e }, d._initLayoutMode = function (e) { var t = o.modes[e], i = this.options[e] || {}; this.options[e] = t.options ? s.extend(t.options, i) : i, this.modes[e] = new t(this) }, d.layout = function () { return !this._isLayoutInited && this._getOption("initLayout") ? void this.arrange() : void this._layout() }, d._layout = function () { var e = this._getIsInstant(); this._resetLayout(), this._manageStamps(), this.layoutItems(this.filteredItems, e), this._isLayoutInited = !0 }, d.arrange = function (e) { this.option(e), this._getIsInstant(); var t = this._filter(this.items); this.filteredItems = t.matches, this._bindArrangeComplete(), this._isInstant ? this._noTransition(this._hideReveal, [t]) : this._hideReveal(t), this._sort(), this._layout() }, d._init = d.arrange, d._hideReveal = function (e) { this.reveal(e.needReveal), this.hide(e.needHide) }, d._getIsInstant = function () { var e = this._getOption("layoutInstant"), t = void 0 !== e ? e : !this._isLayoutInited; return this._isInstant = t, t }, d._bindArrangeComplete = function () { function e() { t && i && n && s.dispatchEvent("arrangeComplete", null, [s.filteredItems]) } var t, i, n, s = this; this.once("layoutComplete", (function () { t = !0, e() })), this.once("hideComplete", (function () { i = !0, e() })), this.once("revealComplete", (function () { n = !0, e() })) }, d._filter = function (e) { var t = this.options.filter; t = t || "*"; for (var i = [], n = [], s = [], r = this._getFilterTest(t), o = 0; o < e.length; o++) { var a = e[o]; if (!a.isIgnored) { var l = r(a); l && i.push(a), l && a.isHidden ? n.push(a) : l || a.isHidden || s.push(a) } } return { matches: i, needReveal: n, needHide: s } }, d._getFilterTest = function (e) { return a && this.options.isJQueryFiltering ? function (t) { return a(t.element).is(e) } : "function" == typeof e ? function (t) { return e(t.element) } : function (t) { return n(t.element, e) } }, d.updateSortData = function (e) { var t; e ? (e = s.makeArray(e), t = this.getItems(e)) : t = this.items, this._getSorters(), this._updateItemsSortData(t) }, d._getSorters = function () { var e = this.options.getSortData; for (var t in e) { var i = e[t]; this._sorters[t] = u(i) } }, d._updateItemsSortData = function (e) { for (var t = e && e.length, i = 0; t && i < t; i++) { e[i].updateSortData() } }; var u = function (e) { if ("string" != typeof e) return e; var t = l(e).split(" "), i = t[0], n = i.match(/^\[(.+)\]$/), s = function (e, t) { return e ? function (t) { return t.getAttribute(e) } : function (e) { var i = e.querySelector(t); return i && i.textContent } }(n && n[1], i), r = c.sortDataParsers[t[1]]; return r ? function (e) { return e && r(s(e)) } : function (e) { return e && s(e) } }; c.sortDataParsers = { parseInt: function (e) { return parseInt(e, 10) }, parseFloat: function (e) { return parseFloat(e) } }, d._sort = function () { if (this.options.sortBy) { var e = s.makeArray(this.options.sortBy); this._getIsSameSortBy(e) || (this.sortHistory = e.concat(this.sortHistory)); var t = function (e, t) { return function (i, n) { for (var s = 0; s < e.length; s++) { var r = e[s], o = i.sortData[r], a = n.sortData[r]; if (o > a || o < a) return (o > a ? 1 : -1) * ((void 0 !== t[r] ? t[r] : t) ? 1 : -1) } return 0 } }(this.sortHistory, this.options.sortAscending); this.filteredItems.sort(t) } }, d._getIsSameSortBy = function (e) { for (var t = 0; t < e.length; t++)if (e[t] != this.sortHistory[t]) return !1; return !0 }, d._mode = function () { var e = this.options.layoutMode, t = this.modes[e]; if (!t) throw new Error("No layout mode: " + e); return t.options = this.options[e], t }, d._resetLayout = function () { t.prototype._resetLayout.call(this), this._mode()._resetLayout() }, d._getItemLayoutPosition = function (e) { return this._mode()._getItemLayoutPosition(e) }, d._manageStamp = function (e) { this._mode()._manageStamp(e) }, d._getContainerSize = function () { return this._mode()._getContainerSize() }, d.needsResizeLayout = function () { return this._mode().needsResizeLayout() }, d.appended = function (e) { var t = this.addItems(e); if (t.length) { var i = this._filterRevealAdded(t); this.filteredItems = this.filteredItems.concat(i) } }, d.prepended = function (e) { var t = this._itemize(e); if (t.length) { this._resetLayout(), this._manageStamps(); var i = this._filterRevealAdded(t); this.layoutItems(this.filteredItems), this.filteredItems = i.concat(this.filteredItems), this.items = t.concat(this.items) } }, d._filterRevealAdded = function (e) { var t = this._filter(e); return this.hide(t.needHide), this.reveal(t.matches), this.layoutItems(t.matches, !0), t.matches }, d.insert = function (e) { var t = this.addItems(e); if (t.length) { var i, n, s = t.length; for (i = 0; i < s; i++)n = t[i], this.element.appendChild(n.element); var r = this._filter(t).matches; for (i = 0; i < s; i++)t[i].isLayoutInstant = !0; for (this.arrange(), i = 0; i < s; i++)delete t[i].isLayoutInstant; this.reveal(r) } }; var h = d.remove; return d.remove = function (e) { e = s.makeArray(e); var t = this.getItems(e); h.call(this, e); for (var i = t && t.length, n = 0; i && n < i; n++) { var r = t[n]; s.removeFrom(this.filteredItems, r) } }, d.shuffle = function () { for (var e = 0; e < this.items.length; e++) { this.items[e].sortData.random = Math.random() } this.options.sortBy = "random", this._sort(), this._layout() }, d._noTransition = function (e, t) { var i = this.options.transitionDuration; this.options.transitionDuration = 0; var n = e.apply(this, t); return this.options.transitionDuration = i, n }, d.getFilteredItemElements = function () { return this.filteredItems.map((function (e) { return e.element })) }, c }));
/*!
 * iTooltip.js v1.1.1
 * https://github.com/Ins-V/iTooltip
 */
class DoubleCenterException { constructor() { window.console.error('iTooltip Error: positionX and positionY properties cannot be "center" at the same time.') } } class iTooltip { constructor(e = "*") { const t = "*" !== e ? e : "*[title]"; this.objects = document.querySelectorAll(t) } init(e = {}) { if (this.settings = Object.assign({ className: "tooltip", indentX: 10, indentY: 15, positionX: "right", positionY: "bottom" }, e), "center" === this.settings.positionX && "center" === this.settings.positionY) throw new DoubleCenterException; this.objects.forEach((e => { e.getAttribute("title") && (e.addEventListener("mouseenter", (e => this.createTooltip(e))), e.addEventListener("mouseleave", (e => this.removeTooltip(e)))) })) } createTooltip(e) { const t = e.target; this.tooltip = document.createElement("div"), this.tooltip.classList.add(this.settings.className), this.tooltip.innerHTML = t.getAttribute("title"); var i = e.target.className.split(" ").find((e => e.startsWith("itooltip-"))); i && this.tooltip.classList.add(i), this.tooltip.style.position = "absolute", this.changePosition(e), t.removeAttribute("title"), document.body.appendChild(this.tooltip), t.addEventListener("mousemove", (e => this.changePosition(e))) } removeTooltip(e) { e.target.setAttribute("title", this.tooltip.innerHTML), this.tooltip.remove() } changePosition(e) { const [t, i] = this.getSizeTooltip(), n = this.getEdges(e), s = window.pageYOffset || document.documentElement.scrollTop; let r = e.pageY, o = e.pageX; if (o = "right" === this.settings.positionX ? n.right <= t ? e.clientX - t - this.settings.indentX : e.clientX + this.settings.indentX : "left" === this.settings.positionX ? n.left <= t ? n.left + this.settings.indentX : e.clientX - t - this.settings.indentX : n.left <= Math.round(t / 2) ? e.clientX - n.left : e.clientX - Math.round(t / 2), "top" === this.settings.positionY) r = n.top <= i ? s + e.clientY + this.settings.indentY : e.pageY - i - this.settings.indentY; else if ("bottom" === this.settings.positionY) r = n.bottom < i && n.top > i + this.settings.indentY ? e.pageY - i - this.settings.indentY : s + e.clientY + this.settings.indentY; else { let e = Math.round(i / 2); n.bottom <= e && (e = Math.round(i - n.bottom)), n.top <= e && (e = n.top), r -= e } this.tooltip.style.top = `${r}px`, this.tooltip.style.left = `${o}px` } getSizeTooltip() { const e = this.tooltip.getBoundingClientRect(); return [e.right - e.left, e.bottom - e.top] } getEdges(e) { const t = document.documentElement; return { left: e.clientX, right: t.clientWidth - e.clientX, top: e.clientY, bottom: t.clientHeight - e.clientY } } }
/*!
Waypoints - 4.0.1
Copyright  2011-2016 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blob/master/licenses.txt
*/!function () { "use strict"; function e(n) { if (!n) throw new Error("No options passed to Waypoint constructor"); if (!n.element) throw new Error("No element option passed to Waypoint constructor"); if (!n.handler) throw new Error("No handler option passed to Waypoint constructor"); this.key = "waypoint-" + t, this.options = e.Adapter.extend({}, e.defaults, n), this.element = this.options.element, this.adapter = new e.Adapter(this.element), this.callback = n.handler, this.axis = this.options.horizontal ? "horizontal" : "vertical", this.enabled = this.options.enabled, this.triggerPoint = null, this.group = e.Group.findOrCreate({ name: this.options.group, axis: this.axis }), this.context = e.Context.findOrCreateByElement(this.options.context), e.offsetAliases[this.options.offset] && (this.options.offset = e.offsetAliases[this.options.offset]), this.group.add(this), this.context.add(this), i[this.key] = this, t += 1 } var t = 0, i = {}; e.prototype.queueTrigger = function (e) { this.group.queueTrigger(this, e) }, e.prototype.trigger = function (e) { this.enabled && this.callback && this.callback.apply(this, e) }, e.prototype.destroy = function () { this.context.remove(this), this.group.remove(this), delete i[this.key] }, e.prototype.disable = function () { return this.enabled = !1, this }, e.prototype.enable = function () { return this.context.refresh(), this.enabled = !0, this }, e.prototype.next = function () { return this.group.next(this) }, e.prototype.previous = function () { return this.group.previous(this) }, e.invokeAll = function (e) { var t = []; for (var n in i) t.push(i[n]); for (var s = 0, r = t.length; r > s; s++)t[s][e]() }, e.destroyAll = function () { e.invokeAll("destroy") }, e.disableAll = function () { e.invokeAll("disable") }, e.enableAll = function () { for (var t in e.Context.refreshAll(), i) i[t].enabled = !0; return this }, e.refreshAll = function () { e.Context.refreshAll() }, e.viewportHeight = function () { return window.innerHeight || document.documentElement.clientHeight }, e.viewportWidth = function () { return document.documentElement.clientWidth }, e.adapters = [], e.defaults = { context: window, continuous: !0, enabled: !0, group: "default", horizontal: !1, offset: 0 }, e.offsetAliases = { "bottom-in-view": function () { return this.context.innerHeight() - this.adapter.outerHeight() }, "right-in-view": function () { return this.context.innerWidth() - this.adapter.outerWidth() } }, window.Waypoint = e }(), function () { "use strict"; function e(e) { window.setTimeout(e, 1e3 / 60) } function t(e) { this.element = e, this.Adapter = s.Adapter, this.adapter = new this.Adapter(e), this.key = "waypoint-context-" + i, this.didScroll = !1, this.didResize = !1, this.oldScroll = { x: this.adapter.scrollLeft(), y: this.adapter.scrollTop() }, this.waypoints = { vertical: {}, horizontal: {} }, e.waypointContextKey = this.key, n[e.waypointContextKey] = this, i += 1, s.windowContext || (s.windowContext = !0, s.windowContext = new t(window)), this.createThrottledScrollHandler(), this.createThrottledResizeHandler() } var i = 0, n = {}, s = window.Waypoint, r = window.onload; t.prototype.add = function (e) { var t = e.options.horizontal ? "horizontal" : "vertical"; this.waypoints[t][e.key] = e, this.refresh() }, t.prototype.checkEmpty = function () { var e = this.Adapter.isEmptyObject(this.waypoints.horizontal), t = this.Adapter.isEmptyObject(this.waypoints.vertical), i = this.element == this.element.window; e && t && !i && (this.adapter.off(".waypoints"), delete n[this.key]) }, t.prototype.createThrottledResizeHandler = function () { function e() { t.handleResize(), t.didResize = !1 } var t = this; this.adapter.on("resize.waypoints", (function () { t.didResize || (t.didResize = !0, s.requestAnimationFrame(e)) })) }, t.prototype.createThrottledScrollHandler = function () { function e() { t.handleScroll(), t.didScroll = !1 } var t = this; this.adapter.on("scroll.waypoints", (function () { (!t.didScroll || s.isTouch) && (t.didScroll = !0, s.requestAnimationFrame(e)) })) }, t.prototype.handleResize = function () { s.Context.refreshAll() }, t.prototype.handleScroll = function () { var e = {}, t = { horizontal: { newScroll: this.adapter.scrollLeft(), oldScroll: this.oldScroll.x, forward: "right", backward: "left" }, vertical: { newScroll: this.adapter.scrollTop(), oldScroll: this.oldScroll.y, forward: "down", backward: "up" } }; for (var i in t) { var n = t[i], s = n.newScroll > n.oldScroll ? n.forward : n.backward; for (var r in this.waypoints[i]) { var o = this.waypoints[i][r]; if (null !== o.triggerPoint) { var a = n.oldScroll < o.triggerPoint, l = n.newScroll >= o.triggerPoint; (a && l || !a && !l) && (o.queueTrigger(s), e[o.group.id] = o.group) } } } for (var c in e) e[c].flushTriggers(); this.oldScroll = { x: t.horizontal.newScroll, y: t.vertical.newScroll } }, t.prototype.innerHeight = function () { return this.element == this.element.window ? s.viewportHeight() : this.adapter.innerHeight() }, t.prototype.remove = function (e) { delete this.waypoints[e.axis][e.key], this.checkEmpty() }, t.prototype.innerWidth = function () { return this.element == this.element.window ? s.viewportWidth() : this.adapter.innerWidth() }, t.prototype.destroy = function () { var e = []; for (var t in this.waypoints) for (var i in this.waypoints[t]) e.push(this.waypoints[t][i]); for (var n = 0, s = e.length; s > n; n++)e[n].destroy() }, t.prototype.refresh = function () { var e, t = this.element == this.element.window, i = t ? void 0 : this.adapter.offset(), n = {}; for (var r in this.handleScroll(), e = { horizontal: { contextOffset: t ? 0 : i.left, contextScroll: t ? 0 : this.oldScroll.x, contextDimension: this.innerWidth(), oldScroll: this.oldScroll.x, forward: "right", backward: "left", offsetProp: "left" }, vertical: { contextOffset: t ? 0 : i.top, contextScroll: t ? 0 : this.oldScroll.y, contextDimension: this.innerHeight(), oldScroll: this.oldScroll.y, forward: "down", backward: "up", offsetProp: "top" } }) { var o = e[r]; for (var a in this.waypoints[r]) { var l, c, d, u, h = this.waypoints[r][a], p = h.options.offset, f = h.triggerPoint, m = 0, g = null == f; h.element !== h.element.window && (m = h.adapter.offset()[o.offsetProp]), "function" == typeof p ? p = p.apply(h) : "string" == typeof p && (p = parseFloat(p), h.options.offset.indexOf("%") > -1 && (p = Math.ceil(o.contextDimension * p / 100))), l = o.contextScroll - o.contextOffset, h.triggerPoint = Math.floor(m + l - p), c = f < o.oldScroll, d = h.triggerPoint >= o.oldScroll, u = !c && !d, !g && (c && d) ? (h.queueTrigger(o.backward), n[h.group.id] = h.group) : (!g && u || g && o.oldScroll >= h.triggerPoint) && (h.queueTrigger(o.forward), n[h.group.id] = h.group) } } return s.requestAnimationFrame((function () { for (var e in n) n[e].flushTriggers() })), this }, t.findOrCreateByElement = function (e) { return t.findByElement(e) || new t(e) }, t.refreshAll = function () { for (var e in n) n[e].refresh() }, t.findByElement = function (e) { return n[e.waypointContextKey] }, window.onload = function () { r && r(), t.refreshAll() }, s.requestAnimationFrame = function (t) { (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || e).call(window, t) }, s.Context = t }(), function () { "use strict"; function e(e, t) { return e.triggerPoint - t.triggerPoint } function t(e, t) { return t.triggerPoint - e.triggerPoint } function i(e) { this.name = e.name, this.axis = e.axis, this.id = this.name + "-" + this.axis, this.waypoints = [], this.clearTriggerQueues(), n[this.axis][this.name] = this } var n = { vertical: {}, horizontal: {} }, s = window.Waypoint; i.prototype.add = function (e) { this.waypoints.push(e) }, i.prototype.clearTriggerQueues = function () { this.triggerQueues = { up: [], down: [], left: [], right: [] } }, i.prototype.flushTriggers = function () { for (var i in this.triggerQueues) { var n = this.triggerQueues[i], s = "up" === i || "left" === i; n.sort(s ? t : e); for (var r = 0, o = n.length; o > r; r += 1) { var a = n[r]; (a.options.continuous || r === n.length - 1) && a.trigger([i]) } } this.clearTriggerQueues() }, i.prototype.next = function (t) { this.waypoints.sort(e); var i = s.Adapter.inArray(t, this.waypoints); return i === this.waypoints.length - 1 ? null : this.waypoints[i + 1] }, i.prototype.previous = function (t) { this.waypoints.sort(e); var i = s.Adapter.inArray(t, this.waypoints); return i ? this.waypoints[i - 1] : null }, i.prototype.queueTrigger = function (e, t) { this.triggerQueues[t].push(e) }, i.prototype.remove = function (e) { var t = s.Adapter.inArray(e, this.waypoints); t > -1 && this.waypoints.splice(t, 1) }, i.prototype.first = function () { return this.waypoints[0] }, i.prototype.last = function () { return this.waypoints[this.waypoints.length - 1] }, i.findOrCreate = function (e) { return n[e.axis][e.name] || new i(e) }, s.Group = i }(), function () { "use strict"; function e(e) { return e === e.window } function t(t) { return e(t) ? t : t.defaultView } function i(e) { this.element = e, this.handlers = {} } var n = window.Waypoint; i.prototype.innerHeight = function () { return e(this.element) ? this.element.innerHeight : this.element.clientHeight }, i.prototype.innerWidth = function () { return e(this.element) ? this.element.innerWidth : this.element.clientWidth }, i.prototype.off = function (e, t) { function i(e, t, i) { for (var n = 0, s = t.length - 1; s > n; n++) { var r = t[n]; i && i !== r || e.removeEventListener(r) } } var n = e.split("."), s = n[0], r = n[1], o = this.element; if (r && this.handlers[r] && s) i(o, this.handlers[r][s], t), this.handlers[r][s] = []; else if (s) for (var a in this.handlers) i(o, this.handlers[a][s] || [], t), this.handlers[a][s] = []; else if (r && this.handlers[r]) { for (var l in this.handlers[r]) i(o, this.handlers[r][l], t); this.handlers[r] = {} } }, i.prototype.offset = function () { if (!this.element.ownerDocument) return null; var e = this.element.ownerDocument.documentElement, i = t(this.element.ownerDocument), n = { top: 0, left: 0 }; return this.element.getBoundingClientRect && (n = this.element.getBoundingClientRect()), { top: n.top + i.pageYOffset - e.clientTop, left: n.left + i.pageXOffset - e.clientLeft } }, i.prototype.on = function (e, t) { var i = e.split("."), n = i[0], s = i[1] || "__default", r = this.handlers[s] = this.handlers[s] || {}; (r[n] = r[n] || []).push(t), this.element.addEventListener(n, t) }, i.prototype.outerHeight = function (t) { var i, n = this.innerHeight(); return t && !e(this.element) && (i = window.getComputedStyle(this.element), n += parseInt(i.marginTop, 10), n += parseInt(i.marginBottom, 10)), n }, i.prototype.outerWidth = function (t) { var i, n = this.innerWidth(); return t && !e(this.element) && (i = window.getComputedStyle(this.element), n += parseInt(i.marginLeft, 10), n += parseInt(i.marginRight, 10)), n }, i.prototype.scrollLeft = function () { var e = t(this.element); return e ? e.pageXOffset : this.element.scrollLeft }, i.prototype.scrollTop = function () { var e = t(this.element); return e ? e.pageYOffset : this.element.scrollTop }, i.extend = function () { function e(e, t) { if ("object" == typeof e && "object" == typeof t) for (var i in t) t.hasOwnProperty(i) && (e[i] = t[i]); return e } for (var t = Array.prototype.slice.call(arguments), i = 1, n = t.length; n > i; i++)e(t[0], t[i]); return t[0] }, i.inArray = function (e, t, i) { return null == t ? -1 : t.indexOf(e, i) }, i.isEmptyObject = function (e) { for (var t in e) return !1; return !0 }, n.adapters.push({ name: "noframework", Adapter: i }), n.Adapter = i }(), function (e) { var t = navigator.userAgent; e.HTMLPictureElement && /ecko/.test(t) && t.match(/rv\:(\d+)/) && RegExp.$1 < 45 && addEventListener("resize", function () { var t, i = document.createElement("source"), n = function (e) { var t, n, s = e.parentNode; "PICTURE" === s.nodeName.toUpperCase() ? (t = i.cloneNode(), s.insertBefore(t, s.firstElementChild), setTimeout((function () { s.removeChild(t) }))) : (!e._pfLastSize || e.offsetWidth > e._pfLastSize) && (e._pfLastSize = e.offsetWidth, n = e.sizes, e.sizes += ",100vw", setTimeout((function () { e.sizes = n }))) }, s = function () { var e, t = document.querySelectorAll("picture > img, img[srcset][sizes]"); for (e = 0; e < t.length; e++)n(t[e]) }, r = function () { clearTimeout(t), t = setTimeout(s, 99) }, o = e.matchMedia && matchMedia("(orientation: landscape)"), a = function () { r(), o && o.addListener && o.addListener(r) }; return i.srcset = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", /^[c|i]|d$/.test(document.readyState || "") ? a() : document.addEventListener("DOMContentLoaded", a), r }()) }(window), function (e, t, i) { "use strict"; function n(e) { return " " === e || "\t" === e || "\n" === e || "\f" === e || "\r" === e } function s(e, t, i, n) { var s, r, o; return "saveData" === w.algorithm ? e > 2.7 ? o = i + 1 : (r = (t - i) * (s = Math.pow(e - .6, 1.5)), n && (r += .1 * s), o = e + r) : o = i > 1 ? Math.sqrt(e * t) : e, o > i } function r(e, t) { return e.res - t.res } function o(e, t, i) { var n; return !i && t && (i = (i = e[u.ns].sets) && i[i.length - 1]), (n = a(t, i)) && (t = u.makeUrl(t), e[u.ns].curSrc = t, e[u.ns].curCan = n, n.res || X(n, n.set.sizes)), n } function a(e, t) { var i, n, s; if (e && t) for (s = u.parseSet(t), e = u.makeUrl(e), i = 0; i < s.length; i++)if (e === u.makeUrl(s[i].url)) { n = s[i]; break } return n } t.createElement("picture"); var l, c, d, u = {}, h = !1, p = function () { }, f = t.createElement("img"), m = f.getAttribute, g = f.setAttribute, v = f.removeAttribute, y = t.documentElement, b = {}, w = { algorithm: "" }, x = "data-pfsrc", _ = x + "set", T = navigator.userAgent, E = /rident/.test(T) || /ecko/.test(T) && T.match(/rv\:(\d+)/) && RegExp.$1 > 35, S = "currentSrc", C = /\s+\+?\d+(e\d+)?w/, k = /(\([^)]+\))?\s*(.+)/, A = e.picturefillCFG, $ = "font-size:100%!important;", M = !0, P = {}, I = {}, L = e.devicePixelRatio, O = { px: 1, in: 96 }, z = t.createElement("a"), D = !1, N = /^[ \t\n\r\u000c]+/, j = /^[, \t\n\r\u000c]+/, F = /^[^ \t\n\r\u000c]+/, H = /[,]+$/, q = /^\d+$/, B = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, R = function (e, t, i, n) { e.addEventListener ? e.addEventListener(t, i, n || !1) : e.attachEvent && e.attachEvent("on" + t, i) }, W = function (e) { var t = {}; return function (i) { return i in t || (t[i] = e(i)), t[i] } }, Y = function () { var e = /^([\d\.]+)(em|vw|px)$/, t = W((function (e) { return "return " + function () { for (var e = arguments, t = 0, i = e[0]; ++t in e;)i = i.replace(e[t], e[++t]); return i }((e || "").toLowerCase(), /\band\b/g, "&&", /,/g, "||", /min-([a-z-\s]+):/g, "e.$1>=", /max-([a-z-\s]+):/g, "e.$1<=", /calc([^)]+)/g, "($1)", /(\d+[\.]*[\d]*)([a-z]+)/g, "($1 * e.$2)", /^(?!(e.[a-z]|[0-9\.&=|><\+\-\*\(\)\/])).*/gi, "") + ";" })); return function (i, n) { var s; if (!(i in P)) if (P[i] = !1, n && (s = i.match(e))) P[i] = s[1] * O[s[2]]; else try { P[i] = new Function("e", t(i))(O) } catch (e) { } return P[i] } }(), X = function (e, t) { return e.w ? (e.cWidth = u.calcListLength(t || "100vw"), e.res = e.w / e.cWidth) : e.res = e.d, e }, V = function (e) { if (h) { var i, n, s, r = e || {}; if (r.elements && 1 === r.elements.nodeType && ("IMG" === r.elements.nodeName.toUpperCase() ? r.elements = [r.elements] : (r.context = r.elements, r.elements = null)), s = (i = r.elements || u.qsa(r.context || t, r.reevaluate || r.reselect ? u.sel : u.selShort)).length) { for (u.setupRun(r), D = !0, n = 0; s > n; n++)u.fillImg(i[n], r); u.teardownRun(r) } } }; e.console && console.warn, S in f || (S = "src"), b["image/jpeg"] = !0, b["image/gif"] = !0, b["image/png"] = !0, b["image/svg+xml"] = t.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1"), u.ns = ("pf" + (new Date).getTime()).substr(0, 9), u.supSrcset = "srcset" in f, u.supSizes = "sizes" in f, u.supPicture = !!e.HTMLPictureElement, u.supSrcset && u.supPicture && !u.supSizes && function (e) { f.srcset = "data:,a", e.src = "data:,a", u.supSrcset = f.complete === e.complete, u.supPicture = u.supSrcset && u.supPicture }(t.createElement("img")), u.supSrcset && !u.supSizes ? function () { var e = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", i = t.createElement("img"), n = function () { 2 === i.width && (u.supSizes = !0), c = u.supSrcset && !u.supSizes, h = !0, setTimeout(V) }; i.onload = n, i.onerror = n, i.setAttribute("sizes", "9px"), i.srcset = e + " 1w,data:image/gif;base64,R0lGODlhAgABAPAAAP///wAAACH5BAAAAAAALAAAAAACAAEAAAICBAoAOw== 9w", i.src = e }() : h = !0, u.selShort = "picture>img,img[srcset]", u.sel = u.selShort, u.cfg = w, u.DPR = L || 1, u.u = O, u.types = b, u.setSize = p, u.makeUrl = W((function (e) { return z.href = e, z.href })), u.qsa = function (e, t) { return "querySelector" in e ? e.querySelectorAll(t) : [] }, u.matchesMedia = function () { return e.matchMedia && (matchMedia("(min-width: 0.1em)") || {}).matches ? u.matchesMedia = function (e) { return !e || matchMedia(e).matches } : u.matchesMedia = u.mMQ, u.matchesMedia.apply(this, arguments) }, u.mMQ = function (e) { return !e || Y(e) }, u.calcLength = function (e) { var t = Y(e, !0) || !1; return 0 > t && (t = !1), t }, u.supportsType = function (e) { return !e || b[e] }, u.parseSize = W((function (e) { var t = (e || "").match(k); return { media: t && t[1], length: t && t[2] } })), u.parseSet = function (e) { return e.cands || (e.cands = function (e, t) { function i(t) { var i, n = t.exec(e.substring(h)); return n ? (i = n[0], h += i.length, i) : void 0 } function s() { var e, i, n, s, r, l, c, d, u, h = !1, f = {}; for (s = 0; s < a.length; s++)l = (r = a[s])[r.length - 1], c = r.substring(0, r.length - 1), d = parseInt(c, 10), u = parseFloat(c), q.test(c) && "w" === l ? ((e || i) && (h = !0), 0 === d ? h = !0 : e = d) : B.test(c) && "x" === l ? ((e || i || n) && (h = !0), 0 > u ? h = !0 : i = u) : q.test(c) && "h" === l ? ((n || i) && (h = !0), 0 === d ? h = !0 : n = d) : h = !0; h || (f.url = o, e && (f.w = e), i && (f.d = i), n && (f.h = n), n || i || e || (f.d = 1), 1 === f.d && (t.has1x = !0), f.set = t, p.push(f)) } function r() { for (i(N), l = "", c = "in descriptor"; ;) { if (d = e.charAt(h), "in descriptor" === c) if (n(d)) l && (a.push(l), l = "", c = "after descriptor"); else { if ("," === d) return h += 1, l && a.push(l), void s(); if ("(" === d) l += d, c = "in parens"; else { if ("" === d) return l && a.push(l), void s(); l += d } } else if ("in parens" === c) if (")" === d) l += d, c = "in descriptor"; else { if ("" === d) return a.push(l), void s(); l += d } else if ("after descriptor" === c) if (n(d)); else { if ("" === d) return void s(); c = "in descriptor", h -= 1 } h += 1 } } for (var o, a, l, c, d, u = e.length, h = 0, p = []; ;) { if (i(j), h >= u) return p; o = i(F), a = [], "," === o.slice(-1) ? (o = o.replace(H, ""), s()) : r() } }(e.srcset, e)), e.cands }, u.getEmValue = function () { var e; if (!l && (e = t.body)) { var i = t.createElement("div"), n = y.style.cssText, s = e.style.cssText; i.style.cssText = "position:absolute;left:0;visibility:hidden;display:block;padding:0;border:none;font-size:1em;width:1em;overflow:hidden;clip:rect(0px, 0px, 0px, 0px)", y.style.cssText = $, e.style.cssText = $, e.appendChild(i), l = i.offsetWidth, e.removeChild(i), l = parseFloat(l, 10), y.style.cssText = n, e.style.cssText = s } return l || 16 }, u.calcListLength = function (e) { if (!(e in I) || w.uT) { var t = u.calcLength(function (e) { function t(e) { return !!(c.test(e) && parseFloat(e) >= 0) || !!d.test(e) || "0" === e || "-0" === e || "+0" === e } var i, s, r, o, a, l, c = /^(?:[+-]?[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?(?:ch|cm|em|ex|in|mm|pc|pt|px|rem|vh|vmin|vmax|vw)$/i, d = /^calc\((?:[0-9a-z \.\+\-\*\/\(\)]+)\)$/i; for (s = function (e) { function t() { r && (o.push(r), r = "") } function i() { o[0] && (a.push(o), o = []) } for (var s, r = "", o = [], a = [], l = 0, c = 0, d = !1; ;) { if ("" === (s = e.charAt(c))) return t(), i(), a; if (d) { if ("*" === s && "/" === e[c + 1]) { d = !1, c += 2, t(); continue } c += 1 } else { if (n(s)) { if (e.charAt(c - 1) && n(e.charAt(c - 1)) || !r) { c += 1; continue } if (0 === l) { t(), c += 1; continue } s = " " } else if ("(" === s) l += 1; else if (")" === s) l -= 1; else { if ("," === s) { t(), i(), c += 1; continue } if ("/" === s && "*" === e.charAt(c + 1)) { d = !0, c += 2; continue } } r += s, c += 1 } } }(e), r = s.length, i = 0; r > i; i++)if (t(a = (o = s[i])[o.length - 1])) { if (l = a, o.pop(), 0 === o.length) return l; if (o = o.join(" "), u.matchesMedia(o)) return l } return "100vw" }(e)); I[e] = t || O.width } return I[e] }, u.setRes = function (e) { var t; if (e) for (var i = 0, n = (t = u.parseSet(e)).length; n > i; i++)X(t[i], e.sizes); return t }, u.setRes.res = X, u.applySetCandidate = function (e, t) { if (e.length) { var i, n, a, l, c, d, h, p, f, m = t[u.ns], g = u.DPR; if (d = m.curSrc || t[S], (h = m.curCan || o(t, d, e[0].set)) && h.set === e[0].set && ((f = E && !t.complete && h.res - .1 > g) || (h.cached = !0, h.res >= g && (c = h))), !c) for (e.sort(r), c = e[(l = e.length) - 1], n = 0; l > n; n++)if ((i = e[n]).res >= g) { c = e[a = n - 1] && (f || d !== u.makeUrl(i.url)) && s(e[a].res, i.res, g, e[a].cached) ? e[a] : i; break } c && (p = u.makeUrl(c.url), m.curSrc = p, m.curCan = c, p !== d && u.setSrc(t, c), u.setSize(t)) } }, u.setSrc = function (e, t) { var i; e.src = t.url, "image/svg+xml" === t.set.type && (i = e.style.width, e.style.width = e.offsetWidth + 1 + "px", e.offsetWidth + 1 && (e.style.width = i)) }, u.getSet = function (e) { var t, i, n, s = !1, r = e[u.ns].sets; for (t = 0; t < r.length && !s; t++)if ((i = r[t]).srcset && u.matchesMedia(i.media) && (n = u.supportsType(i.type))) { "pending" === n && (i = n), s = i; break } return s }, u.parseSets = function (e, t, n) { var s, r, o, l, d = t && "PICTURE" === t.nodeName.toUpperCase(), h = e[u.ns]; (h.src === i || n.src) && (h.src = m.call(e, "src"), h.src ? g.call(e, x, h.src) : v.call(e, x)), (h.srcset === i || n.srcset || !u.supSrcset || e.srcset) && (s = m.call(e, "srcset"), h.srcset = s, l = !0), h.sets = [], d && (h.pic = !0, function (e, t) { var i, n, s, r, o = e.getElementsByTagName("source"); for (i = 0, n = o.length; n > i; i++)(s = o[i])[u.ns] = !0, (r = s.getAttribute("srcset")) && t.push({ srcset: r, media: s.getAttribute("media"), type: s.getAttribute("type"), sizes: s.getAttribute("sizes") }) }(t, h.sets)), h.srcset ? (r = { srcset: h.srcset, sizes: m.call(e, "sizes") }, h.sets.push(r), (o = (c || h.src) && C.test(h.srcset || "")) || !h.src || a(h.src, r) || r.has1x || (r.srcset += ", " + h.src, r.cands.push({ url: h.src, d: 1, set: r }))) : h.src && h.sets.push({ srcset: h.src, sizes: null }), h.curCan = null, h.curSrc = i, h.supported = !(d || r && !u.supSrcset || o && !u.supSizes), l && u.supSrcset && !h.supported && (s ? (g.call(e, _, s), e.srcset = "") : v.call(e, _)), h.supported && !h.srcset && (!h.src && e.src || e.src !== u.makeUrl(h.src)) && (null === h.src ? e.removeAttribute("src") : e.src = h.src), h.parsed = !0 }, u.fillImg = function (e, t) { var i, n = t.reselect || t.reevaluate; e[u.ns] || (e[u.ns] = {}), i = e[u.ns], (n || i.evaled !== d) && ((!i.parsed || t.reevaluate) && u.parseSets(e, e.parentNode, t), i.supported ? i.evaled = d : function (e) { var t, i = u.getSet(e), n = !1; "pending" !== i && (n = d, i && (t = u.setRes(i), u.applySetCandidate(t, e))), e[u.ns].evaled = n }(e)) }, u.setupRun = function () { (!D || M || L !== e.devicePixelRatio) && (M = !1, L = e.devicePixelRatio, P = {}, I = {}, u.DPR = L || 1, O.width = Math.max(e.innerWidth || 0, y.clientWidth), O.height = Math.max(e.innerHeight || 0, y.clientHeight), O.vw = O.width / 100, O.vh = O.height / 100, d = [O.height, O.width, L].join("-"), O.em = u.getEmValue(), O.rem = O.em) }, u.supPicture ? (V = p, u.fillImg = p) : function () { var i, n = e.attachEvent ? /d$|^c/ : /d$|^c|^i/, s = function () { var e = t.readyState || ""; r = setTimeout(s, "loading" === e ? 200 : 999), t.body && (u.fillImgs(), (i = i || n.test(e)) && clearTimeout(r)) }, r = setTimeout(s, t.body ? 9 : 99), o = y.clientHeight; R(e, "resize", function (e, t) { var i, n, s = function () { var r = new Date - n; t > r ? i = setTimeout(s, t - r) : (i = null, e()) }; return function () { n = new Date, i || (i = setTimeout(s, t)) } }((function () { M = Math.max(e.innerWidth || 0, y.clientWidth) !== O.width || y.clientHeight !== o, o = y.clientHeight, M && u.fillImgs() }), 99)), R(t, "readystatechange", s) }(), u.picturefill = V, u.fillImgs = V, u.teardownRun = p, V._ = u, e.picturefillCFG = { pf: u, push: function (e) { var t = e.shift(); "function" == typeof u[t] ? u[t].apply(u, e) : (w[t] = e[0], D && u.fillImgs({ reselect: !0 })) } }; for (; A && A.length;)e.picturefillCFG.push(A.shift()); e.picturefill = V, "object" == typeof module && "object" == typeof module.exports ? module.exports = V : "function" == typeof define && define.amd && define("picturefill", (function () { return V })), u.supPicture || (b["image/webp"] = function (t, i) { var n = new e.Image; return n.onerror = function () { b[t] = !1, V() }, n.onload = function () { b[t] = 1 === n.width, V() }, n.src = i, "pending" }("image/webp", "data:image/webp;base64,UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAABBxAR/Q9ERP8DAABWUDggGAAAADABAJ0BKgEAAQADADQlpAADcAD++/1QAA==")) }(window, document),
  /*!
   * Plyr v3.7.2
   * https://github.com/sampotts/plyr
   */
  "object" == typeof navigator && function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define("Plyr", t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).Plyr = t() }(this, (function () { "use strict"; function e(e, t, i) { return t in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } function t(e, t) { for (var i = 0; i < t.length; i++) { var n = t[i]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } function i(e, t, i) { return t in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } function n(e, t) { var i = Object.keys(e); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); t && (n = n.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), i.push.apply(i, n) } return i } function s(e) { for (var t = 1; t < arguments.length; t++) { var s = null != arguments[t] ? arguments[t] : {}; t % 2 ? n(Object(s), !0).forEach((function (t) { i(e, t, s[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(s)) : n(Object(s)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(s, t)) })) } return e } var r = { addCSS: !0, thumbWidth: 15, watch: !0 }; var o = function (e) { return null != e ? e.constructor : null }, a = function (e, t) { return !!(e && t && e instanceof t) }, l = function (e) { return o(e) === String }, c = function (e) { return Array.isArray(e) }, d = function (e) { return a(e, NodeList) }, u = l, h = c, p = d, f = function (e) { return a(e, Element) }, m = function (e) { return a(e, Event) }, g = function (e) { return function (e) { return null == e }(e) || (l(e) || c(e) || d(e)) && !e.length || function (e) { return o(e) === Object }(e) && !Object.keys(e).length }; var v = function () { function e(t, i) { (function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") })(this, e), f(t) ? this.element = t : u(t) && (this.element = document.querySelector(t)), f(this.element) && g(this.element.rangeTouch) && (this.config = s({}, r, {}, i), this.init()) } return function (e, i, n) { i && t(e.prototype, i), n && t(e, n) }(e, [{ key: "init", value: function () { e.enabled && (this.config.addCSS && (this.element.style.userSelect = "none", this.element.style.webKitUserSelect = "none", this.element.style.touchAction = "manipulation"), this.listeners(!0), this.element.rangeTouch = this) } }, { key: "destroy", value: function () { e.enabled && (this.config.addCSS && (this.element.style.userSelect = "", this.element.style.webKitUserSelect = "", this.element.style.touchAction = ""), this.listeners(!1), this.element.rangeTouch = null) } }, { key: "listeners", value: function (e) { var t = this, i = e ? "addEventListener" : "removeEventListener";["touchstart", "touchmove", "touchend"].forEach((function (e) { t.element[i](e, (function (e) { return t.set(e) }), !1) })) } }, { key: "get", value: function (t) { if (!e.enabled || !m(t)) return null; var i, n = t.target, s = t.changedTouches[0], r = parseFloat(n.getAttribute("min")) || 0, o = parseFloat(n.getAttribute("max")) || 100, a = parseFloat(n.getAttribute("step")) || 1, l = n.getBoundingClientRect(), c = 100 / l.width * (this.config.thumbWidth / 2) / 100; return 0 > (i = 100 / l.width * (s.clientX - l.left)) ? i = 0 : 100 < i && (i = 100), 50 > i ? i -= (100 - 2 * i) * c : 50 < i && (i += 2 * (i - 50) * c), r + function (e, t) { if (1 > t) { var i = function (e) { var t = "".concat(e).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/); return t ? Math.max(0, (t[1] ? t[1].length : 0) - (t[2] ? +t[2] : 0)) : 0 }(t); return parseFloat(e.toFixed(i)) } return Math.round(e / t) * t }(i / 100 * (o - r), a) } }, { key: "set", value: function (t) { e.enabled && m(t) && !t.target.disabled && (t.preventDefault(), t.target.value = this.get(t), function (e, t) { if (e && t) { var i = new Event(t, { bubbles: !0 }); e.dispatchEvent(i) } }(t.target, "touchend" === t.type ? "change" : "input")) } }], [{ key: "setup", value: function (t) { var i = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, n = null; if (g(t) || u(t) ? n = Array.from(document.querySelectorAll(u(t) ? t : 'input[type="range"]')) : f(t) ? n = [t] : p(t) ? n = Array.from(t) : h(t) && (n = t.filter(f)), g(n)) return null; var o = s({}, r, {}, i); if (u(t) && o.watch) { var a = new MutationObserver((function (i) { Array.from(i).forEach((function (i) { Array.from(i.addedNodes).forEach((function (i) { f(i) && function (e, t) { return function () { return Array.from(document.querySelectorAll(t)).includes(this) }.call(e, t) }(i, t) && new e(i, o) })) })) })); a.observe(document.body, { childList: !0, subtree: !0 }) } return n.map((function (t) { return new e(t, i) })) } }, { key: "enabled", get: function () { return "ontouchstart" in document.documentElement } }]), e }(); const y = e => null != e ? e.constructor : null, b = (e, t) => Boolean(e && t && e instanceof t), w = e => null == e, x = e => y(e) === Object, _ = e => y(e) === String, T = e => y(e) === Function, E = e => Array.isArray(e), S = e => b(e, NodeList), C = e => w(e) || (_(e) || E(e) || S(e)) && !e.length || x(e) && !Object.keys(e).length; var k = w, A = x, $ = e => y(e) === Number && !Number.isNaN(e), M = _, P = e => y(e) === Boolean, I = T, L = E, O = S, z = e => null !== e && "object" == typeof e && 1 === e.nodeType && "object" == typeof e.style && "object" == typeof e.ownerDocument, D = e => b(e, Event), N = e => b(e, KeyboardEvent), j = e => b(e, TextTrack) || !w(e) && _(e.kind), F = e => { if (b(e, window.URL)) return !0; if (!_(e)) return !1; let t = e; e.startsWith("http://") && e.startsWith("https://") || (t = `http://${e}`); try { return !C(new URL(t).hostname) } catch (e) { return !1 } }, H = C; const q = (() => { const e = document.createElement("span"), t = { WebkitTransition: "webkitTransitionEnd", MozTransition: "transitionend", OTransition: "oTransitionEnd otransitionend", transition: "transitionend" }, i = Object.keys(t).find((t => void 0 !== e.style[t])); return !!M(i) && t[i] })(); function B(e, t) { setTimeout((() => { try { e.hidden = !0, e.offsetHeight, e.hidden = !1 } catch (e) { } }), t) } const R = { isIE: Boolean(window.document.documentMode), isEdge: window.navigator.userAgent.includes("Edge"), isWebkit: "WebkitAppearance" in document.documentElement.style && !/Edge/.test(navigator.userAgent), isIPhone: /(iPhone|iPod)/gi.test(navigator.platform), isIos: "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1 || /(iPad|iPhone|iPod)/gi.test(navigator.platform) }; function W(e, t) { return t.split(".").reduce(((e, t) => e && e[t]), e) } function Y(e = {}, ...t) { if (!t.length) return e; const i = t.shift(); return A(i) ? (Object.keys(i).forEach((t => { A(i[t]) ? (Object.keys(e).includes(t) || Object.assign(e, { [t]: {} }), Y(e[t], i[t])) : Object.assign(e, { [t]: i[t] }) })), Y(e, ...t)) : e } function X(e, t) { const i = e.length ? e : [e]; Array.from(i).reverse().forEach(((e, i) => { const n = i > 0 ? t.cloneNode(!0) : t, s = e.parentNode, r = e.nextSibling; n.appendChild(e), r ? s.insertBefore(n, r) : s.appendChild(n) })) } function V(e, t) { z(e) && !H(t) && Object.entries(t).filter((([, e]) => !k(e))).forEach((([t, i]) => e.setAttribute(t, i))) } function G(e, t, i) { const n = document.createElement(e); return A(t) && V(n, t), M(i) && (n.innerText = i), n } function U(e, t, i, n) { z(t) && t.appendChild(G(e, i, n)) } function Q(e) { O(e) || L(e) ? Array.from(e).forEach(Q) : z(e) && z(e.parentNode) && e.parentNode.removeChild(e) } function K(e) { if (!z(e)) return; let { length: t } = e.childNodes; for (; t > 0;)e.removeChild(e.lastChild), t -= 1 } function Z(e, t) { return z(t) && z(t.parentNode) && z(e) ? (t.parentNode.replaceChild(e, t), e) : null } function J(e, t) { if (!M(e) || H(e)) return {}; const i = {}, n = Y({}, t); return e.split(",").forEach((e => { const t = e.trim(), s = t.replace(".", ""), r = t.replace(/[[\]]/g, "").split("="), [o] = r, a = r.length > 1 ? r[1].replace(/["']/g, "") : ""; switch (t.charAt(0)) { case ".": M(n.class) ? i.class = `${n.class} ${s}` : i.class = s; break; case "#": i.id = t.replace("#", ""); break; case "[": i[o] = a } })), Y(n, i) } function ee(e, t) { if (!z(e)) return; let i = t; P(i) || (i = !e.hidden), e.hidden = i } function te(e, t, i) { if (O(e)) return Array.from(e).map((e => te(e, t, i))); if (z(e)) { let n = "toggle"; return void 0 !== i && (n = i ? "add" : "remove"), e.classList[n](t), e.classList.contains(t) } return !1 } function ie(e, t) { return z(e) && e.classList.contains(t) } function ne(e, t) { const { prototype: i } = Element; return (i.matches || i.webkitMatchesSelector || i.mozMatchesSelector || i.msMatchesSelector || function () { return Array.from(document.querySelectorAll(t)).includes(this) }).call(e, t) } function se(e) { return this.elements.container.querySelectorAll(e) } function re(e) { return this.elements.container.querySelector(e) } function oe(e = null, t = !1) { z(e) && (e.focus({ preventScroll: !0 }), t && te(e, this.config.classNames.tabFocus)) } const ae = { "audio/ogg": "vorbis", "audio/wav": "1", "video/webm": "vp8, vorbis", "video/mp4": "avc1.42E01E, mp4a.40.2", "video/ogg": "theora" }, le = { audio: "canPlayType" in document.createElement("audio"), video: "canPlayType" in document.createElement("video"), check(e, t, i) { const n = R.isIPhone && i && le.playsinline, s = le[e] || "html5" !== t; return { api: s, ui: s && le.rangeInput && ("video" !== e || !R.isIPhone || n) } }, pip: !(R.isIPhone || !I(G("video").webkitSetPresentationMode) && (!document.pictureInPictureEnabled || G("video").disablePictureInPicture)), airplay: I(window.WebKitPlaybackTargetAvailabilityEvent), playsinline: "playsInline" in document.createElement("video"), mime(e) { if (H(e)) return !1; const [t] = e.split("/"); let i = e; if (!this.isHTML5 || t !== this.type) return !1; Object.keys(ae).includes(i) && (i += `; codecs="${ae[e]}"`); try { return Boolean(i && this.media.canPlayType(i).replace(/no/, "")) } catch (e) { return !1 } }, textTracks: "textTracks" in document.createElement("video"), rangeInput: (() => { const e = document.createElement("input"); return e.type = "range", "range" === e.type })(), touch: "ontouchstart" in document.documentElement, transitions: !1 !== q, reducedMotion: "matchMedia" in window && window.matchMedia("(prefers-reduced-motion)").matches }, ce = (() => { let e = !1; try { const t = Object.defineProperty({}, "passive", { get: () => (e = !0, null) }); window.addEventListener("test", null, t), window.removeEventListener("test", null, t) } catch (e) { } return e })(); function de(e, t, i, n = !1, s = !0, r = !1) { if (!e || !("addEventListener" in e) || H(t) || !I(i)) return; const o = t.split(" "); let a = r; ce && (a = { passive: s, capture: r }), o.forEach((t => { this && this.eventListeners && n && this.eventListeners.push({ element: e, type: t, callback: i, options: a }), e[n ? "addEventListener" : "removeEventListener"](t, i, a) })) } function ue(e, t = "", i, n = !0, s = !1) { de.call(this, e, t, i, !0, n, s) } function he(e, t = "", i, n = !0, s = !1) { de.call(this, e, t, i, !1, n, s) } function pe(e, t = "", i, n = !0, s = !1) { const r = (...o) => { he(e, t, r, n, s), i.apply(this, o) }; de.call(this, e, t, r, !0, n, s) } function fe(e, t = "", i = !1, n = {}) { if (!z(e) || H(t)) return; const s = new CustomEvent(t, { bubbles: i, detail: { ...n, plyr: this } }); e.dispatchEvent(s) } function me() { this && this.eventListeners && (this.eventListeners.forEach((e => { const { element: t, type: i, callback: n, options: s } = e; t.removeEventListener(i, n, s) })), this.eventListeners = []) } function ge() { return new Promise((e => this.ready ? setTimeout(e, 0) : ue.call(this, this.elements.container, "ready", e))).then((() => { })) } function ve(e) { (e => b(e, Promise) && T(e.then))(e) && e.then(null, (() => { })) } function ye(e) { return L(e) ? e.filter(((t, i) => e.indexOf(t) === i)) : e } function be(e, t) { return L(e) && e.length ? e.reduce(((e, i) => Math.abs(i - t) < Math.abs(e - t) ? i : e)) : null } function we(e) { return !(!window || !window.CSS) && window.CSS.supports(e) } const xe = [[1, 1], [4, 3], [3, 4], [5, 4], [4, 5], [3, 2], [2, 3], [16, 10], [10, 16], [16, 9], [9, 16], [21, 9], [9, 21], [32, 9], [9, 32]].reduce(((e, [t, i]) => ({ ...e, [t / i]: [t, i] })), {}); function _e(e) { return !!(L(e) || M(e) && e.includes(":")) && (L(e) ? e : e.split(":")).map(Number).every($) } function Te(e) { if (!L(e) || !e.every($)) return null; const [t, i] = e, n = (e, t) => 0 === t ? e : n(t, e % t), s = n(t, i); return [t / s, i / s] } function Ee(e) { const t = e => _e(e) ? e.split(":").map(Number) : null; let i = t(e); if (null === i && (i = t(this.config.ratio)), null === i && !H(this.embed) && L(this.embed.ratio) && ({ ratio: i } = this.embed), null === i && this.isHTML5) { const { videoWidth: e, videoHeight: t } = this.media; i = [e, t] } return Te(i) } function Se(e) { if (!this.isVideo) return {}; const { wrapper: t } = this.elements, i = Ee.call(this, e); if (!L(i)) return {}; const [n, s] = Te(i), r = 100 / n * s; if (we(`aspect-ratio: ${n}/${s}`) ? t.style.aspectRatio = `${n}/${s}` : t.style.paddingBottom = `${r}%`, this.isVimeo && !this.config.vimeo.premium && this.supported.ui) { const e = 100 / this.media.offsetWidth * parseInt(window.getComputedStyle(this.media).paddingBottom, 10), i = (e - r) / (e / 50); this.fullscreen.active ? t.style.paddingBottom = null : this.media.style.transform = `translateY(-${i}%)` } else this.isHTML5 && t.classList.add(this.config.classNames.videoFixedRatio); return { padding: r, ratio: i } } function Ce(e, t, i = .05) { const n = e / t, s = be(Object.keys(xe), n); return Math.abs(s - n) <= i ? xe[s] : [e, t] } const ke = { getSources() { return this.isHTML5 ? Array.from(this.media.querySelectorAll("source")).filter((e => { const t = e.getAttribute("type"); return !!H(t) || le.mime.call(this, t) })) : [] }, getQualityOptions() { return this.config.quality.forced ? this.config.quality.options : ke.getSources.call(this).map((e => Number(e.getAttribute("size")))).filter(Boolean) }, setup() { if (!this.isHTML5) return; const e = this; e.options.speed = e.config.speed.options, H(this.config.ratio) || Se.call(e), Object.defineProperty(e.media, "quality", { get() { const t = ke.getSources.call(e).find((t => t.getAttribute("src") === e.source)); return t && Number(t.getAttribute("size")) }, set(t) { if (e.quality !== t) { if (e.config.quality.forced && I(e.config.quality.onChange)) e.config.quality.onChange(t); else { const i = ke.getSources.call(e).find((e => Number(e.getAttribute("size")) === t)); if (!i) return; const { currentTime: n, paused: s, preload: r, readyState: o, playbackRate: a } = e.media; e.media.src = i.getAttribute("src"), ("none" !== r || o) && (e.once("loadedmetadata", (() => { e.speed = a, e.currentTime = n, s || ve(e.play()) })), e.media.load()) } fe.call(e, e.media, "qualitychange", !1, { quality: t }) } } }) }, cancelRequests() { this.isHTML5 && (Q(ke.getSources.call(this)), this.media.setAttribute("src", this.config.blankVideo), this.media.load(), this.debug.log("Cancelled network requests")) } }; function Ae(e, ...t) { return H(e) ? e : e.toString().replace(/{(\d+)}/g, ((e, i) => t[i].toString())) } const $e = (e = "", t = "", i = "") => e.replace(new RegExp(t.toString().replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1"), "g"), i.toString()), Me = (e = "") => e.toString().replace(/\w\S*/g, (e => e.charAt(0).toUpperCase() + e.slice(1).toLowerCase())); function Pe(e) { const t = document.createElement("div"); return t.appendChild(e), t.innerHTML } const Ie = { pip: "PIP", airplay: "AirPlay", html5: "HTML5", vimeo: "Vimeo", youtube: "YouTube" }, Le = { get(e = "", t = {}) { if (H(e) || H(t)) return ""; let i = W(t.i18n, e); if (H(i)) return Object.keys(Ie).includes(e) ? Ie[e] : ""; const n = { "{seektime}": t.seekTime, "{title}": t.title }; return Object.entries(n).forEach((([e, t]) => { i = $e(i, e, t) })), i } }; class Oe { constructor(t) { e(this, "get", (e => { if (!Oe.supported || !this.enabled) return null; const t = window.localStorage.getItem(this.key); if (H(t)) return null; const i = JSON.parse(t); return M(e) && e.length ? i[e] : i })), e(this, "set", (e => { if (!Oe.supported || !this.enabled) return; if (!A(e)) return; let t = this.get(); H(t) && (t = {}), Y(t, e); try { window.localStorage.setItem(this.key, JSON.stringify(t)) } catch (e) { } })), this.enabled = t.config.storage.enabled, this.key = t.config.storage.key } static get supported() { try { if (!("localStorage" in window)) return !1; const e = "___test"; return window.localStorage.setItem(e, e), window.localStorage.removeItem(e), !0 } catch (e) { return !1 } } } function ze(e, t = "text") { return new Promise(((i, n) => { try { const n = new XMLHttpRequest; if (!("withCredentials" in n)) return; n.addEventListener("load", (() => { if ("text" === t) try { i(JSON.parse(n.responseText)) } catch (e) { i(n.responseText) } else i(n.response) })), n.addEventListener("error", (() => { throw new Error(n.status) })), n.open("GET", e, !0), n.responseType = t, n.send() } catch (e) { n(e) } })) } function De(e, t) { if (!M(e)) return; const i = M(t); let n = !1; const s = () => null !== document.getElementById(t), r = (e, t) => { e.innerHTML = t, i && s() || document.body.insertAdjacentElement("afterbegin", e) }; if (!i || !s()) { const s = Oe.supported, o = document.createElement("div"); if (o.setAttribute("hidden", ""), i && o.setAttribute("id", t), s) { const e = window.localStorage.getItem(`cache-${t}`); if (n = null !== e, n) { const t = JSON.parse(e); r(o, t.content) } } ze(e).then((e => { if (!H(e)) { if (s) try { window.localStorage.setItem(`cache-${t}`, JSON.stringify({ content: e })) } catch (e) { } r(o, e) } })).catch((() => { })) } } const Ne = e => Math.trunc(e / 60 / 60 % 60, 10); function je(e = 0, t = !1, i = !1) { if (!$(e)) return je(void 0, t, i); const n = e => `0${e}`.slice(-2); let s = Ne(e); const r = (o = e, Math.trunc(o / 60 % 60, 10)); var o; const a = (e => Math.trunc(e % 60, 10))(e); return s = t || s > 0 ? `${s}:` : "", `${i && e > 0 ? "-" : ""}${s}${n(r)}:${n(a)}` } const Fe = { getIconUrl() { const e = new URL(this.config.iconUrl, window.location), t = window.location.host ? window.location.host : window.top.location.host, i = e.host !== t || R.isIE && !window.svg4everybody; return { url: this.config.iconUrl, cors: i } }, findElements() { try { return this.elements.controls = re.call(this, this.config.selectors.controls.wrapper), this.elements.buttons = { play: se.call(this, this.config.selectors.buttons.play), pause: re.call(this, this.config.selectors.buttons.pause), restart: re.call(this, this.config.selectors.buttons.restart), rewind: re.call(this, this.config.selectors.buttons.rewind), fastForward: re.call(this, this.config.selectors.buttons.fastForward), mute: re.call(this, this.config.selectors.buttons.mute), pip: re.call(this, this.config.selectors.buttons.pip), airplay: re.call(this, this.config.selectors.buttons.airplay), settings: re.call(this, this.config.selectors.buttons.settings), captions: re.call(this, this.config.selectors.buttons.captions), fullscreen: re.call(this, this.config.selectors.buttons.fullscreen) }, this.elements.progress = re.call(this, this.config.selectors.progress), this.elements.inputs = { seek: re.call(this, this.config.selectors.inputs.seek), volume: re.call(this, this.config.selectors.inputs.volume) }, this.elements.display = { buffer: re.call(this, this.config.selectors.display.buffer), currentTime: re.call(this, this.config.selectors.display.currentTime), duration: re.call(this, this.config.selectors.display.duration) }, z(this.elements.progress) && (this.elements.display.seekTooltip = this.elements.progress.querySelector(`.${this.config.classNames.tooltip}`)), !0 } catch (e) { return this.debug.warn("It looks like there is a problem with your custom controls HTML", e), this.toggleNativeControls(!0), !1 } }, createIcon(e, t) { const i = "http://www.w3.org/2000/svg", n = Fe.getIconUrl.call(this), s = `${n.cors ? "" : n.url}#${this.config.iconPrefix}`, r = document.createElementNS(i, "svg"); V(r, Y(t, { "aria-hidden": "true", focusable: "false" })); const o = document.createElementNS(i, "use"), a = `${s}-${e}`; return "href" in o && o.setAttributeNS("http://www.w3.org/1999/xlink", "href", a), o.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", a), r.appendChild(o), r }, createLabel(e, t = {}) { const i = Le.get(e, this.config); return G("span", { ...t, class: [t.class, this.config.classNames.hidden].filter(Boolean).join(" ") }, i) }, createBadge(e) { if (H(e)) return null; const t = G("span", { class: this.config.classNames.menu.value }); return t.appendChild(G("span", { class: this.config.classNames.menu.badge }, e)), t }, createButton(e, t) { const i = Y({}, t); let n = function (e = "") { let t = e.toString(); return t = function (e = "") { let t = e.toString(); return t = $e(t, "-", " "), t = $e(t, "_", " "), t = Me(t), $e(t, " ", "") }(t), t.charAt(0).toLowerCase() + t.slice(1) }(e); const s = { element: "button", toggle: !1, label: null, icon: null, labelPressed: null, iconPressed: null }; switch (["element", "icon", "label"].forEach((e => { Object.keys(i).includes(e) && (s[e] = i[e], delete i[e]) })), "button" !== s.element || Object.keys(i).includes("type") || (i.type = "button"), Object.keys(i).includes("class") ? i.class.split(" ").some((e => e === this.config.classNames.control)) || Y(i, { class: `${i.class} ${this.config.classNames.control}` }) : i.class = this.config.classNames.control, e) { case "play": s.toggle = !0, s.label = "play", s.labelPressed = "pause", s.icon = "play", s.iconPressed = "pause"; break; case "mute": s.toggle = !0, s.label = "mute", s.labelPressed = "unmute", s.icon = "volume", s.iconPressed = "muted"; break; case "captions": s.toggle = !0, s.label = "enableCaptions", s.labelPressed = "disableCaptions", s.icon = "captions-off", s.iconPressed = "captions-on"; break; case "fullscreen": s.toggle = !0, s.label = "enterFullscreen", s.labelPressed = "exitFullscreen", s.icon = "enter-fullscreen", s.iconPressed = "exit-fullscreen"; break; case "play-large": i.class += ` ${this.config.classNames.control}--overlaid`, n = "play", s.label = "play", s.icon = "play"; break; default: H(s.label) && (s.label = n), H(s.icon) && (s.icon = e) }const r = G(s.element); return s.toggle ? (r.appendChild(Fe.createIcon.call(this, s.iconPressed, { class: "icon--pressed" })), r.appendChild(Fe.createIcon.call(this, s.icon, { class: "icon--not-pressed" })), r.appendChild(Fe.createLabel.call(this, s.labelPressed, { class: "label--pressed" })), r.appendChild(Fe.createLabel.call(this, s.label, { class: "label--not-pressed" }))) : (r.appendChild(Fe.createIcon.call(this, s.icon)), r.appendChild(Fe.createLabel.call(this, s.label))), Y(i, J(this.config.selectors.buttons[n], i)), V(r, i), "play" === n ? (L(this.elements.buttons[n]) || (this.elements.buttons[n] = []), this.elements.buttons[n].push(r)) : this.elements.buttons[n] = r, r }, createRange(e, t) { const i = G("input", Y(J(this.config.selectors.inputs[e]), { type: "range", min: 0, max: 100, step: .01, value: 0, autocomplete: "off", role: "slider", "aria-label": Le.get(e, this.config), "aria-valuemin": 0, "aria-valuemax": 100, "aria-valuenow": 0 }, t)); return this.elements.inputs[e] = i, Fe.updateRangeFill.call(this, i), v.setup(i), i }, createProgress(e, t) { const i = G("progress", Y(J(this.config.selectors.display[e]), { min: 0, max: 100, value: 0, role: "progressbar", "aria-hidden": !0 }, t)); if ("volume" !== e) { i.appendChild(G("span", null, "0")); const t = { played: "played", buffer: "buffered" }[e], n = t ? Le.get(t, this.config) : ""; i.innerText = `% ${n.toLowerCase()}` } return this.elements.display[e] = i, i }, createTime(e, t) { const i = J(this.config.selectors.display[e], t), n = G("div", Y(i, { class: `${i.class ? i.class : ""} ${this.config.classNames.display.time} `.trim(), "aria-label": Le.get(e, this.config) }), "00:00"); return this.elements.display[e] = n, n }, bindMenuItemShortcuts(e, t) { ue.call(this, e, "keydown keyup", (i => { if (!["Space", "ArrowUp", "ArrowDown", "ArrowRight"].includes(i.key)) return; if (i.preventDefault(), i.stopPropagation(), "keydown" === i.type) return; const n = ne(e, '[role="menuitemradio"]'); if (!n && ["Space", "ArrowRight"].includes(i.key)) Fe.showMenuPanel.call(this, t, !0); else { let t; "Space" !== i.key && ("ArrowDown" === i.key || n && "ArrowRight" === i.key ? (t = e.nextElementSibling, z(t) || (t = e.parentNode.firstElementChild)) : (t = e.previousElementSibling, z(t) || (t = e.parentNode.lastElementChild)), oe.call(this, t, !0)) } }), !1), ue.call(this, e, "keyup", (e => { "Return" === e.key && Fe.focusFirstMenuItem.call(this, null, !0) })) }, createMenuItem({ value: e, list: t, type: i, title: n, badge: s = null, checked: r = !1 }) { const o = J(this.config.selectors.inputs[i]), a = G("button", Y(o, { type: "button", role: "menuitemradio", class: `${this.config.classNames.control} ${o.class ? o.class : ""}`.trim(), "aria-checked": r, value: e })), l = G("span"); l.innerHTML = n, z(s) && l.appendChild(s), a.appendChild(l), Object.defineProperty(a, "checked", { enumerable: !0, get: () => "true" === a.getAttribute("aria-checked"), set(e) { e && Array.from(a.parentNode.children).filter((e => ne(e, '[role="menuitemradio"]'))).forEach((e => e.setAttribute("aria-checked", "false"))), a.setAttribute("aria-checked", e ? "true" : "false") } }), this.listeners.bind(a, "click keyup", (t => { if (!N(t) || "Space" === t.key) { switch (t.preventDefault(), t.stopPropagation(), a.checked = !0, i) { case "language": this.currentTrack = Number(e); break; case "quality": this.quality = e; break; case "speed": this.speed = parseFloat(e) }Fe.showMenuPanel.call(this, "home", N(t)) } }), i, !1), Fe.bindMenuItemShortcuts.call(this, a, i), t.appendChild(a) }, formatTime(e = 0, t = !1) { return $(e) ? je(e, Ne(this.duration) > 0, t) : e }, updateTimeDisplay(e = null, t = 0, i = !1) { z(e) && $(t) && (e.innerText = Fe.formatTime(t, i)) }, updateVolume() { this.supported.ui && (z(this.elements.inputs.volume) && Fe.setRange.call(this, this.elements.inputs.volume, this.muted ? 0 : this.volume), z(this.elements.buttons.mute) && (this.elements.buttons.mute.pressed = this.muted || 0 === this.volume)) }, setRange(e, t = 0) { z(e) && (e.value = t, Fe.updateRangeFill.call(this, e)) }, updateProgress(e) { if (!this.supported.ui || !D(e)) return; let t = 0; const i = (e, t) => { const i = $(t) ? t : 0, n = z(e) ? e : this.elements.display.buffer; if (z(n)) { n.value = i; const e = n.getElementsByTagName("span")[0]; z(e) && (e.childNodes[0].nodeValue = i) } }; if (e) switch (e.type) { case "timeupdate": case "seeking": case "seeked": n = this.currentTime, s = this.duration, t = 0 === n || 0 === s || Number.isNaN(n) || Number.isNaN(s) ? 0 : (n / s * 100).toFixed(2), "timeupdate" === e.type && Fe.setRange.call(this, this.elements.inputs.seek, t); break; case "playing": case "progress": i(this.elements.display.buffer, 100 * this.buffered) }var n, s }, updateRangeFill(e) { const t = D(e) ? e.target : e; if (z(t) && "range" === t.getAttribute("type")) { if (ne(t, this.config.selectors.inputs.seek)) { t.setAttribute("aria-valuenow", this.currentTime); const e = Fe.formatTime(this.currentTime), i = Fe.formatTime(this.duration), n = Le.get("seekLabel", this.config); t.setAttribute("aria-valuetext", n.replace("{currentTime}", e).replace("{duration}", i)) } else if (ne(t, this.config.selectors.inputs.volume)) { const e = 100 * t.value; t.setAttribute("aria-valuenow", e), t.setAttribute("aria-valuetext", `${e.toFixed(1)}%`) } else t.setAttribute("aria-valuenow", t.value); R.isWebkit && t.style.setProperty("--value", t.value / t.max * 100 + "%") } }, updateSeekTooltip(e) { var t, i; if (!this.config.tooltips.seek || !z(this.elements.inputs.seek) || !z(this.elements.display.seekTooltip) || 0 === this.duration) return; const n = this.elements.display.seekTooltip, s = `${this.config.classNames.tooltip}--visible`, r = e => te(n, s, e); if (this.touch) return void r(!1); let o = 0; const a = this.elements.progress.getBoundingClientRect(); if (D(e)) o = 100 / a.width * (e.pageX - a.left); else { if (!ie(n, s)) return; o = parseFloat(n.style.left, 10) } o < 0 ? o = 0 : o > 100 && (o = 100); const l = this.duration / 100 * o; n.innerText = Fe.formatTime(l); const c = null === (t = this.config.markers) || void 0 === t || null === (i = t.points) || void 0 === i ? void 0 : i.find((({ time: e }) => e === Math.round(l))); c && n.insertAdjacentHTML("afterbegin", `${c.label}<br>`), n.style.left = `${o}%`, D(e) && ["mouseenter", "mouseleave"].includes(e.type) && r("mouseenter" === e.type) }, timeUpdate(e) { const t = !z(this.elements.display.duration) && this.config.invertTime; Fe.updateTimeDisplay.call(this, this.elements.display.currentTime, t ? this.duration - this.currentTime : this.currentTime, t), e && "timeupdate" === e.type && this.media.seeking || Fe.updateProgress.call(this, e) }, durationUpdate() { if (!this.supported.ui || !this.config.invertTime && this.currentTime) return; if (this.duration >= 2 ** 32) return ee(this.elements.display.currentTime, !0), void ee(this.elements.progress, !0); z(this.elements.inputs.seek) && this.elements.inputs.seek.setAttribute("aria-valuemax", this.duration); const e = z(this.elements.display.duration); !e && this.config.displayDuration && this.paused && Fe.updateTimeDisplay.call(this, this.elements.display.currentTime, this.duration), e && Fe.updateTimeDisplay.call(this, this.elements.display.duration, this.duration), this.config.markers.enabled && Fe.setMarkers.call(this), Fe.updateSeekTooltip.call(this) }, toggleMenuButton(e, t) { ee(this.elements.settings.buttons[e], !t) }, updateSetting(e, t, i) { const n = this.elements.settings.panels[e]; let s = null, r = t; if ("captions" === e) s = this.currentTrack; else { if (s = H(i) ? this[e] : i, H(s) && (s = this.config[e].default), !H(this.options[e]) && !this.options[e].includes(s)) return void this.debug.warn(`Unsupported value of '${s}' for ${e}`); if (!this.config[e].options.includes(s)) return void this.debug.warn(`Disabled value of '${s}' for ${e}`) } if (z(r) || (r = n && n.querySelector('[role="menu"]')), !z(r)) return; this.elements.settings.buttons[e].querySelector(`.${this.config.classNames.menu.value}`).innerHTML = Fe.getLabel.call(this, e, s); const o = r && r.querySelector(`[value="${s}"]`); z(o) && (o.checked = !0) }, getLabel(e, t) { switch (e) { case "speed": return 1 === t ? Le.get("normal", this.config) : `${t}&times;`; case "quality": if ($(t)) { const e = Le.get(`qualityLabel.${t}`, this.config); return e.length ? e : `${t}p` } return Me(t); case "captions": return Be.getLabel.call(this); default: return null } }, setQualityMenu(e) { if (!z(this.elements.settings.panels.quality)) return; const t = "quality", i = this.elements.settings.panels.quality.querySelector('[role="menu"]'); L(e) && (this.options.quality = ye(e).filter((e => this.config.quality.options.includes(e)))); const n = !H(this.options.quality) && this.options.quality.length > 1; if (Fe.toggleMenuButton.call(this, t, n), K(i), Fe.checkMenu.call(this), !n) return; const s = e => { const t = Le.get(`qualityBadge.${e}`, this.config); return t.length ? Fe.createBadge.call(this, t) : null }; this.options.quality.sort(((e, t) => { const i = this.config.quality.options; return i.indexOf(e) > i.indexOf(t) ? 1 : -1 })).forEach((e => { Fe.createMenuItem.call(this, { value: e, list: i, type: t, title: Fe.getLabel.call(this, "quality", e), badge: s(e) }) })), Fe.updateSetting.call(this, t, i) }, setCaptionsMenu() { if (!z(this.elements.settings.panels.captions)) return; const e = "captions", t = this.elements.settings.panels.captions.querySelector('[role="menu"]'), i = Be.getTracks.call(this), n = Boolean(i.length); if (Fe.toggleMenuButton.call(this, e, n), K(t), Fe.checkMenu.call(this), !n) return; const s = i.map(((e, i) => ({ value: i, checked: this.captions.toggled && this.currentTrack === i, title: Be.getLabel.call(this, e), badge: e.language && Fe.createBadge.call(this, e.language.toUpperCase()), list: t, type: "language" }))); s.unshift({ value: -1, checked: !this.captions.toggled, title: Le.get("disabled", this.config), list: t, type: "language" }), s.forEach(Fe.createMenuItem.bind(this)), Fe.updateSetting.call(this, e, t) }, setSpeedMenu() { if (!z(this.elements.settings.panels.speed)) return; const e = "speed", t = this.elements.settings.panels.speed.querySelector('[role="menu"]'); this.options.speed = this.options.speed.filter((e => e >= this.minimumSpeed && e <= this.maximumSpeed)); const i = !H(this.options.speed) && this.options.speed.length > 1; Fe.toggleMenuButton.call(this, e, i), K(t), Fe.checkMenu.call(this), i && (this.options.speed.forEach((i => { Fe.createMenuItem.call(this, { value: i, list: t, type: e, title: Fe.getLabel.call(this, "speed", i) }) })), Fe.updateSetting.call(this, e, t)) }, checkMenu() { const { buttons: e } = this.elements.settings, t = !H(e) && Object.values(e).some((e => !e.hidden)); ee(this.elements.settings.menu, !t) }, focusFirstMenuItem(e, t = !1) { if (this.elements.settings.popup.hidden) return; let i = e; z(i) || (i = Object.values(this.elements.settings.panels).find((e => !e.hidden))); const n = i.querySelector('[role^="menuitem"]'); oe.call(this, n, t) }, toggleMenu(e) { const { popup: t } = this.elements.settings, i = this.elements.buttons.settings; if (!z(t) || !z(i)) return; const { hidden: n } = t; let s = n; if (P(e)) s = e; else if (N(e) && "Escape" === e.key) s = !1; else if (D(e)) { const n = I(e.composedPath) ? e.composedPath()[0] : e.target, r = t.contains(n); if (r || !r && e.target !== i && s) return } i.setAttribute("aria-expanded", s), ee(t, !s), te(this.elements.container, this.config.classNames.menu.open, s), s && N(e) ? Fe.focusFirstMenuItem.call(this, null, !0) : s || n || oe.call(this, i, N(e)) }, getMenuSize(e) { const t = e.cloneNode(!0); t.style.position = "absolute", t.style.opacity = 0, t.removeAttribute("hidden"), e.parentNode.appendChild(t); const i = t.scrollWidth, n = t.scrollHeight; return Q(t), { width: i, height: n } }, showMenuPanel(e = "", t = !1) { const i = this.elements.container.querySelector(`#plyr-settings-${this.id}-${e}`); if (!z(i)) return; const n = i.parentNode, s = Array.from(n.children).find((e => !e.hidden)); if (le.transitions && !le.reducedMotion) { n.style.width = `${s.scrollWidth}px`, n.style.height = `${s.scrollHeight}px`; const e = Fe.getMenuSize.call(this, i), t = e => { e.target === n && ["width", "height"].includes(e.propertyName) && (n.style.width = "", n.style.height = "", he.call(this, n, q, t)) }; ue.call(this, n, q, t), n.style.width = `${e.width}px`, n.style.height = `${e.height}px` } ee(s, !0), ee(i, !1), Fe.focusFirstMenuItem.call(this, i, t) }, setDownloadUrl() { const e = this.elements.buttons.download; z(e) && e.setAttribute("href", this.download) }, create(e) { const { bindMenuItemShortcuts: t, createButton: i, createProgress: n, createRange: s, createTime: r, setQualityMenu: o, setSpeedMenu: a, showMenuPanel: l } = Fe; this.elements.controls = null, L(this.config.controls) && this.config.controls.includes("play-large") && this.elements.container.appendChild(i.call(this, "play-large")); const c = G("div", J(this.config.selectors.controls.wrapper)); this.elements.controls = c; const d = { class: "plyr__controls__item" }; return ye(L(this.config.controls) ? this.config.controls : []).forEach((o => { if ("restart" === o && c.appendChild(i.call(this, "restart", d)), "rewind" === o && c.appendChild(i.call(this, "rewind", d)), "play" === o && c.appendChild(i.call(this, "play", d)), "fast-forward" === o && c.appendChild(i.call(this, "fast-forward", d)), "progress" === o) { const t = G("div", { class: `${d.class} plyr__progress__container` }), i = G("div", J(this.config.selectors.progress)); if (i.appendChild(s.call(this, "seek", { id: `plyr-seek-${e.id}` })), i.appendChild(n.call(this, "buffer")), this.config.tooltips.seek) { const e = G("span", { class: this.config.classNames.tooltip }, "00:00"); i.appendChild(e), this.elements.display.seekTooltip = e } this.elements.progress = i, t.appendChild(this.elements.progress), c.appendChild(t) } if ("current-time" === o && c.appendChild(r.call(this, "currentTime", d)), "duration" === o && c.appendChild(r.call(this, "duration", d)), "mute" === o || "volume" === o) { let { volume: t } = this.elements; if (z(t) && c.contains(t) || (t = G("div", Y({}, d, { class: `${d.class} plyr__volume`.trim() })), this.elements.volume = t, c.appendChild(t)), "mute" === o && t.appendChild(i.call(this, "mute")), "volume" === o && !R.isIos) { const i = { max: 1, step: .05, value: this.config.volume }; t.appendChild(s.call(this, "volume", Y(i, { id: `plyr-volume-${e.id}` }))) } } if ("captions" === o && c.appendChild(i.call(this, "captions", d)), "settings" === o && !H(this.config.settings)) { const n = G("div", Y({}, d, { class: `${d.class} plyr__menu`.trim(), hidden: "" })); n.appendChild(i.call(this, "settings", { "aria-haspopup": !0, "aria-controls": `plyr-settings-${e.id}`, "aria-expanded": !1 })); const s = G("div", { class: "plyr__menu__container", id: `plyr-settings-${e.id}`, hidden: "" }), r = G("div"), o = G("div", { id: `plyr-settings-${e.id}-home` }), a = G("div", { role: "menu" }); o.appendChild(a), r.appendChild(o), this.elements.settings.panels.home = o, this.config.settings.forEach((i => { const n = G("button", Y(J(this.config.selectors.buttons.settings), { type: "button", class: `${this.config.classNames.control} ${this.config.classNames.control}--forward`, role: "menuitem", "aria-haspopup": !0, hidden: "" })); t.call(this, n, i), ue.call(this, n, "click", (() => { l.call(this, i, !1) })); const s = G("span", null, Le.get(i, this.config)), o = G("span", { class: this.config.classNames.menu.value }); o.innerHTML = e[i], s.appendChild(o), n.appendChild(s), a.appendChild(n); const c = G("div", { id: `plyr-settings-${e.id}-${i}`, hidden: "" }), d = G("button", { type: "button", class: `${this.config.classNames.control} ${this.config.classNames.control}--back` }); d.appendChild(G("span", { "aria-hidden": !0 }, Le.get(i, this.config))), d.appendChild(G("span", { class: this.config.classNames.hidden }, Le.get("menuBack", this.config))), ue.call(this, c, "keydown", (e => { "ArrowLeft" === e.key && (e.preventDefault(), e.stopPropagation(), l.call(this, "home", !0)) }), !1), ue.call(this, d, "click", (() => { l.call(this, "home", !1) })), c.appendChild(d), c.appendChild(G("div", { role: "menu" })), r.appendChild(c), this.elements.settings.buttons[i] = n, this.elements.settings.panels[i] = c })), s.appendChild(r), n.appendChild(s), c.appendChild(n), this.elements.settings.popup = s, this.elements.settings.menu = n } if ("pip" === o && le.pip && c.appendChild(i.call(this, "pip", d)), "airplay" === o && le.airplay && c.appendChild(i.call(this, "airplay", d)), "download" === o) { const e = Y({}, d, { element: "a", href: this.download, target: "_blank" }); this.isHTML5 && (e.download = ""); const { download: t } = this.config.urls; !F(t) && this.isEmbed && Y(e, { icon: `logo-${this.provider}`, label: this.provider }), c.appendChild(i.call(this, "download", e)) } "fullscreen" === o && c.appendChild(i.call(this, "fullscreen", d)) })), this.isHTML5 && o.call(this, ke.getQualityOptions.call(this)), a.call(this), c }, inject() { if (this.config.loadSprite) { const e = Fe.getIconUrl.call(this); e.cors && De(e.url, "sprite-plyr") } this.id = Math.floor(1e4 * Math.random()); let e = null; this.elements.controls = null; const t = { id: this.id, seektime: this.config.seekTime, title: this.config.title }; let i, n = !0; if (I(this.config.controls) && (this.config.controls = this.config.controls.call(this, t)), this.config.controls || (this.config.controls = []), z(this.config.controls) || M(this.config.controls) ? e = this.config.controls : (e = Fe.create.call(this, { id: this.id, seektime: this.config.seekTime, speed: this.speed, quality: this.quality, captions: Be.getLabel.call(this) }), n = !1), n && M(this.config.controls) && (e = (e => { let i = e; return Object.entries(t).forEach((([e, t]) => { i = $e(i, `{${e}}`, t) })), i })(e)), M(this.config.selectors.controls.container) && (i = document.querySelector(this.config.selectors.controls.container)), z(i) || (i = this.elements.container), i[z(e) ? "insertAdjacentElement" : "insertAdjacentHTML"]("afterbegin", e), z(this.elements.controls) || Fe.findElements.call(this), !H(this.elements.buttons)) { const e = e => { const t = this.config.classNames.controlPressed; Object.defineProperty(e, "pressed", { enumerable: !0, get: () => ie(e, t), set(i = !1) { te(e, t, i) } }) }; Object.values(this.elements.buttons).filter(Boolean).forEach((t => { L(t) || O(t) ? Array.from(t).filter(Boolean).forEach(e) : e(t) })) } if (R.isEdge && B(i), this.config.tooltips.controls) { const { classNames: e, selectors: t } = this.config, i = `${t.controls.wrapper} ${t.labels} .${e.hidden}`, n = se.call(this, i); Array.from(n).forEach((e => { te(e, this.config.classNames.hidden, !1), te(e, this.config.classNames.tooltip, !0) })) } }, setMediaMetadata() { try { "mediaSession" in navigator && (navigator.mediaSession.metadata = new window.MediaMetadata({ title: this.config.mediaMetadata.title, artist: this.config.mediaMetadata.artist, album: this.config.mediaMetadata.album, artwork: this.config.mediaMetadata.artwork })) } catch (e) { } }, setMarkers() { var e, t; if (!this.duration || this.elements.markers) return; const i = null === (e = this.config.markers) || void 0 === e || null === (t = e.points) || void 0 === t ? void 0 : t.filter((({ time: e }) => e > 0 && e < this.duration)); if (null == i || !i.length) return; const n = document.createDocumentFragment(), s = document.createDocumentFragment(); let r = null; const o = `${this.config.classNames.tooltip}--visible`, a = e => te(r, o, e); i.forEach((e => { const t = G("span", { class: this.config.classNames.marker }, ""), i = e.time / this.duration * 100 + "%"; r && (t.addEventListener("mouseenter", (() => { e.label || (r.style.left = i, r.innerHTML = e.label, a(!0)) })), t.addEventListener("mouseleave", (() => { a(!1) }))), t.addEventListener("click", (() => { this.currentTime = e.time })), t.style.left = i, s.appendChild(t) })), n.appendChild(s), this.config.tooltips.seek || (r = G("span", { class: this.config.classNames.tooltip }, ""), n.appendChild(r)), this.elements.markers = { points: s, tip: r }, this.elements.progress.appendChild(n) } }; function He(e, t = !0) { let i = e; if (t) { const e = document.createElement("a"); e.href = i, i = e.href } try { return new URL(i) } catch (e) { return null } } function qe(e) { const t = new URLSearchParams; return A(e) && Object.entries(e).forEach((([e, i]) => { t.set(e, i) })), t } const Be = { setup() { if (!this.supported.ui) return; if (!this.isVideo || this.isYouTube || this.isHTML5 && !le.textTracks) return void (L(this.config.controls) && this.config.controls.includes("settings") && this.config.settings.includes("captions") && Fe.setCaptionsMenu.call(this)); var e, t; if (z(this.elements.captions) || (this.elements.captions = G("div", J(this.config.selectors.captions)), e = this.elements.captions, t = this.elements.wrapper, z(e) && z(t) && t.parentNode.insertBefore(e, t.nextSibling)), R.isIE && window.URL) { const e = this.media.querySelectorAll("track"); Array.from(e).forEach((e => { const t = e.getAttribute("src"), i = He(t); null !== i && i.hostname !== window.location.href.hostname && ["http:", "https:"].includes(i.protocol) && ze(t, "blob").then((t => { e.setAttribute("src", window.URL.createObjectURL(t)) })).catch((() => { Q(e) })) })) } const i = ye((navigator.languages || [navigator.language || navigator.userLanguage || "en"]).map((e => e.split("-")[0]))); let n = (this.storage.get("language") || this.config.captions.language || "auto").toLowerCase(); "auto" === n && ([n] = i); let s = this.storage.get("captions"); if (P(s) || ({ active: s } = this.config.captions), Object.assign(this.captions, { toggled: !1, active: s, language: n, languages: i }), this.isHTML5) { const e = this.config.captions.update ? "addtrack removetrack" : "removetrack"; ue.call(this, this.media.textTracks, e, Be.update.bind(this)) } setTimeout(Be.update.bind(this), 0) }, update() { const e = Be.getTracks.call(this, !0), { active: t, language: i, meta: n, currentTrackNode: s } = this.captions, r = Boolean(e.find((e => e.language === i))); this.isHTML5 && this.isVideo && e.filter((e => !n.get(e))).forEach((e => { this.debug.log("Track added", e), n.set(e, { default: "showing" === e.mode }), "showing" === e.mode && (e.mode = "hidden"), ue.call(this, e, "cuechange", (() => Be.updateCues.call(this))) })), (r && this.language !== i || !e.includes(s)) && (Be.setLanguage.call(this, i), Be.toggle.call(this, t && r)), this.elements && te(this.elements.container, this.config.classNames.captions.enabled, !H(e)), L(this.config.controls) && this.config.controls.includes("settings") && this.config.settings.includes("captions") && Fe.setCaptionsMenu.call(this) }, toggle(e, t = !0) { if (!this.supported.ui) return; const { toggled: i } = this.captions, n = this.config.classNames.captions.active, s = k(e) ? !i : e; if (s !== i) { if (t || (this.captions.active = s, this.storage.set({ captions: s })), !this.language && s && !t) { const e = Be.getTracks.call(this), t = Be.findTrack.call(this, [this.captions.language, ...this.captions.languages], !0); return this.captions.language = t.language, void Be.set.call(this, e.indexOf(t)) } this.elements.buttons.captions && (this.elements.buttons.captions.pressed = s), te(this.elements.container, n, s), this.captions.toggled = s, Fe.updateSetting.call(this, "captions"), fe.call(this, this.media, s ? "captionsenabled" : "captionsdisabled") } setTimeout((() => { s && this.captions.toggled && (this.captions.currentTrackNode.mode = "hidden") })) }, set(e, t = !0) { const i = Be.getTracks.call(this); if (-1 !== e) if ($(e)) if (e in i) { if (this.captions.currentTrack !== e) { this.captions.currentTrack = e; const n = i[e], { language: s } = n || {}; this.captions.currentTrackNode = n, Fe.updateSetting.call(this, "captions"), t || (this.captions.language = s, this.storage.set({ language: s })), this.isVimeo && this.embed.enableTextTrack(s), fe.call(this, this.media, "languagechange") } Be.toggle.call(this, !0, t), this.isHTML5 && this.isVideo && Be.updateCues.call(this) } else this.debug.warn("Track not found", e); else this.debug.warn("Invalid caption argument", e); else Be.toggle.call(this, !1, t) }, setLanguage(e, t = !0) { if (!M(e)) return void this.debug.warn("Invalid language argument", e); const i = e.toLowerCase(); this.captions.language = i; const n = Be.getTracks.call(this), s = Be.findTrack.call(this, [i]); Be.set.call(this, n.indexOf(s), t) }, getTracks(e = !1) { return Array.from((this.media || {}).textTracks || []).filter((t => !this.isHTML5 || e || this.captions.meta.has(t))).filter((e => ["captions", "subtitles"].includes(e.kind))) }, findTrack(e, t = !1) { const i = Be.getTracks.call(this), n = e => Number((this.captions.meta.get(e) || {}).default), s = Array.from(i).sort(((e, t) => n(t) - n(e))); let r; return e.every((e => (r = s.find((t => t.language === e)), !r))), r || (t ? s[0] : void 0) }, getCurrentTrack() { return Be.getTracks.call(this)[this.currentTrack] }, getLabel(e) { let t = e; return !j(t) && le.textTracks && this.captions.toggled && (t = Be.getCurrentTrack.call(this)), j(t) ? H(t.label) ? H(t.language) ? Le.get("enabled", this.config) : e.language.toUpperCase() : t.label : Le.get("disabled", this.config) }, updateCues(e) { if (!this.supported.ui) return; if (!z(this.elements.captions)) return void this.debug.warn("No captions element to render to"); if (!k(e) && !Array.isArray(e)) return void this.debug.warn("updateCues: Invalid input", e); let t = e; if (!t) { const e = Be.getCurrentTrack.call(this); t = Array.from((e || {}).activeCues || []).map((e => e.getCueAsHTML())).map(Pe) } const i = t.map((e => e.trim())).join("\n"); if (i !== this.elements.captions.innerHTML) { K(this.elements.captions); const e = G("span", J(this.config.selectors.caption)); e.innerHTML = i, this.elements.captions.appendChild(e), fe.call(this, this.media, "cuechange") } } }, Re = { enabled: !0, title: "", debug: !1, autoplay: !1, autopause: !0, playsinline: !0, seekTime: 10, volume: 1, muted: !1, duration: null, displayDuration: !0, invertTime: !0, toggleInvert: !0, ratio: null, clickToPlay: !0, hideControls: !0, resetOnEnd: !1, disableContextMenu: !0, loadSprite: !0, iconPrefix: "plyr", iconUrl: "https://cdn.plyr.io/3.7.2/plyr.svg", blankVideo: "https://cdn.plyr.io/static/blank.mp4", quality: { default: 576, options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240], forced: !1, onChange: null }, loop: { active: !1 }, speed: { selected: 1, options: [.5, .75, 1, 1.25, 1.5, 1.75, 2, 4] }, keyboard: { focused: !0, global: !1 }, tooltips: { controls: !1, seek: !0 }, captions: { active: !1, language: "auto", update: !1 }, fullscreen: { enabled: !0, fallback: !0, iosNative: !1 }, storage: { enabled: !0, key: "plyr" }, controls: ["play-large", "play", "progress", "current-time", "mute", "volume", "captions", "settings", "pip", "airplay", "fullscreen"], settings: ["captions", "quality", "speed"], i18n: { restart: "Restart", rewind: "Rewind {seektime}s", play: "Play", pause: "Pause", fastForward: "Forward {seektime}s", seek: "Seek", seekLabel: "{currentTime} of {duration}", played: "Played", buffered: "Buffered", currentTime: "Current time", duration: "Duration", volume: "Volume", mute: "Mute", unmute: "Unmute", enableCaptions: "Enable captions", disableCaptions: "Disable captions", download: "Download", enterFullscreen: "Enter fullscreen", exitFullscreen: "Exit fullscreen", frameTitle: "Player for {title}", captions: "Captions", settings: "Settings", pip: "PIP", menuBack: "Go back to previous menu", speed: "Speed", normal: "Normal", quality: "Quality", loop: "Loop", start: "Start", end: "End", all: "All", reset: "Reset", disabled: "Disabled", enabled: "Enabled", advertisement: "Ad", qualityBadge: { 2160: "4K", 1440: "HD", 1080: "HD", 720: "HD", 576: "SD", 480: "SD" } }, urls: { download: null, vimeo: { sdk: "https://player.vimeo.com/api/player.js", iframe: "https://player.vimeo.com/video/{0}?{1}", api: "https://vimeo.com/api/oembed.json?url={0}" }, youtube: { sdk: "https://www.youtube.com/iframe_api", api: "https://noembed.com/embed?url=https://www.youtube.com/watch?v={0}" }, googleIMA: { sdk: "https://imasdk.googleapis.com/js/sdkloader/ima3.js" } }, listeners: { seek: null, play: null, pause: null, restart: null, rewind: null, fastForward: null, mute: null, volume: null, captions: null, download: null, fullscreen: null, pip: null, airplay: null, speed: null, quality: null, loop: null, language: null }, events: ["ended", "progress", "stalled", "playing", "waiting", "canplay", "canplaythrough", "loadstart", "loadeddata", "loadedmetadata", "timeupdate", "volumechange", "play", "pause", "error", "seeking", "seeked", "emptied", "ratechange", "cuechange", "download", "enterfullscreen", "exitfullscreen", "captionsenabled", "captionsdisabled", "languagechange", "controlshidden", "controlsshown", "ready", "statechange", "qualitychange", "adsloaded", "adscontentpause", "adscontentresume", "adstarted", "adsmidpoint", "adscomplete", "adsallcomplete", "adsimpression", "adsclick"], selectors: { editable: "input, textarea, select, [contenteditable]", container: ".plyr", controls: { container: null, wrapper: ".plyr__controls" }, labels: "[data-plyr]", buttons: { play: '[data-plyr="play"]', pause: '[data-plyr="pause"]', restart: '[data-plyr="restart"]', rewind: '[data-plyr="rewind"]', fastForward: '[data-plyr="fast-forward"]', mute: '[data-plyr="mute"]', captions: '[data-plyr="captions"]', download: '[data-plyr="download"]', fullscreen: '[data-plyr="fullscreen"]', pip: '[data-plyr="pip"]', airplay: '[data-plyr="airplay"]', settings: '[data-plyr="settings"]', loop: '[data-plyr="loop"]' }, inputs: { seek: '[data-plyr="seek"]', volume: '[data-plyr="volume"]', speed: '[data-plyr="speed"]', language: '[data-plyr="language"]', quality: '[data-plyr="quality"]' }, display: { currentTime: ".plyr__time--current", duration: ".plyr__time--duration", buffer: ".plyr__progress__buffer", loop: ".plyr__progress__loop", volume: ".plyr__volume--display" }, progress: ".plyr__progress", captions: ".plyr__captions", caption: ".plyr__caption" }, classNames: { type: "plyr--{0}", provider: "plyr--{0}", video: "plyr__video-wrapper", embed: "plyr__video-embed", videoFixedRatio: "plyr__video-wrapper--fixed-ratio", embedContainer: "plyr__video-embed__container", poster: "plyr__poster", posterEnabled: "plyr__poster-enabled", ads: "plyr__ads", control: "plyr__control", controlPressed: "plyr__control--pressed", playing: "plyr--playing", paused: "plyr--paused", stopped: "plyr--stopped", loading: "plyr--loading", hover: "plyr--hover", tooltip: "plyr__tooltip", cues: "plyr__cues", marker: "plyr__progress__marker", hidden: "plyr__sr-only", hideControls: "plyr--hide-controls", isIos: "plyr--is-ios", isTouch: "plyr--is-touch", uiSupported: "plyr--full-ui", noTransition: "plyr--no-transition", display: { time: "plyr__time" }, menu: { value: "plyr__menu__value", badge: "plyr__badge", open: "plyr--menu-open" }, captions: { enabled: "plyr--captions-enabled", active: "plyr--captions-active" }, fullscreen: { enabled: "plyr--fullscreen-enabled", fallback: "plyr--fullscreen-fallback" }, pip: { supported: "plyr--pip-supported", active: "plyr--pip-active" }, airplay: { supported: "plyr--airplay-supported", active: "plyr--airplay-active" }, tabFocus: "plyr__tab-focus", previewThumbnails: { thumbContainer: "plyr__preview-thumb", thumbContainerShown: "plyr__preview-thumb--is-shown", imageContainer: "plyr__preview-thumb__image-container", timeContainer: "plyr__preview-thumb__time-container", scrubbingContainer: "plyr__preview-scrubbing", scrubbingContainerShown: "plyr__preview-scrubbing--is-shown" } }, attributes: { embed: { provider: "data-plyr-provider", id: "data-plyr-embed-id", hash: "data-plyr-embed-hash" } }, ads: { enabled: !1, publisherId: "", tagUrl: "" }, previewThumbnails: { enabled: !1, src: "" }, vimeo: { byline: !1, portrait: !1, title: !1, speed: !0, transparent: !1, customControls: !0, referrerPolicy: null, premium: !1 }, youtube: { rel: 0, showinfo: 0, iv_load_policy: 3, modestbranding: 1, customControls: !0, noCookie: !1 }, mediaMetadata: { title: "", artist: "", album: "", artwork: [] }, markers: { enabled: !1, points: [] } }, We = "picture-in-picture", Ye = { html5: "html5", youtube: "youtube", vimeo: "vimeo" }, Xe = "video", Ve = () => { }; class Ge { constructor(e = !1) { this.enabled = window.console && e, this.enabled && this.log("Debugging enabled") } get log() { return this.enabled ? Function.prototype.bind.call(console.log, console) : Ve } get warn() { return this.enabled ? Function.prototype.bind.call(console.warn, console) : Ve } get error() { return this.enabled ? Function.prototype.bind.call(console.error, console) : Ve } } class Ue { constructor(t) { e(this, "onChange", (() => { if (!this.enabled) return; const e = this.player.elements.buttons.fullscreen; z(e) && (e.pressed = this.active); const t = this.target === this.player.media ? this.target : this.player.elements.container; fe.call(this.player, t, this.active ? "enterfullscreen" : "exitfullscreen", !0) })), e(this, "toggleFallback", ((e = !1) => { if (e ? this.scrollPosition = { x: window.scrollX || 0, y: window.scrollY || 0 } : window.scrollTo(this.scrollPosition.x, this.scrollPosition.y), document.body.style.overflow = e ? "hidden" : "", te(this.target, this.player.config.classNames.fullscreen.fallback, e), R.isIos) { let t = document.head.querySelector('meta[name="viewport"]'); const i = "viewport-fit=cover"; t || (t = document.createElement("meta"), t.setAttribute("name", "viewport")); const n = M(t.content) && t.content.includes(i); e ? (this.cleanupViewport = !n, n || (t.content += `,${i}`)) : this.cleanupViewport && (t.content = t.content.split(",").filter((e => e.trim() !== i)).join(",")) } this.onChange() })), e(this, "trapFocus", (e => { if (R.isIos || !this.active || "Tab" !== e.key) return; const t = document.activeElement, i = se.call(this.player, "a[href], button:not(:disabled), input:not(:disabled), [tabindex]"), [n] = i, s = i[i.length - 1]; t !== s || e.shiftKey ? t === n && e.shiftKey && (s.focus(), e.preventDefault()) : (n.focus(), e.preventDefault()) })), e(this, "update", (() => { if (this.enabled) { let e; e = this.forceFallback ? "Fallback (forced)" : Ue.native ? "Native" : "Fallback", this.player.debug.log(`${e} fullscreen enabled`) } else this.player.debug.log("Fullscreen not supported and fallback disabled"); te(this.player.elements.container, this.player.config.classNames.fullscreen.enabled, this.enabled) })), e(this, "enter", (() => { this.enabled && (R.isIos && this.player.config.fullscreen.iosNative ? this.player.isVimeo ? this.player.embed.requestFullscreen() : this.target.webkitEnterFullscreen() : !Ue.native || this.forceFallback ? this.toggleFallback(!0) : this.prefix ? H(this.prefix) || this.target[`${this.prefix}Request${this.property}`]() : this.target.requestFullscreen({ navigationUI: "hide" })) })), e(this, "exit", (() => { if (this.enabled) if (R.isIos && this.player.config.fullscreen.iosNative) this.target.webkitExitFullscreen(), ve(this.player.play()); else if (!Ue.native || this.forceFallback) this.toggleFallback(!1); else if (this.prefix) { if (!H(this.prefix)) { const e = "moz" === this.prefix ? "Cancel" : "Exit"; document[`${this.prefix}${e}${this.property}`]() } } else (document.cancelFullScreen || document.exitFullscreen).call(document) })), e(this, "toggle", (() => { this.active ? this.exit() : this.enter() })), this.player = t, this.prefix = Ue.prefix, this.property = Ue.property, this.scrollPosition = { x: 0, y: 0 }, this.forceFallback = "force" === t.config.fullscreen.fallback, this.player.elements.fullscreen = t.config.fullscreen.container && function (e, t) { const { prototype: i } = Element; return (i.closest || function () { let e = this; do { if (ne.matches(e, t)) return e; e = e.parentElement || e.parentNode } while (null !== e && 1 === e.nodeType); return null }).call(e, t) }(this.player.elements.container, t.config.fullscreen.container), ue.call(this.player, document, "ms" === this.prefix ? "MSFullscreenChange" : `${this.prefix}fullscreenchange`, (() => { this.onChange() })), ue.call(this.player, this.player.elements.container, "dblclick", (e => { z(this.player.elements.controls) && this.player.elements.controls.contains(e.target) || this.player.listeners.proxy(e, this.toggle, "fullscreen") })), ue.call(this, this.player.elements.container, "keydown", (e => this.trapFocus(e))), this.update() } static get native() { return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled) } get usingNative() { return Ue.native && !this.forceFallback } static get prefix() { if (I(document.exitFullscreen)) return ""; let e = ""; return ["webkit", "moz", "ms"].some((t => !(!I(document[`${t}ExitFullscreen`]) && !I(document[`${t}CancelFullScreen`]) || (e = t, 0)))), e } static get property() { return "moz" === this.prefix ? "FullScreen" : "Fullscreen" } get enabled() { return (Ue.native || this.player.config.fullscreen.fallback) && this.player.config.fullscreen.enabled && this.player.supported.ui && this.player.isVideo } get active() { if (!this.enabled) return !1; if (!Ue.native || this.forceFallback) return ie(this.target, this.player.config.classNames.fullscreen.fallback); const e = this.prefix ? this.target.getRootNode()[`${this.prefix}${this.property}Element`] : this.target.getRootNode().fullscreenElement; return e && e.shadowRoot ? e === this.target.getRootNode().host : e === this.target } get target() { return R.isIos && this.player.config.fullscreen.iosNative ? this.player.media : this.player.elements.fullscreen || this.player.elements.container } } function Qe(e, t = 1) { return new Promise(((i, n) => { const s = new Image, r = () => { delete s.onload, delete s.onerror, (s.naturalWidth >= t ? i : n)(s) }; Object.assign(s, { onload: r, onerror: r, src: e }) })) } const Ke = { addStyleHook() { te(this.elements.container, this.config.selectors.container.replace(".", ""), !0), te(this.elements.container, this.config.classNames.uiSupported, this.supported.ui) }, toggleNativeControls(e = !1) { e && this.isHTML5 ? this.media.setAttribute("controls", "") : this.media.removeAttribute("controls") }, build() { if (this.listeners.media(), !this.supported.ui) return this.debug.warn(`Basic support only for ${this.provider} ${this.type}`), void Ke.toggleNativeControls.call(this, !0); z(this.elements.controls) || (Fe.inject.call(this), this.listeners.controls()), Ke.toggleNativeControls.call(this), this.isHTML5 && Be.setup.call(this), this.volume = null, this.muted = null, this.loop = null, this.quality = null, this.speed = null, Fe.updateVolume.call(this), Fe.timeUpdate.call(this), Fe.durationUpdate.call(this), Ke.checkPlaying.call(this), te(this.elements.container, this.config.classNames.pip.supported, le.pip && this.isHTML5 && this.isVideo), te(this.elements.container, this.config.classNames.airplay.supported, le.airplay && this.isHTML5), te(this.elements.container, this.config.classNames.isIos, R.isIos), te(this.elements.container, this.config.classNames.isTouch, this.touch), this.ready = !0, setTimeout((() => { fe.call(this, this.media, "ready") }), 0), Ke.setTitle.call(this), this.poster && Ke.setPoster.call(this, this.poster, !1).catch((() => { })), this.config.duration && Fe.durationUpdate.call(this), this.config.mediaMetadata && Fe.setMediaMetadata.call(this) }, setTitle() { let e = Le.get("play", this.config); if (M(this.config.title) && !H(this.config.title) && (e += `, ${this.config.title}`), Array.from(this.elements.buttons.play || []).forEach((t => { t.setAttribute("aria-label", e) })), this.isEmbed) { const e = re.call(this, "iframe"); if (!z(e)) return; const t = H(this.config.title) ? "video" : this.config.title, i = Le.get("frameTitle", this.config); e.setAttribute("title", i.replace("{title}", t)) } }, togglePoster(e) { te(this.elements.container, this.config.classNames.posterEnabled, e) }, setPoster(e, t = !0) { return t && this.poster ? Promise.reject(new Error("Poster already set")) : (this.media.setAttribute("data-poster", e), this.elements.poster.removeAttribute("hidden"), ge.call(this).then((() => Qe(e))).catch((t => { throw e === this.poster && Ke.togglePoster.call(this, !1), t })).then((() => { if (e !== this.poster) throw new Error("setPoster cancelled by later call to setPoster") })).then((() => (Object.assign(this.elements.poster.style, { backgroundImage: `url('${e}')`, backgroundSize: "" }), Ke.togglePoster.call(this, !0), e)))) }, checkPlaying(e) { te(this.elements.container, this.config.classNames.playing, this.playing), te(this.elements.container, this.config.classNames.paused, this.paused), te(this.elements.container, this.config.classNames.stopped, this.stopped), Array.from(this.elements.buttons.play || []).forEach((e => { Object.assign(e, { pressed: this.playing }), e.setAttribute("aria-label", Le.get(this.playing ? "pause" : "play", this.config)) })), D(e) && "timeupdate" === e.type || Ke.toggleControls.call(this) }, checkLoading(e) { this.loading = ["stalled", "waiting"].includes(e.type), clearTimeout(this.timers.loading), this.timers.loading = setTimeout((() => { te(this.elements.container, this.config.classNames.loading, this.loading), Ke.toggleControls.call(this) }), this.loading ? 250 : 0) }, toggleControls(e) { const { controls: t } = this.elements; if (t && this.config.hideControls) { const i = this.touch && this.lastSeekTime + 2e3 > Date.now(); this.toggleControls(Boolean(e || this.loading || this.paused || t.pressed || t.hover || i)) } }, migrateStyles() { Object.values({ ...this.media.style }).filter((e => !H(e) && M(e) && e.startsWith("--plyr"))).forEach((e => { this.elements.container.style.setProperty(e, this.media.style.getPropertyValue(e)), this.media.style.removeProperty(e) })), H(this.media.style) && this.media.removeAttribute("style") } }; class Ze { constructor(t) { e(this, "firstTouch", (() => { const { player: e } = this, { elements: t } = e; e.touch = !0, te(t.container, e.config.classNames.isTouch, !0) })), e(this, "setTabFocus", (e => { const { player: t } = this, { elements: i } = t, { key: n, type: s, timeStamp: r } = e; if (clearTimeout(this.focusTimer), "keydown" === s && "Tab" !== n) return; "keydown" === s && (this.lastKeyDown = r); const o = r - this.lastKeyDown <= 20; ("focus" !== s || o) && ((() => { const e = t.config.classNames.tabFocus; te(se.call(t, `.${e}`), e, !1) })(), "focusout" !== s && (this.focusTimer = setTimeout((() => { const e = document.activeElement; i.container.contains(e) && te(document.activeElement, t.config.classNames.tabFocus, !0) }), 10))) })), e(this, "global", ((e = !0) => { const { player: t } = this; t.config.keyboard.global && de.call(t, window, "keydown keyup", this.handleKey, e, !1), de.call(t, document.body, "click", this.toggleMenu, e), pe.call(t, document.body, "touchstart", this.firstTouch), de.call(t, document.body, "keydown focus blur focusout", this.setTabFocus, e, !1, !0) })), e(this, "container", (() => { const { player: e } = this, { config: t, elements: i, timers: n } = e; !t.keyboard.global && t.keyboard.focused && ue.call(e, i.container, "keydown keyup", this.handleKey, !1), ue.call(e, i.container, "mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen", (t => { const { controls: s } = i; s && "enterfullscreen" === t.type && (s.pressed = !1, s.hover = !1); let r = 0;["touchstart", "touchmove", "mousemove"].includes(t.type) && (Ke.toggleControls.call(e, !0), r = e.touch ? 3e3 : 2e3), clearTimeout(n.controls), n.controls = setTimeout((() => Ke.toggleControls.call(e, !1)), r) })); const s = () => { if (!e.isVimeo || e.config.vimeo.premium) return; const t = i.wrapper, { active: n } = e.fullscreen, [s, r] = Ee.call(e), o = we(`aspect-ratio: ${s} / ${r}`); if (!n) return void (o ? (t.style.width = null, t.style.height = null) : (t.style.maxWidth = null, t.style.margin = null)); const [a, l] = [Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0), Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)], c = a / l > s / r; o ? (t.style.width = c ? "auto" : "100%", t.style.height = c ? "100%" : "auto") : (t.style.maxWidth = c ? l / r * s + "px" : null, t.style.margin = c ? "0 auto" : null) }, r = () => { clearTimeout(n.resized), n.resized = setTimeout(s, 50) }; ue.call(e, i.container, "enterfullscreen exitfullscreen", (t => { const { target: n } = e.fullscreen; n === i.container && (!e.isEmbed && H(e.config.ratio) || (s(), ("enterfullscreen" === t.type ? ue : he).call(e, window, "resize", r))) })) })), e(this, "media", (() => { const { player: e } = this, { elements: t } = e; if (ue.call(e, e.media, "timeupdate seeking seeked", (t => Fe.timeUpdate.call(e, t))), ue.call(e, e.media, "durationchange loadeddata loadedmetadata", (t => Fe.durationUpdate.call(e, t))), ue.call(e, e.media, "ended", (() => { e.isHTML5 && e.isVideo && e.config.resetOnEnd && (e.restart(), e.pause()) })), ue.call(e, e.media, "progress playing seeking seeked", (t => Fe.updateProgress.call(e, t))), ue.call(e, e.media, "volumechange", (t => Fe.updateVolume.call(e, t))), ue.call(e, e.media, "playing play pause ended emptied timeupdate", (t => Ke.checkPlaying.call(e, t))), ue.call(e, e.media, "waiting canplay seeked playing", (t => Ke.checkLoading.call(e, t))), e.supported.ui && e.config.clickToPlay && !e.isAudio) { const i = re.call(e, `.${e.config.classNames.video}`); if (!z(i)) return; ue.call(e, t.container, "click", (n => { ([t.container, i].includes(n.target) || i.contains(n.target)) && (e.touch && e.config.hideControls || (e.ended ? (this.proxy(n, e.restart, "restart"), this.proxy(n, (() => { ve(e.play()) }), "play")) : this.proxy(n, (() => { ve(e.togglePlay()) }), "play"))) })) } e.supported.ui && e.config.disableContextMenu && ue.call(e, t.wrapper, "contextmenu", (e => { e.preventDefault() }), !1), ue.call(e, e.media, "volumechange", (() => { e.storage.set({ volume: e.volume, muted: e.muted }) })), ue.call(e, e.media, "ratechange", (() => { Fe.updateSetting.call(e, "speed"), e.storage.set({ speed: e.speed }) })), ue.call(e, e.media, "qualitychange", (t => { Fe.updateSetting.call(e, "quality", null, t.detail.quality) })), ue.call(e, e.media, "ready qualitychange", (() => { Fe.setDownloadUrl.call(e) })); const i = e.config.events.concat(["keyup", "keydown"]).join(" "); ue.call(e, e.media, i, (i => { let { detail: n = {} } = i; "error" === i.type && (n = e.media.error), fe.call(e, t.container, i.type, !0, n) })) })), e(this, "proxy", ((e, t, i) => { const { player: n } = this, s = n.config.listeners[i]; let r = !0; I(s) && (r = s.call(n, e)), !1 !== r && I(t) && t.call(n, e) })), e(this, "bind", ((e, t, i, n, s = !0) => { const { player: r } = this, o = r.config.listeners[n], a = I(o); ue.call(r, e, t, (e => this.proxy(e, i, n)), s && !a) })), e(this, "controls", (() => { const { player: e } = this, { elements: t } = e, i = R.isIE ? "change" : "input"; if (t.buttons.play && Array.from(t.buttons.play).forEach((t => { this.bind(t, "click", (() => { ve(e.togglePlay()) }), "play") })), this.bind(t.buttons.restart, "click", e.restart, "restart"), this.bind(t.buttons.rewind, "click", (() => { e.lastSeekTime = Date.now(), e.rewind() }), "rewind"), this.bind(t.buttons.fastForward, "click", (() => { e.lastSeekTime = Date.now(), e.forward() }), "fastForward"), this.bind(t.buttons.mute, "click", (() => { e.muted = !e.muted }), "mute"), this.bind(t.buttons.captions, "click", (() => e.toggleCaptions())), this.bind(t.buttons.download, "click", (() => { fe.call(e, e.media, "download") }), "download"), this.bind(t.buttons.fullscreen, "click", (() => { e.fullscreen.toggle() }), "fullscreen"), this.bind(t.buttons.pip, "click", (() => { e.pip = "toggle" }), "pip"), this.bind(t.buttons.airplay, "click", e.airplay, "airplay"), this.bind(t.buttons.settings, "click", (t => { t.stopPropagation(), t.preventDefault(), Fe.toggleMenu.call(e, t) }), null, !1), this.bind(t.buttons.settings, "keyup", (t => { ["Space", "Enter"].includes(t.key) && ("Enter" !== t.key ? (t.preventDefault(), t.stopPropagation(), Fe.toggleMenu.call(e, t)) : Fe.focusFirstMenuItem.call(e, null, !0)) }), null, !1), this.bind(t.settings.menu, "keydown", (t => { "Escape" === t.key && Fe.toggleMenu.call(e, t) })), this.bind(t.inputs.seek, "mousedown mousemove", (e => { const i = t.progress.getBoundingClientRect(), n = 100 / i.width * (e.pageX - i.left); e.currentTarget.setAttribute("seek-value", n) })), this.bind(t.inputs.seek, "mousedown mouseup keydown keyup touchstart touchend", (t => { const i = t.currentTarget, n = "play-on-seeked"; if (N(t) && !["ArrowLeft", "ArrowRight"].includes(t.key)) return; e.lastSeekTime = Date.now(); const s = i.hasAttribute(n), r = ["mouseup", "touchend", "keyup"].includes(t.type); s && r ? (i.removeAttribute(n), ve(e.play())) : !r && e.playing && (i.setAttribute(n, ""), e.pause()) })), R.isIos) { const t = se.call(e, 'input[type="range"]'); Array.from(t).forEach((e => this.bind(e, i, (e => B(e.target))))) } this.bind(t.inputs.seek, i, (t => { const i = t.currentTarget; let n = i.getAttribute("seek-value"); H(n) && (n = i.value), i.removeAttribute("seek-value"), e.currentTime = n / i.max * e.duration }), "seek"), this.bind(t.progress, "mouseenter mouseleave mousemove", (t => Fe.updateSeekTooltip.call(e, t))), this.bind(t.progress, "mousemove touchmove", (t => { const { previewThumbnails: i } = e; i && i.loaded && i.startMove(t) })), this.bind(t.progress, "mouseleave touchend click", (() => { const { previewThumbnails: t } = e; t && t.loaded && t.endMove(!1, !0) })), this.bind(t.progress, "mousedown touchstart", (t => { const { previewThumbnails: i } = e; i && i.loaded && i.startScrubbing(t) })), this.bind(t.progress, "mouseup touchend", (t => { const { previewThumbnails: i } = e; i && i.loaded && i.endScrubbing(t) })), R.isWebkit && Array.from(se.call(e, 'input[type="range"]')).forEach((t => { this.bind(t, "input", (t => Fe.updateRangeFill.call(e, t.target))) })), e.config.toggleInvert && !z(t.display.duration) && this.bind(t.display.currentTime, "click", (() => { 0 !== e.currentTime && (e.config.invertTime = !e.config.invertTime, Fe.timeUpdate.call(e)) })), this.bind(t.inputs.volume, i, (t => { e.volume = t.target.value }), "volume"), this.bind(t.controls, "mouseenter mouseleave", (i => { t.controls.hover = !e.touch && "mouseenter" === i.type })), t.fullscreen && Array.from(t.fullscreen.children).filter((e => !e.contains(t.container))).forEach((i => { this.bind(i, "mouseenter mouseleave", (i => { t.controls && (t.controls.hover = !e.touch && "mouseenter" === i.type) })) })), this.bind(t.controls, "mousedown mouseup touchstart touchend touchcancel", (e => { t.controls.pressed = ["mousedown", "touchstart"].includes(e.type) })), this.bind(t.controls, "focusin", (() => { const { config: i, timers: n } = e; te(t.controls, i.classNames.noTransition, !0), Ke.toggleControls.call(e, !0), setTimeout((() => { te(t.controls, i.classNames.noTransition, !1) }), 0); const s = this.touch ? 3e3 : 4e3; clearTimeout(n.controls), n.controls = setTimeout((() => Ke.toggleControls.call(e, !1)), s) })), this.bind(t.inputs.volume, "wheel", (t => { const i = t.webkitDirectionInvertedFromDevice, [n, s] = [t.deltaX, -t.deltaY].map((e => i ? -e : e)), r = Math.sign(Math.abs(n) > Math.abs(s) ? n : s); e.increaseVolume(r / 50); const { volume: o } = e.media; (1 === r && o < 1 || -1 === r && o > 0) && t.preventDefault() }), "volume", !1) })), this.player = t, this.lastKey = null, this.focusTimer = null, this.lastKeyDown = null, this.handleKey = this.handleKey.bind(this), this.toggleMenu = this.toggleMenu.bind(this), this.setTabFocus = this.setTabFocus.bind(this), this.firstTouch = this.firstTouch.bind(this) } handleKey(e) { const { player: t } = this, { elements: i } = t, { key: n, type: s, altKey: r, ctrlKey: o, metaKey: a, shiftKey: l } = e, c = "keydown" === s, d = c && n === this.lastKey; var u; if (!(r || o || a || l) && n) if (c) { const s = document.activeElement; if (z(s)) { const { editable: n } = t.config.selectors, { seek: r } = i.inputs; if (s !== r && ne(s, n)) return; if ("Space" === e.key && ne(s, 'button, [role^="menuitem"]')) return } switch (["Space", "ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "c", "f", "k", "l", "m"].includes(n) && (e.preventDefault(), e.stopPropagation()), n) { case "0": case "1": case "2": case "3": case "4": case "5": case "6": case "7": case "8": case "9": d || (u = parseInt(n, 10), t.currentTime = t.duration / 10 * u); break; case "Space": case "k": d || ve(t.togglePlay()); break; case "ArrowUp": t.increaseVolume(.1); break; case "ArrowDown": t.decreaseVolume(.1); break; case "m": d || (t.muted = !t.muted); break; case "ArrowRight": t.forward(); break; case "ArrowLeft": t.rewind(); break; case "f": t.fullscreen.toggle(); break; case "c": d || t.toggleCaptions(); break; case "l": t.loop = !t.loop }"Escape" === n && !t.fullscreen.usingNative && t.fullscreen.active && t.fullscreen.toggle(), this.lastKey = n } else this.lastKey = null } toggleMenu(e) { Fe.toggleMenu.call(this.player, e) } } "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self; var Je = function (e, t) { return function (e, t) { e.exports = function () { var e = function () { }, t = {}, i = {}, n = {}; function s(e, t) { e = e.push ? e : [e]; var s, r, o, a = [], l = e.length, c = l; for (s = function (e, i) { i.length && a.push(e), --c || t(a) }; l--;)r = e[l], (o = i[r]) ? s(r, o) : (n[r] = n[r] || []).push(s) } function r(e, t) { if (e) { var s = n[e]; if (i[e] = t, s) for (; s.length;)s[0](e, t), s.splice(0, 1) } } function o(t, i) { t.call && (t = { success: t }), i.length ? (t.error || e)(i) : (t.success || e)(t) } function a(t, i, n, s) { var r, o, l = document, c = n.async, d = (n.numRetries || 0) + 1, u = n.before || e, h = t.replace(/[\?|#].*$/, ""), p = t.replace(/^(css|img)!/, ""); s = s || 0, /(^css!|\.css$)/.test(h) ? ((o = l.createElement("link")).rel = "stylesheet", o.href = p, (r = "hideFocus" in o) && o.relList && (r = 0, o.rel = "preload", o.as = "style")) : /(^img!|\.(png|gif|jpg|svg|webp)$)/.test(h) ? (o = l.createElement("img")).src = p : ((o = l.createElement("script")).src = t, o.async = void 0 === c || c), o.onload = o.onerror = o.onbeforeload = function (e) { var l = e.type[0]; if (r) try { o.sheet.cssText.length || (l = "e") } catch (e) { 18 != e.code && (l = "e") } if ("e" == l) { if ((s += 1) < d) return a(t, i, n, s) } else if ("preload" == o.rel && "style" == o.as) return o.rel = "stylesheet"; i(t, l, e.defaultPrevented) }, !1 !== u(t, o) && l.head.appendChild(o) } function l(e, t, i) { var n, s, r = (e = e.push ? e : [e]).length, o = r, l = []; for (n = function (e, i, n) { if ("e" == i && l.push(e), "b" == i) { if (!n) return; l.push(e) } --r || t(l) }, s = 0; s < o; s++)a(e[s], n, i) } function c(e, i, n) { var s, a; if (i && i.trim && (s = i), a = (s ? n : i) || {}, s) { if (s in t) throw "LoadJS"; t[s] = !0 } function c(t, i) { l(e, (function (e) { o(a, e), t && o({ success: t, error: i }, e), r(s, e) }), a) } if (a.returnPromise) return new Promise(c); c() } return c.ready = function (e, t) { return s(e, (function (e) { o(t, e) })), c }, c.done = function (e) { r(e, []) }, c.reset = function () { t = {}, i = {}, n = {} }, c.isDefined = function (e) { return e in t }, c }() }(t = { exports: {} }), t.exports }(); function et(e) { return new Promise(((t, i) => { Je(e, { success: t, error: i }) })) } function tt(e) { e && !this.embed.hasPlayed && (this.embed.hasPlayed = !0), this.media.paused === e && (this.media.paused = !e, fe.call(this, this.media, e ? "play" : "pause")) } const it = { setup() { const e = this; te(e.elements.wrapper, e.config.classNames.embed, !0), e.options.speed = e.config.speed.options, Se.call(e), A(window.Vimeo) ? it.ready.call(e) : et(e.config.urls.vimeo.sdk).then((() => { it.ready.call(e) })).catch((t => { e.debug.warn("Vimeo SDK (player.js) failed to load", t) })) }, ready() { const e = this, t = e.config.vimeo, { premium: i, referrerPolicy: n, ...s } = t; let r = e.media.getAttribute("src"), o = ""; H(r) ? (r = e.media.getAttribute(e.config.attributes.embed.id), o = e.media.getAttribute(e.config.attributes.embed.hash)) : o = function (e) { const t = e.match(/^.*(vimeo.com\/|video\/)(\d+)(\?.*&*h=|\/)+([\d,a-f]+)/); return t && 5 === t.length ? t[4] : null }(r); const a = o ? { h: o } : {}; i && Object.assign(s, { controls: !1, sidedock: !1 }); const l = qe({ loop: e.config.loop.active, autoplay: e.autoplay, muted: e.muted, gesture: "media", playsinline: !this.config.fullscreen.iosNative, ...a, ...s }), c = H(d = r) ? null : $(Number(d)) ? d : d.match(/^.*(vimeo.com\/|video\/)(\d+).*/) ? RegExp.$2 : d; var d; const u = G("iframe"), h = Ae(e.config.urls.vimeo.iframe, c, l); if (u.setAttribute("src", h), u.setAttribute("allowfullscreen", ""), u.setAttribute("allow", ["autoplay", "fullscreen", "picture-in-picture", "encrypted-media", "accelerometer", "gyroscope"].join("; ")), H(n) || u.setAttribute("referrerPolicy", n), i || !t.customControls) u.setAttribute("data-poster", e.poster), e.media = Z(u, e.media); else { const t = G("div", { class: e.config.classNames.embedContainer, "data-poster": e.poster }); t.appendChild(u), e.media = Z(t, e.media) } t.customControls || ze(Ae(e.config.urls.vimeo.api, h)).then((t => { !H(t) && t.thumbnail_url && Ke.setPoster.call(e, t.thumbnail_url).catch((() => { })) })), e.embed = new window.Vimeo.Player(u, { autopause: e.config.autopause, muted: e.muted }), e.media.paused = !0, e.media.currentTime = 0, e.supported.ui && e.embed.disableTextTrack(), e.media.play = () => (tt.call(e, !0), e.embed.play()), e.media.pause = () => (tt.call(e, !1), e.embed.pause()), e.media.stop = () => { e.pause(), e.currentTime = 0 }; let { currentTime: p } = e.media; Object.defineProperty(e.media, "currentTime", { get: () => p, set(t) { const { embed: i, media: n, paused: s, volume: r } = e, o = s && !i.hasPlayed; n.seeking = !0, fe.call(e, n, "seeking"), Promise.resolve(o && i.setVolume(0)).then((() => i.setCurrentTime(t))).then((() => o && i.pause())).then((() => o && i.setVolume(r))).catch((() => { })) } }); let f = e.config.speed.selected; Object.defineProperty(e.media, "playbackRate", { get: () => f, set(t) { e.embed.setPlaybackRate(t).then((() => { f = t, fe.call(e, e.media, "ratechange") })).catch((() => { e.options.speed = [1] })) } }); let { volume: m } = e.config; Object.defineProperty(e.media, "volume", { get: () => m, set(t) { e.embed.setVolume(t).then((() => { m = t, fe.call(e, e.media, "volumechange") })) } }); let { muted: g } = e.config; Object.defineProperty(e.media, "muted", { get: () => g, set(t) { const i = !!P(t) && t; e.embed.setVolume(i ? 0 : e.config.volume).then((() => { g = i, fe.call(e, e.media, "volumechange") })) } }); let v, { loop: y } = e.config; Object.defineProperty(e.media, "loop", { get: () => y, set(t) { const i = P(t) ? t : e.config.loop.active; e.embed.setLoop(i).then((() => { y = i })) } }), e.embed.getVideoUrl().then((t => { v = t, Fe.setDownloadUrl.call(e) })).catch((e => { this.debug.warn(e) })), Object.defineProperty(e.media, "currentSrc", { get: () => v }), Object.defineProperty(e.media, "ended", { get: () => e.currentTime === e.duration }), Promise.all([e.embed.getVideoWidth(), e.embed.getVideoHeight()]).then((t => { const [i, n] = t; e.embed.ratio = Ce(i, n), Se.call(this) })), e.embed.setAutopause(e.config.autopause).then((t => { e.config.autopause = t })), e.embed.getVideoTitle().then((t => { e.config.title = t, Ke.setTitle.call(this) })), e.embed.getCurrentTime().then((t => { p = t, fe.call(e, e.media, "timeupdate") })), e.embed.getDuration().then((t => { e.media.duration = t, fe.call(e, e.media, "durationchange") })), e.embed.getTextTracks().then((t => { e.media.textTracks = t, Be.setup.call(e) })), e.embed.on("cuechange", (({ cues: t = [] }) => { const i = t.map((e => function (e) { const t = document.createDocumentFragment(), i = document.createElement("div"); return t.appendChild(i), i.innerHTML = e, t.firstChild.innerText }(e.text))); Be.updateCues.call(e, i) })), e.embed.on("loaded", (() => { e.embed.getPaused().then((t => { tt.call(e, !t), t || fe.call(e, e.media, "playing") })), z(e.embed.element) && e.supported.ui && e.embed.element.setAttribute("tabindex", -1) })), e.embed.on("bufferstart", (() => { fe.call(e, e.media, "waiting") })), e.embed.on("bufferend", (() => { fe.call(e, e.media, "playing") })), e.embed.on("play", (() => { tt.call(e, !0), fe.call(e, e.media, "playing") })), e.embed.on("pause", (() => { tt.call(e, !1) })), e.embed.on("timeupdate", (t => { e.media.seeking = !1, p = t.seconds, fe.call(e, e.media, "timeupdate") })), e.embed.on("progress", (t => { e.media.buffered = t.percent, fe.call(e, e.media, "progress"), 1 === parseInt(t.percent, 10) && fe.call(e, e.media, "canplaythrough"), e.embed.getDuration().then((t => { t !== e.media.duration && (e.media.duration = t, fe.call(e, e.media, "durationchange")) })) })), e.embed.on("seeked", (() => { e.media.seeking = !1, fe.call(e, e.media, "seeked") })), e.embed.on("ended", (() => { e.media.paused = !0, fe.call(e, e.media, "ended") })), e.embed.on("error", (t => { e.media.error = t, fe.call(e, e.media, "error") })), t.customControls && setTimeout((() => Ke.build.call(e)), 0) } }; function nt(e) { e && !this.embed.hasPlayed && (this.embed.hasPlayed = !0), this.media.paused === e && (this.media.paused = !e, fe.call(this, this.media, e ? "play" : "pause")) } function st(e) { return e.noCookie ? "https://www.youtube-nocookie.com" : "http:" === window.location.protocol ? "http://www.youtube.com" : void 0 } const rt = { setup() { if (te(this.elements.wrapper, this.config.classNames.embed, !0), A(window.YT) && I(window.YT.Player)) rt.ready.call(this); else { const e = window.onYouTubeIframeAPIReady; window.onYouTubeIframeAPIReady = () => { I(e) && e(), rt.ready.call(this) }, et(this.config.urls.youtube.sdk).catch((e => { this.debug.warn("YouTube API failed to load", e) })) } }, getTitle(e) { ze(Ae(this.config.urls.youtube.api, e)).then((e => { if (A(e)) { const { title: t, height: i, width: n } = e; this.config.title = t, Ke.setTitle.call(this), this.embed.ratio = Ce(n, i) } Se.call(this) })).catch((() => { Se.call(this) })) }, ready() { const e = this, t = e.config.youtube, i = e.media && e.media.getAttribute("id"); if (!H(i) && i.startsWith("youtube-")) return; let n = e.media.getAttribute("src"); H(n) && (n = e.media.getAttribute(this.config.attributes.embed.id)); const s = H(r = n) ? null : r.match(/^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/) ? RegExp.$2 : r; var r; const o = G("div", { id: `${e.provider}-${Math.floor(1e4 * Math.random())}`, "data-poster": t.customControls ? e.poster : void 0 }); if (e.media = Z(o, e.media), t.customControls) { const t = e => `https://i.ytimg.com/vi/${s}/${e}default.jpg`; Qe(t("maxres"), 121).catch((() => Qe(t("sd"), 121))).catch((() => Qe(t("hq")))).then((t => Ke.setPoster.call(e, t.src))).then((t => { t.includes("maxres") || (e.elements.poster.style.backgroundSize = "cover") })).catch((() => { })) } e.embed = new window.YT.Player(e.media, { videoId: s, host: st(t), playerVars: Y({}, { autoplay: e.config.autoplay ? 1 : 0, hl: e.config.hl, controls: e.supported.ui && t.customControls ? 0 : 1, disablekb: 1, playsinline: e.config.fullscreen.iosNative ? 0 : 1, cc_load_policy: e.captions.active ? 1 : 0, cc_lang_pref: e.config.captions.language, widget_referrer: window ? window.location.href : null }, t), events: { onError(t) { if (!e.media.error) { const i = t.data, n = { 2: "The request contains an invalid parameter value. For example, this error occurs if you specify a video ID that does not have 11 characters, or if the video ID contains invalid characters, such as exclamation points or asterisks.", 5: "The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred.", 100: "The video requested was not found. This error occurs when a video has been removed (for any reason) or has been marked as private.", 101: "The owner of the requested video does not allow it to be played in embedded players.", 150: "The owner of the requested video does not allow it to be played in embedded players." }[i] || "An unknown error occured"; e.media.error = { code: i, message: n }, fe.call(e, e.media, "error") } }, onPlaybackRateChange(t) { const i = t.target; e.media.playbackRate = i.getPlaybackRate(), fe.call(e, e.media, "ratechange") }, onReady(i) { if (I(e.media.play)) return; const n = i.target; rt.getTitle.call(e, s), e.media.play = () => { nt.call(e, !0), n.playVideo() }, e.media.pause = () => { nt.call(e, !1), n.pauseVideo() }, e.media.stop = () => { n.stopVideo() }, e.media.duration = n.getDuration(), e.media.paused = !0, e.media.currentTime = 0, Object.defineProperty(e.media, "currentTime", { get: () => Number(n.getCurrentTime()), set(t) { e.paused && !e.embed.hasPlayed && e.embed.mute(), e.media.seeking = !0, fe.call(e, e.media, "seeking"), n.seekTo(t) } }), Object.defineProperty(e.media, "playbackRate", { get: () => n.getPlaybackRate(), set(e) { n.setPlaybackRate(e) } }); let { volume: r } = e.config; Object.defineProperty(e.media, "volume", { get: () => r, set(t) { r = t, n.setVolume(100 * r), fe.call(e, e.media, "volumechange") } }); let { muted: o } = e.config; Object.defineProperty(e.media, "muted", { get: () => o, set(t) { const i = P(t) ? t : o; o = i, n[i ? "mute" : "unMute"](), n.setVolume(100 * r), fe.call(e, e.media, "volumechange") } }), Object.defineProperty(e.media, "currentSrc", { get: () => n.getVideoUrl() }), Object.defineProperty(e.media, "ended", { get: () => e.currentTime === e.duration }); const a = n.getAvailablePlaybackRates(); e.options.speed = a.filter((t => e.config.speed.options.includes(t))), e.supported.ui && t.customControls && e.media.setAttribute("tabindex", -1), fe.call(e, e.media, "timeupdate"), fe.call(e, e.media, "durationchange"), clearInterval(e.timers.buffering), e.timers.buffering = setInterval((() => { e.media.buffered = n.getVideoLoadedFraction(), (null === e.media.lastBuffered || e.media.lastBuffered < e.media.buffered) && fe.call(e, e.media, "progress"), e.media.lastBuffered = e.media.buffered, 1 === e.media.buffered && (clearInterval(e.timers.buffering), fe.call(e, e.media, "canplaythrough")) }), 200), t.customControls && setTimeout((() => Ke.build.call(e)), 50) }, onStateChange(i) { const n = i.target; switch (clearInterval(e.timers.playing), e.media.seeking && [1, 2].includes(i.data) && (e.media.seeking = !1, fe.call(e, e.media, "seeked")), i.data) { case -1: fe.call(e, e.media, "timeupdate"), e.media.buffered = n.getVideoLoadedFraction(), fe.call(e, e.media, "progress"); break; case 0: nt.call(e, !1), e.media.loop ? (n.stopVideo(), n.playVideo()) : fe.call(e, e.media, "ended"); break; case 1: t.customControls && !e.config.autoplay && e.media.paused && !e.embed.hasPlayed ? e.media.pause() : (nt.call(e, !0), fe.call(e, e.media, "playing"), e.timers.playing = setInterval((() => { fe.call(e, e.media, "timeupdate") }), 50), e.media.duration !== n.getDuration() && (e.media.duration = n.getDuration(), fe.call(e, e.media, "durationchange"))); break; case 2: e.muted || e.embed.unMute(), nt.call(e, !1); break; case 3: fe.call(e, e.media, "waiting") }fe.call(e, e.elements.container, "statechange", !1, { code: i.data }) } } }) } }, ot = { setup() { this.media ? (te(this.elements.container, this.config.classNames.type.replace("{0}", this.type), !0), te(this.elements.container, this.config.classNames.provider.replace("{0}", this.provider), !0), this.isEmbed && te(this.elements.container, this.config.classNames.type.replace("{0}", "video"), !0), this.isVideo && (this.elements.wrapper = G("div", { class: this.config.classNames.video }), X(this.media, this.elements.wrapper), this.elements.poster = G("div", { class: this.config.classNames.poster }), this.elements.wrapper.appendChild(this.elements.poster)), this.isHTML5 ? ke.setup.call(this) : this.isYouTube ? rt.setup.call(this) : this.isVimeo && it.setup.call(this)) : this.debug.warn("No media element found!") } }; class at { constructor(t) { e(this, "load", (() => { this.enabled && (A(window.google) && A(window.google.ima) ? this.ready() : et(this.player.config.urls.googleIMA.sdk).then((() => { this.ready() })).catch((() => { this.trigger("error", new Error("Google IMA SDK failed to load")) }))) })), e(this, "ready", (() => { var e; this.enabled || ((e = this).manager && e.manager.destroy(), e.elements.displayContainer && e.elements.displayContainer.destroy(), e.elements.container.remove()), this.startSafetyTimer(12e3, "ready()"), this.managerPromise.then((() => { this.clearSafetyTimer("onAdsManagerLoaded()") })), this.listeners(), this.setupIMA() })), e(this, "setupIMA", (() => { this.elements.container = G("div", { class: this.player.config.classNames.ads }), this.player.elements.container.appendChild(this.elements.container), google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED), google.ima.settings.setLocale(this.player.config.ads.language), google.ima.settings.setDisableCustomPlaybackForIOS10Plus(this.player.config.playsinline), this.elements.displayContainer = new google.ima.AdDisplayContainer(this.elements.container, this.player.media), this.loader = new google.ima.AdsLoader(this.elements.displayContainer), this.loader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, (e => this.onAdsManagerLoaded(e)), !1), this.loader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, (e => this.onAdError(e)), !1), this.requestAds() })), e(this, "requestAds", (() => { const { container: e } = this.player.elements; try { const t = new google.ima.AdsRequest; t.adTagUrl = this.tagUrl, t.linearAdSlotWidth = e.offsetWidth, t.linearAdSlotHeight = e.offsetHeight, t.nonLinearAdSlotWidth = e.offsetWidth, t.nonLinearAdSlotHeight = e.offsetHeight, t.forceNonLinearFullSlot = !1, t.setAdWillPlayMuted(!this.player.muted), this.loader.requestAds(t) } catch (e) { this.onAdError(e) } })), e(this, "pollCountdown", ((e = !1) => { if (!e) return clearInterval(this.countdownTimer), void this.elements.container.removeAttribute("data-badge-text"); this.countdownTimer = setInterval((() => { const e = je(Math.max(this.manager.getRemainingTime(), 0)), t = `${Le.get("advertisement", this.player.config)} - ${e}`; this.elements.container.setAttribute("data-badge-text", t) }), 100) })), e(this, "onAdsManagerLoaded", (e => { if (!this.enabled) return; const t = new google.ima.AdsRenderingSettings; t.restoreCustomPlaybackStateOnAdBreakComplete = !0, t.enablePreloading = !0, this.manager = e.getAdsManager(this.player, t), this.cuePoints = this.manager.getCuePoints(), this.manager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, (e => this.onAdError(e))), Object.keys(google.ima.AdEvent.Type).forEach((e => { this.manager.addEventListener(google.ima.AdEvent.Type[e], (e => this.onAdEvent(e))) })), this.trigger("loaded") })), e(this, "addCuePoints", (() => { H(this.cuePoints) || this.cuePoints.forEach((e => { if (0 !== e && -1 !== e && e < this.player.duration) { const t = this.player.elements.progress; if (z(t)) { const i = 100 / this.player.duration * e, n = G("span", { class: this.player.config.classNames.cues }); n.style.left = `${i.toString()}%`, t.appendChild(n) } } })) })), e(this, "onAdEvent", (e => { const { container: t } = this.player.elements, i = e.getAd(), n = e.getAdData(); switch ((e => { fe.call(this.player, this.player.media, `ads${e.replace(/_/g, "").toLowerCase()}`) })(e.type), e.type) { case google.ima.AdEvent.Type.LOADED: this.trigger("loaded"), this.pollCountdown(!0), i.isLinear() || (i.width = t.offsetWidth, i.height = t.offsetHeight); break; case google.ima.AdEvent.Type.STARTED: this.manager.setVolume(this.player.volume); break; case google.ima.AdEvent.Type.ALL_ADS_COMPLETED: this.player.ended ? this.loadAds() : this.loader.contentComplete(); break; case google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED: this.pauseContent(); break; case google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED: this.pollCountdown(), this.resumeContent(); break; case google.ima.AdEvent.Type.LOG: n.adError && this.player.debug.warn(`Non-fatal ad error: ${n.adError.getMessage()}`) } })), e(this, "onAdError", (e => { this.cancel(), this.player.debug.warn("Ads error", e) })), e(this, "listeners", (() => { const { container: e } = this.player.elements; let t; this.player.on("canplay", (() => { this.addCuePoints() })), this.player.on("ended", (() => { this.loader.contentComplete() })), this.player.on("timeupdate", (() => { t = this.player.currentTime })), this.player.on("seeked", (() => { const e = this.player.currentTime; H(this.cuePoints) || this.cuePoints.forEach(((i, n) => { t < i && i < e && (this.manager.discardAdBreak(), this.cuePoints.splice(n, 1)) })) })), window.addEventListener("resize", (() => { this.manager && this.manager.resize(e.offsetWidth, e.offsetHeight, google.ima.ViewMode.NORMAL) })) })), e(this, "play", (() => { const { container: e } = this.player.elements; this.managerPromise || this.resumeContent(), this.managerPromise.then((() => { this.manager.setVolume(this.player.volume), this.elements.displayContainer.initialize(); try { this.initialized || (this.manager.init(e.offsetWidth, e.offsetHeight, google.ima.ViewMode.NORMAL), this.manager.start()), this.initialized = !0 } catch (e) { this.onAdError(e) } })).catch((() => { })) })), e(this, "resumeContent", (() => { this.elements.container.style.zIndex = "", this.playing = !1, ve(this.player.media.play()) })), e(this, "pauseContent", (() => { this.elements.container.style.zIndex = 3, this.playing = !0, this.player.media.pause() })), e(this, "cancel", (() => { this.initialized && this.resumeContent(), this.trigger("error"), this.loadAds() })), e(this, "loadAds", (() => { this.managerPromise.then((() => { this.manager && this.manager.destroy(), this.managerPromise = new Promise((e => { this.on("loaded", e), this.player.debug.log(this.manager) })), this.initialized = !1, this.requestAds() })).catch((() => { })) })), e(this, "trigger", ((e, ...t) => { const i = this.events[e]; L(i) && i.forEach((e => { I(e) && e.apply(this, t) })) })), e(this, "on", ((e, t) => (L(this.events[e]) || (this.events[e] = []), this.events[e].push(t), this))), e(this, "startSafetyTimer", ((e, t) => { this.player.debug.log(`Safety timer invoked from: ${t}`), this.safetyTimer = setTimeout((() => { this.cancel(), this.clearSafetyTimer("startSafetyTimer()") }), e) })), e(this, "clearSafetyTimer", (e => { k(this.safetyTimer) || (this.player.debug.log(`Safety timer cleared from: ${e}`), clearTimeout(this.safetyTimer), this.safetyTimer = null) })), this.player = t, this.config = t.config.ads, this.playing = !1, this.initialized = !1, this.elements = { container: null, displayContainer: null }, this.manager = null, this.loader = null, this.cuePoints = null, this.events = {}, this.safetyTimer = null, this.countdownTimer = null, this.managerPromise = new Promise(((e, t) => { this.on("loaded", e), this.on("error", t) })), this.load() } get enabled() { const { config: e } = this; return this.player.isHTML5 && this.player.isVideo && e.enabled && (!H(e.publisherId) || F(e.tagUrl)) } get tagUrl() { const { config: e } = this; return F(e.tagUrl) ? e.tagUrl : `https://go.aniview.com/api/adserver6/vast/?${qe({ AV_PUBLISHERID: "58c25bb0073ef448b1087ad6", AV_CHANNELID: "5a0458dc28a06145e4519d21", AV_URL: window.location.hostname, cb: Date.now(), AV_WIDTH: 640, AV_HEIGHT: 480, AV_CDIM2: e.publisherId })}` } } function lt(e = 0, t = 0, i = 255) { return Math.min(Math.max(e, t), i) } const ct = e => { const t = []; return e.split(/\r\n\r\n|\n\n|\r\r/).forEach((e => { const i = {}; e.split(/\r\n|\n|\r/).forEach((e => { if ($(i.startTime)) { if (!H(e.trim()) && H(i.text)) { const t = e.trim().split("#xywh=");[i.text] = t, t[1] && ([i.x, i.y, i.w, i.h] = t[1].split(",")) } } else { const t = e.match(/([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})( ?--> ?)([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})/); t && (i.startTime = 60 * Number(t[1] || 0) * 60 + 60 * Number(t[2]) + Number(t[3]) + Number(`0.${t[4]}`), i.endTime = 60 * Number(t[6] || 0) * 60 + 60 * Number(t[7]) + Number(t[8]) + Number(`0.${t[9]}`)) } })), i.text && t.push(i) })), t }, dt = (e, t) => { const i = {}; return e > t.width / t.height ? (i.width = t.width, i.height = 1 / e * t.width) : (i.height = t.height, i.width = e * t.height), i }; class ut { constructor(t) { e(this, "load", (() => { this.player.elements.display.seekTooltip && (this.player.elements.display.seekTooltip.hidden = this.enabled), this.enabled && this.getThumbnails().then((() => { this.enabled && (this.render(), this.determineContainerAutoSizing(), this.loaded = !0) })) })), e(this, "getThumbnails", (() => new Promise((e => { const { src: t } = this.player.config.previewThumbnails; if (H(t)) throw new Error("Missing previewThumbnails.src config attribute"); const i = () => { this.thumbnails.sort(((e, t) => e.height - t.height)), this.player.debug.log("Preview thumbnails", this.thumbnails), e() }; if (I(t)) t((e => { this.thumbnails = e, i() })); else { const e = (M(t) ? [t] : t).map((e => this.getThumbnail(e))); Promise.all(e).then(i) } })))), e(this, "getThumbnail", (e => new Promise((t => { ze(e).then((i => { const n = { frames: ct(i), height: null, urlPrefix: "" }; n.frames[0].text.startsWith("/") || n.frames[0].text.startsWith("http://") || n.frames[0].text.startsWith("https://") || (n.urlPrefix = e.substring(0, e.lastIndexOf("/") + 1)); const s = new Image; s.onload = () => { n.height = s.naturalHeight, n.width = s.naturalWidth, this.thumbnails.push(n), t() }, s.src = n.urlPrefix + n.frames[0].text })) })))), e(this, "startMove", (e => { if (this.loaded && D(e) && ["touchmove", "mousemove"].includes(e.type) && this.player.media.duration) { if ("touchmove" === e.type) this.seekTime = this.player.media.duration * (this.player.elements.inputs.seek.value / 100); else { var t, i; const n = this.player.elements.progress.getBoundingClientRect(), s = 100 / n.width * (e.pageX - n.left); this.seekTime = this.player.media.duration * (s / 100), this.seekTime < 0 && (this.seekTime = 0), this.seekTime > this.player.media.duration - 1 && (this.seekTime = this.player.media.duration - 1), this.mousePosX = e.pageX, this.elements.thumb.time.innerText = je(this.seekTime); const r = null === (t = this.player.config.markers) || void 0 === t || null === (i = t.points) || void 0 === i ? void 0 : i.find((({ time: e }) => e === Math.round(this.seekTime))); r && this.elements.thumb.time.insertAdjacentHTML("afterbegin", `${r.label}<br>`) } this.showImageAtCurrentTime() } })), e(this, "endMove", (() => { this.toggleThumbContainer(!1, !0) })), e(this, "startScrubbing", (e => { (k(e.button) || !1 === e.button || 0 === e.button) && (this.mouseDown = !0, this.player.media.duration && (this.toggleScrubbingContainer(!0), this.toggleThumbContainer(!1, !0), this.showImageAtCurrentTime())) })), e(this, "endScrubbing", (() => { this.mouseDown = !1, Math.ceil(this.lastTime) === Math.ceil(this.player.media.currentTime) ? this.toggleScrubbingContainer(!1) : pe.call(this.player, this.player.media, "timeupdate", (() => { this.mouseDown || this.toggleScrubbingContainer(!1) })) })), e(this, "listeners", (() => { this.player.on("play", (() => { this.toggleThumbContainer(!1, !0) })), this.player.on("seeked", (() => { this.toggleThumbContainer(!1) })), this.player.on("timeupdate", (() => { this.lastTime = this.player.media.currentTime })) })), e(this, "render", (() => { this.elements.thumb.container = G("div", { class: this.player.config.classNames.previewThumbnails.thumbContainer }), this.elements.thumb.imageContainer = G("div", { class: this.player.config.classNames.previewThumbnails.imageContainer }), this.elements.thumb.container.appendChild(this.elements.thumb.imageContainer); const e = G("div", { class: this.player.config.classNames.previewThumbnails.timeContainer }); this.elements.thumb.time = G("span", {}, "00:00"), e.appendChild(this.elements.thumb.time), this.elements.thumb.imageContainer.appendChild(e), z(this.player.elements.progress) && this.player.elements.progress.appendChild(this.elements.thumb.container), this.elements.scrubbing.container = G("div", { class: this.player.config.classNames.previewThumbnails.scrubbingContainer }), this.player.elements.wrapper.appendChild(this.elements.scrubbing.container) })), e(this, "destroy", (() => { this.elements.thumb.container && this.elements.thumb.container.remove(), this.elements.scrubbing.container && this.elements.scrubbing.container.remove() })), e(this, "showImageAtCurrentTime", (() => { this.mouseDown ? this.setScrubbingContainerSize() : this.setThumbContainerSizeAndPos(); const e = this.thumbnails[0].frames.findIndex((e => this.seekTime >= e.startTime && this.seekTime <= e.endTime)), t = e >= 0; let i = 0; this.mouseDown || this.toggleThumbContainer(t), t && (this.thumbnails.forEach(((t, n) => { this.loadedImages.includes(t.frames[e].text) && (i = n) })), e !== this.showingThumb && (this.showingThumb = e, this.loadImage(i))) })), e(this, "loadImage", ((e = 0) => { const t = this.showingThumb, i = this.thumbnails[e], { urlPrefix: n } = i, s = i.frames[t], r = i.frames[t].text, o = n + r; if (this.currentImageElement && this.currentImageElement.dataset.filename === r) this.showImage(this.currentImageElement, s, e, t, r, !1), this.currentImageElement.dataset.index = t, this.removeOldImages(this.currentImageElement); else { this.loadingImage && this.usingSprites && (this.loadingImage.onload = null); const i = new Image; i.src = o, i.dataset.index = t, i.dataset.filename = r, this.showingThumbFilename = r, this.player.debug.log(`Loading image: ${o}`), i.onload = () => this.showImage(i, s, e, t, r, !0), this.loadingImage = i, this.removeOldImages(i) } })), e(this, "showImage", ((e, t, i, n, s, r = !0) => { this.player.debug.log(`Showing thumb: ${s}. num: ${n}. qual: ${i}. newimg: ${r}`), this.setImageSizeAndOffset(e, t), r && (this.currentImageContainer.appendChild(e), this.currentImageElement = e, this.loadedImages.includes(s) || this.loadedImages.push(s)), this.preloadNearby(n, !0).then(this.preloadNearby(n, !1)).then(this.getHigherQuality(i, e, t, s)) })), e(this, "removeOldImages", (e => { Array.from(this.currentImageContainer.children).forEach((t => { if ("img" !== t.tagName.toLowerCase()) return; const i = this.usingSprites ? 500 : 1e3; if (t.dataset.index !== e.dataset.index && !t.dataset.deleting) { t.dataset.deleting = !0; const { currentImageContainer: e } = this; setTimeout((() => { e.removeChild(t), this.player.debug.log(`Removing thumb: ${t.dataset.filename}`) }), i) } })) })), e(this, "preloadNearby", ((e, t = !0) => new Promise((i => { setTimeout((() => { const n = this.thumbnails[0].frames[e].text; if (this.showingThumbFilename === n) { let s; s = t ? this.thumbnails[0].frames.slice(e) : this.thumbnails[0].frames.slice(0, e).reverse(); let r = !1; s.forEach((e => { const t = e.text; if (t !== n && !this.loadedImages.includes(t)) { r = !0, this.player.debug.log(`Preloading thumb filename: ${t}`); const { urlPrefix: e } = this.thumbnails[0], n = e + t, s = new Image; s.src = n, s.onload = () => { this.player.debug.log(`Preloaded thumb filename: ${t}`), this.loadedImages.includes(t) || this.loadedImages.push(t), i() } } })), r || i() } }), 300) })))), e(this, "getHigherQuality", ((e, t, i, n) => { if (e < this.thumbnails.length - 1) { let s = t.naturalHeight; this.usingSprites && (s = i.h), s < this.thumbContainerHeight && setTimeout((() => { this.showingThumbFilename === n && (this.player.debug.log(`Showing higher quality thumb for: ${n}`), this.loadImage(e + 1)) }), 300) } })), e(this, "toggleThumbContainer", ((e = !1, t = !1) => { const i = this.player.config.classNames.previewThumbnails.thumbContainerShown; this.elements.thumb.container.classList.toggle(i, e), !e && t && (this.showingThumb = null, this.showingThumbFilename = null) })), e(this, "toggleScrubbingContainer", ((e = !1) => { const t = this.player.config.classNames.previewThumbnails.scrubbingContainerShown; this.elements.scrubbing.container.classList.toggle(t, e), e || (this.showingThumb = null, this.showingThumbFilename = null) })), e(this, "determineContainerAutoSizing", (() => { (this.elements.thumb.imageContainer.clientHeight > 20 || this.elements.thumb.imageContainer.clientWidth > 20) && (this.sizeSpecifiedInCSS = !0) })), e(this, "setThumbContainerSizeAndPos", (() => { const { imageContainer: e } = this.elements.thumb; if (this.sizeSpecifiedInCSS) { if (e.clientHeight > 20 && e.clientWidth < 20) { const t = Math.floor(e.clientHeight * this.thumbAspectRatio); e.style.width = `${t}px` } else if (e.clientHeight < 20 && e.clientWidth > 20) { const t = Math.floor(e.clientWidth / this.thumbAspectRatio); e.style.height = `${t}px` } } else { const t = Math.floor(this.thumbContainerHeight * this.thumbAspectRatio); e.style.height = `${this.thumbContainerHeight}px`, e.style.width = `${t}px` } this.setThumbContainerPos() })), e(this, "setThumbContainerPos", (() => { const e = this.player.elements.progress.getBoundingClientRect(), t = this.player.elements.container.getBoundingClientRect(), { container: i } = this.elements.thumb, n = t.left - e.left + 10, s = t.right - e.left - i.clientWidth - 10, r = this.mousePosX - e.left - i.clientWidth / 2, o = lt(r, n, s); i.style.left = `${o}px`, i.style.setProperty("--preview-arrow-offset", r - o + "px") })), e(this, "setScrubbingContainerSize", (() => { const { width: e, height: t } = dt(this.thumbAspectRatio, { width: this.player.media.clientWidth, height: this.player.media.clientHeight }); this.elements.scrubbing.container.style.width = `${e}px`, this.elements.scrubbing.container.style.height = `${t}px` })), e(this, "setImageSizeAndOffset", ((e, t) => { if (!this.usingSprites) return; const i = this.thumbContainerHeight / t.h; e.style.height = e.naturalHeight * i + "px", e.style.width = e.naturalWidth * i + "px", e.style.left = `-${t.x * i}px`, e.style.top = `-${t.y * i}px` })), this.player = t, this.thumbnails = [], this.loaded = !1, this.lastMouseMoveTime = Date.now(), this.mouseDown = !1, this.loadedImages = [], this.elements = { thumb: {}, scrubbing: {} }, this.load() } get enabled() { return this.player.isHTML5 && this.player.isVideo && this.player.config.previewThumbnails.enabled } get currentImageContainer() { return this.mouseDown ? this.elements.scrubbing.container : this.elements.thumb.imageContainer } get usingSprites() { return Object.keys(this.thumbnails[0].frames[0]).includes("w") } get thumbAspectRatio() { return this.usingSprites ? this.thumbnails[0].frames[0].w / this.thumbnails[0].frames[0].h : this.thumbnails[0].width / this.thumbnails[0].height } get thumbContainerHeight() { if (this.mouseDown) { const { height: e } = dt(this.thumbAspectRatio, { width: this.player.media.clientWidth, height: this.player.media.clientHeight }); return e } return this.sizeSpecifiedInCSS ? this.elements.thumb.imageContainer.clientHeight : Math.floor(this.player.media.clientWidth / this.thumbAspectRatio / 4) } get currentImageElement() { return this.mouseDown ? this.currentScrubbingImageElement : this.currentThumbnailImageElement } set currentImageElement(e) { this.mouseDown ? this.currentScrubbingImageElement = e : this.currentThumbnailImageElement = e } } const ht = { insertElements(e, t) { M(t) ? U(e, this.media, { src: t }) : L(t) && t.forEach((t => { U(e, this.media, t) })) }, change(e) { W(e, "sources.length") ? (ke.cancelRequests.call(this), this.destroy.call(this, (() => { this.options.quality = [], Q(this.media), this.media = null, z(this.elements.container) && this.elements.container.removeAttribute("class"); const { sources: t, type: i } = e, [{ provider: n = Ye.html5, src: s }] = t, r = "html5" === n ? i : "div", o = "html5" === n ? {} : { src: s }; Object.assign(this, { provider: n, type: i, supported: le.check(i, n, this.config.playsinline), media: G(r, o) }), this.elements.container.appendChild(this.media), P(e.autoplay) && (this.config.autoplay = e.autoplay), this.isHTML5 && (this.config.crossorigin && this.media.setAttribute("crossorigin", ""), this.config.autoplay && this.media.setAttribute("autoplay", ""), H(e.poster) || (this.poster = e.poster), this.config.loop.active && this.media.setAttribute("loop", ""), this.config.muted && this.media.setAttribute("muted", ""), this.config.playsinline && this.media.setAttribute("playsinline", "")), Ke.addStyleHook.call(this), this.isHTML5 && ht.insertElements.call(this, "source", t), this.config.title = e.title, ot.setup.call(this), this.isHTML5 && Object.keys(e).includes("tracks") && ht.insertElements.call(this, "track", e.tracks), (this.isHTML5 || this.isEmbed && !this.supported.ui) && Ke.build.call(this), this.isHTML5 && this.media.load(), H(e.previewThumbnails) || (Object.assign(this.config.previewThumbnails, e.previewThumbnails), this.previewThumbnails && this.previewThumbnails.loaded && (this.previewThumbnails.destroy(), this.previewThumbnails = null), this.config.previewThumbnails.enabled && (this.previewThumbnails = new ut(this))), this.fullscreen.update() }), !0)) : this.debug.warn("Invalid source format") } }; class pt { constructor(t, i) { if (e(this, "play", (() => I(this.media.play) ? (this.ads && this.ads.enabled && this.ads.managerPromise.then((() => this.ads.play())).catch((() => ve(this.media.play()))), this.media.play()) : null)), e(this, "pause", (() => this.playing && I(this.media.pause) ? this.media.pause() : null)), e(this, "togglePlay", (e => (P(e) ? e : !this.playing) ? this.play() : this.pause())), e(this, "stop", (() => { this.isHTML5 ? (this.pause(), this.restart()) : I(this.media.stop) && this.media.stop() })), e(this, "restart", (() => { this.currentTime = 0 })), e(this, "rewind", (e => { this.currentTime -= $(e) ? e : this.config.seekTime })), e(this, "forward", (e => { this.currentTime += $(e) ? e : this.config.seekTime })), e(this, "increaseVolume", (e => { const t = this.media.muted ? 0 : this.volume; this.volume = t + ($(e) ? e : 0) })), e(this, "decreaseVolume", (e => { this.increaseVolume(-e) })), e(this, "airplay", (() => { le.airplay && this.media.webkitShowPlaybackTargetPicker() })), e(this, "toggleControls", (e => { if (this.supported.ui && !this.isAudio) { const t = ie(this.elements.container, this.config.classNames.hideControls), i = void 0 === e ? void 0 : !e, n = te(this.elements.container, this.config.classNames.hideControls, i); if (n && L(this.config.controls) && this.config.controls.includes("settings") && !H(this.config.settings) && Fe.toggleMenu.call(this, !1), n !== t) { const e = n ? "controlshidden" : "controlsshown"; fe.call(this, this.media, e) } return !n } return !1 })), e(this, "on", ((e, t) => { ue.call(this, this.elements.container, e, t) })), e(this, "once", ((e, t) => { pe.call(this, this.elements.container, e, t) })), e(this, "off", ((e, t) => { he(this.elements.container, e, t) })), e(this, "destroy", ((e, t = !1) => { if (!this.ready) return; const i = () => { document.body.style.overflow = "", this.embed = null, t ? (Object.keys(this.elements).length && (Q(this.elements.buttons.play), Q(this.elements.captions), Q(this.elements.controls), Q(this.elements.wrapper), this.elements.buttons.play = null, this.elements.captions = null, this.elements.controls = null, this.elements.wrapper = null), I(e) && e()) : (me.call(this), ke.cancelRequests.call(this), Z(this.elements.original, this.elements.container), fe.call(this, this.elements.original, "destroyed", !0), I(e) && e.call(this.elements.original), this.ready = !1, setTimeout((() => { this.elements = null, this.media = null }), 200)) }; this.stop(), clearTimeout(this.timers.loading), clearTimeout(this.timers.controls), clearTimeout(this.timers.resized), this.isHTML5 ? (Ke.toggleNativeControls.call(this, !0), i()) : this.isYouTube ? (clearInterval(this.timers.buffering), clearInterval(this.timers.playing), null !== this.embed && I(this.embed.destroy) && this.embed.destroy(), i()) : this.isVimeo && (null !== this.embed && this.embed.unload().then(i), setTimeout(i, 200)) })), e(this, "supports", (e => le.mime.call(this, e))), this.timers = {}, this.ready = !1, this.loading = !1, this.failed = !1, this.touch = le.touch, this.media = t, M(this.media) && (this.media = document.querySelectorAll(this.media)), (window.jQuery && this.media instanceof jQuery || O(this.media) || L(this.media)) && (this.media = this.media[0]), this.config = Y({}, Re, pt.defaults, i || {}, (() => { try { return JSON.parse(this.media.getAttribute("data-plyr-config")) } catch (e) { return {} } })()), this.elements = { container: null, fullscreen: null, captions: null, buttons: {}, display: {}, progress: {}, inputs: {}, settings: { popup: null, menu: null, panels: {}, buttons: {} } }, this.captions = { active: null, currentTrack: -1, meta: new WeakMap }, this.fullscreen = { active: !1 }, this.options = { speed: [], quality: [] }, this.debug = new Ge(this.config.debug), this.debug.log("Config", this.config), this.debug.log("Support", le), k(this.media) || !z(this.media)) return void this.debug.error("Setup failed: no suitable element passed"); if (this.media.plyr) return void this.debug.warn("Target already setup"); if (!this.config.enabled) return void this.debug.error("Setup failed: disabled by config"); if (!le.check().api) return void this.debug.error("Setup failed: no support"); const n = this.media.cloneNode(!0); n.autoplay = !1, this.elements.original = n; const s = this.media.tagName.toLowerCase(); let r = null, o = null; switch (s) { case "div": if (r = this.media.querySelector("iframe"), z(r)) { if (o = He(r.getAttribute("src")), this.provider = function (e) { return /^(https?:\/\/)?(www\.)?(youtube\.com|youtube-nocookie\.com|youtu\.?be)\/.+$/.test(e) ? Ye.youtube : /^https?:\/\/player.vimeo.com\/video\/\d{0,9}(?=\b|\/)/.test(e) ? Ye.vimeo : null }(o.toString()), this.elements.container = this.media, this.media = r, this.elements.container.className = "", o.search.length) { const e = ["1", "true"]; e.includes(o.searchParams.get("autoplay")) && (this.config.autoplay = !0), e.includes(o.searchParams.get("loop")) && (this.config.loop.active = !0), this.isYouTube ? (this.config.playsinline = e.includes(o.searchParams.get("playsinline")), this.config.youtube.hl = o.searchParams.get("hl")) : this.config.playsinline = !0 } } else this.provider = this.media.getAttribute(this.config.attributes.embed.provider), this.media.removeAttribute(this.config.attributes.embed.provider); if (H(this.provider) || !Object.values(Ye).includes(this.provider)) return void this.debug.error("Setup failed: Invalid provider"); this.type = Xe; break; case "video": case "audio": this.type = s, this.provider = Ye.html5, this.media.hasAttribute("crossorigin") && (this.config.crossorigin = !0), this.media.hasAttribute("autoplay") && (this.config.autoplay = !0), (this.media.hasAttribute("playsinline") || this.media.hasAttribute("webkit-playsinline")) && (this.config.playsinline = !0), this.media.hasAttribute("muted") && (this.config.muted = !0), this.media.hasAttribute("loop") && (this.config.loop.active = !0); break; default: return void this.debug.error("Setup failed: unsupported type") }this.supported = le.check(this.type, this.provider, this.config.playsinline), this.supported.api ? (this.eventListeners = [], this.listeners = new Ze(this), this.storage = new Oe(this), this.media.plyr = this, z(this.elements.container) || (this.elements.container = G("div", { tabindex: 0 }), X(this.media, this.elements.container)), Ke.migrateStyles.call(this), Ke.addStyleHook.call(this), ot.setup.call(this), this.config.debug && ue.call(this, this.elements.container, this.config.events.join(" "), (e => { this.debug.log(`event: ${e.type}`) })), this.fullscreen = new Ue(this), (this.isHTML5 || this.isEmbed && !this.supported.ui) && Ke.build.call(this), this.listeners.container(), this.listeners.global(), this.config.ads.enabled && (this.ads = new at(this)), this.isHTML5 && this.config.autoplay && this.once("canplay", (() => ve(this.play()))), this.lastSeekTime = 0, this.config.previewThumbnails.enabled && (this.previewThumbnails = new ut(this))) : this.debug.error("Setup failed: no support") } get isHTML5() { return this.provider === Ye.html5 } get isEmbed() { return this.isYouTube || this.isVimeo } get isYouTube() { return this.provider === Ye.youtube } get isVimeo() { return this.provider === Ye.vimeo } get isVideo() { return this.type === Xe } get isAudio() { return "audio" === this.type } get playing() { return Boolean(this.ready && !this.paused && !this.ended) } get paused() { return Boolean(this.media.paused) } get stopped() { return Boolean(this.paused && 0 === this.currentTime) } get ended() { return Boolean(this.media.ended) } set currentTime(e) { if (!this.duration) return; const t = $(e) && e > 0; this.media.currentTime = t ? Math.min(e, this.duration) : 0, this.debug.log(`Seeking to ${this.currentTime} seconds`) } get currentTime() { return Number(this.media.currentTime) } get buffered() { const { buffered: e } = this.media; return $(e) ? e : e && e.length && this.duration > 0 ? e.end(0) / this.duration : 0 } get seeking() { return Boolean(this.media.seeking) } get duration() { const e = parseFloat(this.config.duration), t = (this.media || {}).duration, i = $(t) && t !== 1 / 0 ? t : 0; return e || i } set volume(e) { let t = e; M(t) && (t = Number(t)), $(t) || (t = this.storage.get("volume")), $(t) || ({ volume: t } = this.config), t > 1 && (t = 1), t < 0 && (t = 0), this.config.volume = t, this.media.volume = t, !H(e) && this.muted && t > 0 && (this.muted = !1) } get volume() { return Number(this.media.volume) } set muted(e) { let t = e; P(t) || (t = this.storage.get("muted")), P(t) || (t = this.config.muted), this.config.muted = t, this.media.muted = t } get muted() { return Boolean(this.media.muted) } get hasAudio() { return !this.isHTML5 || !!this.isAudio || Boolean(this.media.mozHasAudio) || Boolean(this.media.webkitAudioDecodedByteCount) || Boolean(this.media.audioTracks && this.media.audioTracks.length) } set speed(e) { let t = null; $(e) && (t = e), $(t) || (t = this.storage.get("speed")), $(t) || (t = this.config.speed.selected); const { minimumSpeed: i, maximumSpeed: n } = this; t = lt(t, i, n), this.config.speed.selected = t, setTimeout((() => { this.media && (this.media.playbackRate = t) }), 0) } get speed() { return Number(this.media.playbackRate) } get minimumSpeed() { return this.isYouTube ? Math.min(...this.options.speed) : this.isVimeo ? .5 : .0625 } get maximumSpeed() { return this.isYouTube ? Math.max(...this.options.speed) : this.isVimeo ? 2 : 16 } set quality(e) { const t = this.config.quality, i = this.options.quality; if (!i.length) return; let n = [!H(e) && Number(e), this.storage.get("quality"), t.selected, t.default].find($), s = !0; if (!i.includes(n)) { const e = be(i, n); this.debug.warn(`Unsupported quality option: ${n}, using ${e} instead`), n = e, s = !1 } t.selected = n, this.media.quality = n, s && this.storage.set({ quality: n }) } get quality() { return this.media.quality } set loop(e) { const t = P(e) ? e : this.config.loop.active; this.config.loop.active = t, this.media.loop = t } get loop() { return Boolean(this.media.loop) } set source(e) { ht.change.call(this, e) } get source() { return this.media.currentSrc } get download() { const { download: e } = this.config.urls; return F(e) ? e : this.source } set download(e) { F(e) && (this.config.urls.download = e, Fe.setDownloadUrl.call(this)) } set poster(e) { this.isVideo ? Ke.setPoster.call(this, e, !1).catch((() => { })) : this.debug.warn("Poster can only be set for video") } get poster() { return this.isVideo ? this.media.getAttribute("poster") || this.media.getAttribute("data-poster") : null } get ratio() { if (!this.isVideo) return null; const e = Te(Ee.call(this)); return L(e) ? e.join(":") : e } set ratio(e) { this.isVideo ? M(e) && _e(e) ? (this.config.ratio = Te(e), Se.call(this)) : this.debug.error(`Invalid aspect ratio specified (${e})`) : this.debug.warn("Aspect ratio can only be set for video") } set autoplay(e) { this.config.autoplay = P(e) ? e : this.config.autoplay } get autoplay() { return Boolean(this.config.autoplay) } toggleCaptions(e) { Be.toggle.call(this, e, !1) } set currentTrack(e) { Be.set.call(this, e, !1), Be.setup.call(this) } get currentTrack() { const { toggled: e, currentTrack: t } = this.captions; return e ? t : -1 } set language(e) { Be.setLanguage.call(this, e, !1) } get language() { return (Be.getCurrentTrack.call(this) || {}).language } set pip(e) { if (!le.pip) return; const t = P(e) ? e : !this.pip; I(this.media.webkitSetPresentationMode) && this.media.webkitSetPresentationMode(t ? We : "inline"), I(this.media.requestPictureInPicture) && (!this.pip && t ? this.media.requestPictureInPicture() : this.pip && !t && document.exitPictureInPicture()) } get pip() { return le.pip ? H(this.media.webkitPresentationMode) ? this.media === document.pictureInPictureElement : this.media.webkitPresentationMode === We : null } setPreviewThumbnails(e) { this.previewThumbnails && this.previewThumbnails.loaded && (this.previewThumbnails.destroy(), this.previewThumbnails = null), Object.assign(this.config.previewThumbnails, e), this.config.previewThumbnails.enabled && (this.previewThumbnails = new ut(this)) } static supported(e, t, i) { return le.check(e, t, i) } static loadSprite(e, t) { return De(e, t) } static setup(e, t = {}) { let i = null; return M(e) ? i = Array.from(document.querySelectorAll(e)) : O(e) ? i = Array.from(e) : L(e) && (i = e.filter(z)), H(i) ? null : i.map((e => new pt(e, t))) } } var ft; return pt.defaults = (ft = Re, JSON.parse(JSON.stringify(ft))), pt })); var _self = "undefined" != typeof window ? window : "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope ? self : {}, Prism = function (e) { var t = /\blang(?:uage)?-([\w-]+)\b/i, i = 0, n = {}, s = { manual: e.Prism && e.Prism.manual, disableWorkerMessageHandler: e.Prism && e.Prism.disableWorkerMessageHandler, util: { encode: function e(t) { return t instanceof r ? new r(t.type, e(t.content), t.alias) : Array.isArray(t) ? t.map(e) : t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ") }, type: function (e) { return Object.prototype.toString.call(e).slice(8, -1) }, objId: function (e) { return e.__id || Object.defineProperty(e, "__id", { value: ++i }), e.__id }, clone: function e(t, i) { var n, r; switch (i = i || {}, s.util.type(t)) { case "Object": if (r = s.util.objId(t), i[r]) return i[r]; for (var o in n = {}, i[r] = n, t) t.hasOwnProperty(o) && (n[o] = e(t[o], i)); return n; case "Array": return r = s.util.objId(t), i[r] ? i[r] : (n = [], i[r] = n, t.forEach((function (t, s) { n[s] = e(t, i) })), n); default: return t } }, getLanguage: function (e) { for (; e && !t.test(e.className);)e = e.parentElement; return e ? (e.className.match(t) || [, "none"])[1].toLowerCase() : "none" }, currentScript: function () { if ("undefined" == typeof document) return null; if ("currentScript" in document) return document.currentScript; try { throw new Error } catch (n) { var e = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(n.stack) || [])[1]; if (e) { var t = document.getElementsByTagName("script"); for (var i in t) if (t[i].src == e) return t[i] } return null } }, isActive: function (e, t, i) { for (var n = "no-" + t; e;) { var s = e.classList; if (s.contains(t)) return !0; if (s.contains(n)) return !1; e = e.parentElement } return !!i } }, languages: { plain: n, plaintext: n, text: n, txt: n, extend: function (e, t) { var i = s.util.clone(s.languages[e]); for (var n in t) i[n] = t[n]; return i }, insertBefore: function (e, t, i, n) { var r = (n = n || s.languages)[e], o = {}; for (var a in r) if (r.hasOwnProperty(a)) { if (a == t) for (var l in i) i.hasOwnProperty(l) && (o[l] = i[l]); i.hasOwnProperty(a) || (o[a] = r[a]) } var c = n[e]; return n[e] = o, s.languages.DFS(s.languages, (function (t, i) { i === c && t != e && (this[t] = o) })), o }, DFS: function e(t, i, n, r) { r = r || {}; var o = s.util.objId; for (var a in t) if (t.hasOwnProperty(a)) { i.call(t, a, t[a], n || a); var l = t[a], c = s.util.type(l); "Object" !== c || r[o(l)] ? "Array" !== c || r[o(l)] || (r[o(l)] = !0, e(l, i, a, r)) : (r[o(l)] = !0, e(l, i, null, r)) } } }, plugins: {}, highlightAll: function (e, t) { s.highlightAllUnder(document, e, t) }, highlightAllUnder: function (e, t, i) { var n = { callback: i, container: e, selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code' }; s.hooks.run("before-highlightall", n), n.elements = Array.prototype.slice.apply(n.container.querySelectorAll(n.selector)), s.hooks.run("before-all-elements-highlight", n); for (var r, o = 0; r = n.elements[o++];)s.highlightElement(r, !0 === t, n.callback) }, highlightElement: function (i, n, r) { var o = s.util.getLanguage(i), a = s.languages[o]; i.className = i.className.replace(t, "").replace(/\s+/g, " ") + " language-" + o; var l = i.parentElement; l && "pre" === l.nodeName.toLowerCase() && (l.className = l.className.replace(t, "").replace(/\s+/g, " ") + " language-" + o); var c = { element: i, language: o, grammar: a, code: i.textContent }; function d(e) { c.highlightedCode = e, s.hooks.run("before-insert", c), c.element.innerHTML = c.highlightedCode, s.hooks.run("after-highlight", c), s.hooks.run("complete", c), r && r.call(c.element) } if (s.hooks.run("before-sanity-check", c), (l = c.element.parentElement) && "pre" === l.nodeName.toLowerCase() && !l.hasAttribute("tabindex") && l.setAttribute("tabindex", "0"), !c.code) return s.hooks.run("complete", c), void (r && r.call(c.element)); if (s.hooks.run("before-highlight", c), c.grammar) if (n && e.Worker) { var u = new Worker(s.filename); u.onmessage = function (e) { d(e.data) }, u.postMessage(JSON.stringify({ language: c.language, code: c.code, immediateClose: !0 })) } else d(s.highlight(c.code, c.grammar, c.language)); else d(s.util.encode(c.code)) }, highlight: function (e, t, i) { var n = { code: e, grammar: t, language: i }; return s.hooks.run("before-tokenize", n), n.tokens = s.tokenize(n.code, n.grammar), s.hooks.run("after-tokenize", n), r.stringify(s.util.encode(n.tokens), n.language) }, tokenize: function (e, t) { var i = t.rest; if (i) { for (var n in i) t[n] = i[n]; delete t.rest } var d = new a; return l(d, d.head, e), function e(t, i, n, a, d, u) { for (var h in n) if (n.hasOwnProperty(h) && n[h]) { var p = n[h]; p = Array.isArray(p) ? p : [p]; for (var f = 0; f < p.length; ++f) { if (u && u.cause == h + "," + f) return; var m = p[f], g = m.inside, v = !!m.lookbehind, y = !!m.greedy, b = m.alias; if (y && !m.pattern.global) { var w = m.pattern.toString().match(/[imsuy]*$/)[0]; m.pattern = RegExp(m.pattern.source, w + "g") } for (var x = m.pattern || m, _ = a.next, T = d; _ !== i.tail && !(u && T >= u.reach); T += _.value.length, _ = _.next) { var E = _.value; if (i.length > t.length) return; if (!(E instanceof r)) { var S, C = 1; if (y) { if (!(S = o(x, T, t, v))) break; var k = S.index, A = S.index + S[0].length, $ = T; for ($ += _.value.length; $ <= k;)$ += (_ = _.next).value.length; if (T = $ -= _.value.length, _.value instanceof r) continue; for (var M = _; M !== i.tail && ($ < A || "string" == typeof M.value); M = M.next)C++, $ += M.value.length; C--, E = t.slice(T, $), S.index -= T } else if (!(S = o(x, 0, E, v))) continue; k = S.index; var P = S[0], I = E.slice(0, k), L = E.slice(k + P.length), O = T + E.length; u && O > u.reach && (u.reach = O); var z = _.prev; if (I && (z = l(i, z, I), T += I.length), c(i, z, C), _ = l(i, z, new r(h, g ? s.tokenize(P, g) : P, b, P)), L && l(i, _, L), 1 < C) { var D = { cause: h + "," + f, reach: O }; e(t, i, n, _.prev, T, D), u && D.reach > u.reach && (u.reach = D.reach) } } } } } }(e, d, t, d.head, 0), function (e) { for (var t = [], i = e.head.next; i !== e.tail;)t.push(i.value), i = i.next; return t }(d) }, hooks: { all: {}, add: function (e, t) { var i = s.hooks.all; i[e] = i[e] || [], i[e].push(t) }, run: function (e, t) { var i = s.hooks.all[e]; if (i && i.length) for (var n, r = 0; n = i[r++];)n(t) } }, Token: r }; function r(e, t, i, n) { this.type = e, this.content = t, this.alias = i, this.length = 0 | (n || "").length } function o(e, t, i, n) { e.lastIndex = t; var s = e.exec(i); if (s && n && s[1]) { var r = s[1].length; s.index += r, s[0] = s[0].slice(r) } return s } function a() { var e = { value: null, prev: null, next: null }, t = { value: null, prev: e, next: null }; e.next = t, this.head = e, this.tail = t, this.length = 0 } function l(e, t, i) { var n = t.next, s = { value: i, prev: t, next: n }; return t.next = s, n.prev = s, e.length++, s } function c(e, t, i) { for (var n = t.next, s = 0; s < i && n !== e.tail; s++)n = n.next; (t.next = n).prev = t, e.length -= s } if (e.Prism = s, r.stringify = function e(t, i) { if ("string" == typeof t) return t; if (Array.isArray(t)) { var n = ""; return t.forEach((function (t) { n += e(t, i) })), n } var r = { type: t.type, content: e(t.content, i), tag: "span", classes: ["token", t.type], attributes: {}, language: i }, o = t.alias; o && (Array.isArray(o) ? Array.prototype.push.apply(r.classes, o) : r.classes.push(o)), s.hooks.run("wrap", r); var a = ""; for (var l in r.attributes) a += " " + l + '="' + (r.attributes[l] || "").replace(/"/g, "&quot;") + '"'; return "<" + r.tag + ' class="' + r.classes.join(" ") + '"' + a + ">" + r.content + "</" + r.tag + ">" }, !e.document) return e.addEventListener && (s.disableWorkerMessageHandler || e.addEventListener("message", (function (t) { var i = JSON.parse(t.data), n = i.language, r = i.code, o = i.immediateClose; e.postMessage(s.highlight(r, s.languages[n], n)), o && e.close() }), !1)), s; var d = s.util.currentScript(); function u() { s.manual || s.highlightAll() } if (d && (s.filename = d.src, d.hasAttribute("data-manual") && (s.manual = !0)), !s.manual) { var h = document.readyState; "loading" === h || "interactive" === h && d && d.defer ? document.addEventListener("DOMContentLoaded", u) : window.requestAnimationFrame ? window.requestAnimationFrame(u) : window.setTimeout(u, 16) } return s }(_self); "undefined" != typeof module && module.exports && (module.exports = Prism), "undefined" != typeof global && (global.Prism = Prism), Prism.languages.markup = { comment: /<!--[\s\S]*?-->/, prolog: /<\?[\s\S]+?\?>/, doctype: { pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i, greedy: !0, inside: { "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: !0, greedy: !0, inside: null }, string: { pattern: /"[^"]*"|'[^']*'/, greedy: !0 }, punctuation: /^<!|>$|[[\]]/, "doctype-tag": /^DOCTYPE/, name: /[^\s<>'"]+/ } }, cdata: /<!\[CDATA\[[\s\S]*?\]\]>/i, tag: { pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/, greedy: !0, inside: { tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, "special-attr": [], "attr-value": { pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, inside: { punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/] } }, punctuation: /\/?>/, "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i] }, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", (function (e) { "entity" === e.type && (e.attributes.title = e.content.replace(/&amp;/, "&")) })), Object.defineProperty(Prism.languages.markup.tag, "addInlined", { value: function (e, t) { var i = {}; i["language-" + t] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: !0, inside: Prism.languages[t] }, i.cdata = /^<!\[CDATA\[|\]\]>$/i; var n = { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: i } }; n["language-" + t] = { pattern: /[\s\S]+/, inside: Prism.languages[t] }; var s = {}; s[e] = { pattern: RegExp("(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[^])*?(?=</__>)".replace(/__/g, (function () { return e })), "i"), lookbehind: !0, greedy: !0, inside: n }, Prism.languages.insertBefore("markup", "cdata", s) } }), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", { value: function (e, t) { Prism.languages.markup.tag.inside["special-attr"].push({ pattern: RegExp("(^|[\"'\\s])(?:" + e + ")\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))", "i"), lookbehind: !0, inside: { "attr-name": /^[^\s=]+/, "attr-value": { pattern: /=[\s\S]+/, inside: { value: { pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/, lookbehind: !0, alias: [t, "language-" + t], inside: Prism.languages[t] }, punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/] } } } }) } }), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml, function (e) { var t = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/; e.languages.css = { comment: /\/\*[\s\S]*?\*\//, atrule: { pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/, inside: { rule: /^@[\w-]+/, "selector-function-argument": { pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/, lookbehind: !0, alias: "selector" }, keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: !0 } } }, url: { pattern: RegExp("\\burl\\((?:" + t.source + "|(?:[^\\\\\r\n()\"']|\\\\[^])*)\\)", "i"), greedy: !0, inside: { function: /^url/i, punctuation: /^\(|\)$/, string: { pattern: RegExp("^" + t.source + "$"), alias: "url" } } }, selector: { pattern: RegExp("(^|[{}\\s])[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|" + t.source + ")*(?=\\s*\\{)"), lookbehind: !0 }, string: { pattern: t, greedy: !0 }, property: { pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i, lookbehind: !0 }, important: /!important\b/i, function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: !0 }, punctuation: /[(){};:,]/ }, e.languages.css.atrule.inside.rest = e.languages.css; var i = e.languages.markup; i && (i.tag.addInlined("style", "css"), i.tag.addAttribute("style", "css")) }(Prism), Prism.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: !0, greedy: !0 }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: !0 }, "class-name": { pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i, lookbehind: !0, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\b\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/, punctuation: /[{}[\];(),.:]/ }, Prism.languages.javascript = Prism.languages.extend("clike", { "class-name": [Prism.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:prototype|constructor))/, lookbehind: !0 }], keyword: [{ pattern: /((?:^|\})\s*)catch\b/, lookbehind: !0 }, { pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: !0 }], function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/ }), Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/, Prism.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/, lookbehind: !0, greedy: !0, inside: { "regex-source": { pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/, lookbehind: !0, alias: "language-regex", inside: Prism.languages.regex }, "regex-delimiter": /^\/|\/$/, "regex-flags": /^[a-z]+$/ } }, "function-variable": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/, lookbehind: !0, inside: Prism.languages.javascript }, { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i, lookbehind: !0, inside: Prism.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/, lookbehind: !0, inside: Prism.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/, lookbehind: !0, inside: Prism.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ }), Prism.languages.insertBefore("javascript", "string", { hashbang: { pattern: /^#!.*/, greedy: !0, alias: "comment" }, "template-string": { pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/, greedy: !0, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/, lookbehind: !0, inside: { "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" }, rest: Prism.languages.javascript } }, string: /[\s\S]+/ } } }), Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"), Prism.languages.markup.tag.addAttribute("on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)", "javascript")), Prism.languages.js = Prism.languages.javascript, function (e) { function t(e, t) { return "___" + e.toUpperCase() + t + "___" } Object.defineProperties(e.languages["markup-templating"] = {}, { buildPlaceholders: { value: function (i, n, s, r) { if (i.language === n) { var o = i.tokenStack = []; i.code = i.code.replace(s, (function (e) { if ("function" == typeof r && !r(e)) return e; for (var s, a = o.length; -1 !== i.code.indexOf(s = t(n, a));)++a; return o[a] = e, s })), i.grammar = e.languages.markup } } }, tokenizePlaceholders: { value: function (i, n) { if (i.language === n && i.tokenStack) { i.grammar = e.languages[n]; var s = 0, r = Object.keys(i.tokenStack); !function o(a) { for (var l = 0; l < a.length && !(s >= r.length); l++) { var c = a[l]; if ("string" == typeof c || c.content && "string" == typeof c.content) { var d = r[s], u = i.tokenStack[d], h = "string" == typeof c ? c : c.content, p = t(n, d), f = h.indexOf(p); if (-1 < f) { ++s; var m = h.substring(0, f), g = new e.Token(n, e.tokenize(u, i.grammar), "language-" + n, u), v = h.substring(f + p.length), y = []; m && y.push.apply(y, o([m])), y.push(g), v && y.push.apply(y, o([v])), "string" == typeof c ? a.splice.apply(a, [l, 1].concat(y)) : c.content = y } } else c.content && o(c.content) } return a }(i.tokens) } } } }) }(Prism), function (e) { var t = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/, i = [{ pattern: /\b(?:false|true)\b/i, alias: "boolean" }, { pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i, greedy: !0, lookbehind: !0 }, { pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i, greedy: !0, lookbehind: !0 }, /\b(?:null)\b/i, /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/], n = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i, s = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/, r = /[{}\[\](),:;]/; e.languages.php = { delimiter: { pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i, alias: "important" }, comment: t, variable: /\$+(?:\w+\b|(?=\{))/i, package: { pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i, lookbehind: !0, inside: { punctuation: /\\/ } }, "class-name-definition": { pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i, lookbehind: !0, alias: "class-name" }, "function-definition": { pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i, lookbehind: !0, alias: "function" }, keyword: [{ pattern: /(\(\s*)\b(?:bool|boolean|int|integer|float|string|object|array)\b(?=\s*\))/i, alias: "type-casting", greedy: !0, lookbehind: !0 }, { pattern: /([(,?]\s*)\b(?:bool|int|float|string|object|array(?!\s*\()|mixed|self|static|callable|iterable|(?:null|false)(?=\s*\|))\b(?=\s*\$)/i, alias: "type-hint", greedy: !0, lookbehind: !0 }, { pattern: /([(,?]\s*[\w|]\|\s*)(?:null|false)\b(?=\s*\$)/i, alias: "type-hint", greedy: !0, lookbehind: !0 }, { pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:bool|int|float|string|object|void|array(?!\s*\()|mixed|self|static|callable|iterable|(?:null|false)(?=\s*\|))\b/i, alias: "return-type", greedy: !0, lookbehind: !0 }, { pattern: /(\)\s*:\s*(?:\?\s*)?[\w|]\|\s*)(?:null|false)\b/i, alias: "return-type", greedy: !0, lookbehind: !0 }, { pattern: /\b(?:bool|int|float|string|object|void|array(?!\s*\()|mixed|iterable|(?:null|false)(?=\s*\|))\b/i, alias: "type-declaration", greedy: !0 }, { pattern: /(\|\s*)(?:null|false)\b/i, alias: "type-declaration", greedy: !0, lookbehind: !0 }, { pattern: /\b(?:parent|self|static)(?=\s*::)/i, alias: "static-context", greedy: !0 }, { pattern: /(\byield\s+)from\b/i, lookbehind: !0 }, /\bclass\b/i, { pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:__halt_compiler|abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|namespace|match|new|or|parent|print|private|protected|public|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield)\b/i, lookbehind: !0 }], "argument-name": { pattern: /([(,]\s+)\b[a-z_]\w*(?=\s*:(?!:))/i, lookbehind: !0 }, "class-name": [{ pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i, greedy: !0, lookbehind: !0 }, { pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i, greedy: !0, lookbehind: !0 }, { pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i, greedy: !0 }, { pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i, alias: "class-name-fully-qualified", greedy: !0, lookbehind: !0, inside: { punctuation: /\\/ } }, { pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i, alias: "class-name-fully-qualified", greedy: !0, inside: { punctuation: /\\/ } }, { pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i, alias: "class-name-fully-qualified", greedy: !0, lookbehind: !0, inside: { punctuation: /\\/ } }, { pattern: /\b[a-z_]\w*(?=\s*\$)/i, alias: "type-declaration", greedy: !0 }, { pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i, alias: ["class-name-fully-qualified", "type-declaration"], greedy: !0, inside: { punctuation: /\\/ } }, { pattern: /\b[a-z_]\w*(?=\s*::)/i, alias: "static-context", greedy: !0 }, { pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i, alias: ["class-name-fully-qualified", "static-context"], greedy: !0, inside: { punctuation: /\\/ } }, { pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i, alias: "type-hint", greedy: !0, lookbehind: !0 }, { pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i, alias: ["class-name-fully-qualified", "type-hint"], greedy: !0, lookbehind: !0, inside: { punctuation: /\\/ } }, { pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i, alias: "return-type", greedy: !0, lookbehind: !0 }, { pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i, alias: ["class-name-fully-qualified", "return-type"], greedy: !0, lookbehind: !0, inside: { punctuation: /\\/ } }], constant: i, function: { pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i, lookbehind: !0, inside: { punctuation: /\\/ } }, property: { pattern: /(->\s*)\w+/, lookbehind: !0 }, number: n, operator: s, punctuation: r }; var o = { pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/, lookbehind: !0, inside: e.languages.php }, a = [{ pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/, alias: "nowdoc-string", greedy: !0, inside: { delimiter: { pattern: /^<<<'[^']+'|[a-z_]\w*;$/i, alias: "symbol", inside: { punctuation: /^<<<'?|[';]$/ } } } }, { pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i, alias: "heredoc-string", greedy: !0, inside: { delimiter: { pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i, alias: "symbol", inside: { punctuation: /^<<<"?|[";]$/ } }, interpolation: o } }, { pattern: /`(?:\\[\s\S]|[^\\`])*`/, alias: "backtick-quoted-string", greedy: !0 }, { pattern: /'(?:\\[\s\S]|[^\\'])*'/, alias: "single-quoted-string", greedy: !0 }, { pattern: /"(?:\\[\s\S]|[^\\"])*"/, alias: "double-quoted-string", greedy: !0, inside: { interpolation: o } }]; e.languages.insertBefore("php", "variable", { string: a, attribute: { pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im, greedy: !0, inside: { "attribute-content": { pattern: /^(#\[)[\s\S]+(?=\]$)/, lookbehind: !0, inside: { comment: t, string: a, "attribute-class-name": [{ pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i, alias: "class-name", greedy: !0, lookbehind: !0 }, { pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i, alias: ["class-name", "class-name-fully-qualified"], greedy: !0, lookbehind: !0, inside: { punctuation: /\\/ } }], constant: i, number: n, operator: s, punctuation: r } }, delimiter: { pattern: /^#\[|\]$/, alias: "punctuation" } } } }), e.hooks.add("before-tokenize", (function (t) { /<\?/.test(t.code) && e.languages["markup-templating"].buildPlaceholders(t, "php", /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/gi) })), e.hooks.add("after-tokenize", (function (t) { e.languages["markup-templating"].tokenizePlaceholders(t, "php") })) }(Prism), function (e) { e.languages.sass = e.languages.extend("css", { comment: { pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m, lookbehind: !0, greedy: !0 } }), e.languages.insertBefore("sass", "atrule", { "atrule-line": { pattern: /^(?:[ \t]*)[@+=].+/m, greedy: !0, inside: { atrule: /(?:@[\w-]+|[+=])/m } } }), delete e.languages.sass.atrule; var t = /\$[-\w]+|#\{\$[-\w]+\}/, i = [/[+*\/%]|[=!]=|<=?|>=?|\b(?:and|or|not)\b/, { pattern: /(\s)-(?=\s)/, lookbehind: !0 }]; e.languages.insertBefore("sass", "property", { "variable-line": { pattern: /^[ \t]*\$.+/m, greedy: !0, inside: { punctuation: /:/, variable: t, operator: i } }, "property-line": { pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m, greedy: !0, inside: { property: [/[^:\s]+(?=\s*:)/, { pattern: /(:)[^:\s]+/, lookbehind: !0 }], punctuation: /:/, variable: t, operator: i, important: e.languages.sass.important } } }), delete e.languages.sass.property, delete e.languages.sass.important, e.languages.insertBefore("sass", "punctuation", { selector: { pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m, lookbehind: !0, greedy: !0 } }) }(Prism), Prism.languages.scss = Prism.languages.extend("css", { comment: { pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/, lookbehind: !0 }, atrule: { pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/, inside: { rule: /@[\w-]+/ } }, url: /(?:[-a-z]+-)?url(?=\()/i, selector: { pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/m, inside: { parent: { pattern: /&/, alias: "important" }, placeholder: /%[-\w]+/, variable: /\$[-\w]+|#\{\$[-\w]+\}/ } }, property: { pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/, inside: { variable: /\$[-\w]+|#\{\$[-\w]+\}/ } } }), Prism.languages.insertBefore("scss", "atrule", { keyword: [/@(?:if|else(?: if)?|forward|for|each|while|import|use|extend|debug|warn|mixin|include|function|return|content)\b/i, { pattern: /( )(?:from|through)(?= )/, lookbehind: !0 }] }), Prism.languages.insertBefore("scss", "important", { variable: /\$[-\w]+|#\{\$[-\w]+\}/ }), Prism.languages.insertBefore("scss", "function", { "module-modifier": { pattern: /\b(?:as|with|show|hide)\b/i, alias: "keyword" }, placeholder: { pattern: /%[-\w]+/, alias: "selector" }, statement: { pattern: /\B!(?:default|optional)\b/i, alias: "keyword" }, boolean: /\b(?:true|false)\b/, null: { pattern: /\bnull\b/, alias: "keyword" }, operator: { pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|or|not)(?=\s)/, lookbehind: !0 } }), Prism.languages.scss.atrule.inside.rest = Prism.languages.scss, function (e) { if ("object" == typeof exports && "undefined" != typeof module) module.exports = e(); else if ("function" == typeof define && define.amd) define([], e); else { ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).ProgressBar = e() } }((function () { return function e(t, i, n) { function s(o, a) { if (!i[o]) { if (!t[o]) { var l = "function" == typeof require && require; if (!a && l) return l(o, !0); if (r) return r(o, !0); var c = new Error("Cannot find module '" + o + "'"); throw c.code = "MODULE_NOT_FOUND", c } var d = i[o] = { exports: {} }; t[o][0].call(d.exports, (function (e) { var i = t[o][1][e]; return s(i || e) }), d, d.exports, e, t, i, n) } return i[o].exports } for (var r = "function" == typeof require && require, o = 0; o < n.length; o++)s(n[o]); return s }({ 1: [function (e, t, i) { (function () { var e = this || Function("return this")(), n = function () { "use strict"; function n() { } function s(e, t) { var i; for (i in e) Object.hasOwnProperty.call(e, i) && t(i) } function r(e, t) { return s(t, (function (i) { e[i] = t[i] })), e } function o(e, t) { s(t, (function (i) { void 0 === e[i] && (e[i] = t[i]) })) } function a(e, t, i, n, s, r, o) { var a, c, d, u = r > e ? 0 : (e - r) / s; for (a in t) t.hasOwnProperty(a) && (d = "function" == typeof (c = o[a]) ? c : p[c], t[a] = l(i[a], n[a], d, u)); return t } function l(e, t, i, n) { return e + (t - e) * i(n) } function c(e, t) { var i = h.prototype.filter, n = e._filterArgs; s(i, (function (s) { void 0 !== i[s][t] && i[s][t].apply(e, n) })) } function d(e, t, i, n, s, r, o, l, d, u, h) { m = t + i + n, g = Math.min(h || _(), m), v = g >= m, y = n - (m - g), e.isPlaying() && (v ? (d(o, e._attachment, y), e.stop(!0)) : (e._scheduleId = u(e._timeoutHandler, w), c(e, "beforeTween"), t + i > g ? a(1, s, r, o, 1, 1, l) : a(g, s, r, o, n, t + i, l), c(e, "afterTween"), d(s, e._attachment, y))) } function u(e, t) { var i = {}, n = typeof t; return s(e, "string" === n || "function" === n ? function (e) { i[e] = t } : function (e) { i[e] || (i[e] = t[e] || b) }), i } function h(e, t) { this._currentState = e || {}, this._configured = !1, this._scheduleFunction = f, void 0 !== t && this.setConfig(t) } var p, f, m, g, v, y, b = "linear", w = 1e3 / 60, x = Date.now ? Date.now : function () { return +new Date }, _ = "undefined" != typeof SHIFTY_DEBUG_NOW ? SHIFTY_DEBUG_NOW : x; return f = "undefined" != typeof window && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || window.mozCancelRequestAnimationFrame && window.mozRequestAnimationFrame) || setTimeout, h.prototype.tween = function (e) { return this._isTweening ? this : (void 0 === e && this._configured || this.setConfig(e), this._timestamp = _(), this._start(this.get(), this._attachment), this.resume()) }, h.prototype.setConfig = function (e) { e = e || {}, this._configured = !0, this._attachment = e.attachment, this._pausedAtTime = null, this._scheduleId = null, this._delay = e.delay || 0, this._start = e.start || n, this._step = e.step || n, this._finish = e.finish || n, this._duration = e.duration || 500, this._currentState = r({}, e.from) || this.get(), this._originalState = this.get(), this._targetState = r({}, e.to) || this.get(); var t = this; this._timeoutHandler = function () { d(t, t._timestamp, t._delay, t._duration, t._currentState, t._originalState, t._targetState, t._easing, t._step, t._scheduleFunction) }; var i = this._currentState, s = this._targetState; return o(s, i), this._easing = u(i, e.easing || b), this._filterArgs = [i, this._originalState, s, this._easing], c(this, "tweenCreated"), this }, h.prototype.get = function () { return r({}, this._currentState) }, h.prototype.set = function (e) { this._currentState = e }, h.prototype.pause = function () { return this._pausedAtTime = _(), this._isPaused = !0, this }, h.prototype.resume = function () { return this._isPaused && (this._timestamp += _() - this._pausedAtTime), this._isPaused = !1, this._isTweening = !0, this._timeoutHandler(), this }, h.prototype.seek = function (e) { e = Math.max(e, 0); var t = _(); return this._timestamp + e === 0 || (this._timestamp = t - e, this.isPlaying() || (this._isTweening = !0, this._isPaused = !1, d(this, this._timestamp, this._delay, this._duration, this._currentState, this._originalState, this._targetState, this._easing, this._step, this._scheduleFunction, t), this.pause())), this }, h.prototype.stop = function (t) { return this._isTweening = !1, this._isPaused = !1, this._timeoutHandler = n, (e.cancelAnimationFrame || e.webkitCancelAnimationFrame || e.oCancelAnimationFrame || e.msCancelAnimationFrame || e.mozCancelRequestAnimationFrame || e.clearTimeout)(this._scheduleId), t && (c(this, "beforeTween"), a(1, this._currentState, this._originalState, this._targetState, 1, 0, this._easing), c(this, "afterTween"), c(this, "afterTweenEnd"), this._finish.call(this, this._currentState, this._attachment)), this }, h.prototype.isPlaying = function () { return this._isTweening && !this._isPaused }, h.prototype.setScheduleFunction = function (e) { this._scheduleFunction = e }, h.prototype.dispose = function () { var e; for (e in this) this.hasOwnProperty(e) && delete this[e] }, h.prototype.filter = {}, h.prototype.formula = { linear: function (e) { return e } }, p = h.prototype.formula, r(h, { now: _, each: s, tweenProps: a, tweenProp: l, applyFilter: c, shallowCopy: r, defaults: o, composeEasingObject: u }), "function" == typeof SHIFTY_DEBUG_NOW && (e.timeoutHandler = d), "object" == typeof i ? t.exports = h : void 0 === e.Tweenable && (e.Tweenable = h), h }(); n.shallowCopy(n.prototype.formula, { easeInQuad: function (e) { return Math.pow(e, 2) }, easeOutQuad: function (e) { return -(Math.pow(e - 1, 2) - 1) }, easeInOutQuad: function (e) { return (e /= .5) < 1 ? .5 * Math.pow(e, 2) : -.5 * ((e -= 2) * e - 2) }, easeInCubic: function (e) { return Math.pow(e, 3) }, easeOutCubic: function (e) { return Math.pow(e - 1, 3) + 1 }, easeInOutCubic: function (e) { return (e /= .5) < 1 ? .5 * Math.pow(e, 3) : .5 * (Math.pow(e - 2, 3) + 2) }, easeInQuart: function (e) { return Math.pow(e, 4) }, easeOutQuart: function (e) { return -(Math.pow(e - 1, 4) - 1) }, easeInOutQuart: function (e) { return (e /= .5) < 1 ? .5 * Math.pow(e, 4) : -.5 * ((e -= 2) * Math.pow(e, 3) - 2) }, easeInQuint: function (e) { return Math.pow(e, 5) }, easeOutQuint: function (e) { return Math.pow(e - 1, 5) + 1 }, easeInOutQuint: function (e) { return (e /= .5) < 1 ? .5 * Math.pow(e, 5) : .5 * (Math.pow(e - 2, 5) + 2) }, easeInSine: function (e) { return 1 - Math.cos(e * (Math.PI / 2)) }, easeOutSine: function (e) { return Math.sin(e * (Math.PI / 2)) }, easeInOutSine: function (e) { return -.5 * (Math.cos(Math.PI * e) - 1) }, easeInExpo: function (e) { return 0 === e ? 0 : Math.pow(2, 10 * (e - 1)) }, easeOutExpo: function (e) { return 1 === e ? 1 : 1 - Math.pow(2, -10 * e) }, easeInOutExpo: function (e) { return 0 === e ? 0 : 1 === e ? 1 : (e /= .5) < 1 ? .5 * Math.pow(2, 10 * (e - 1)) : .5 * (2 - Math.pow(2, -10 * --e)) }, easeInCirc: function (e) { return -(Math.sqrt(1 - e * e) - 1) }, easeOutCirc: function (e) { return Math.sqrt(1 - Math.pow(e - 1, 2)) }, easeInOutCirc: function (e) { return (e /= .5) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1) }, easeOutBounce: function (e) { return 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375 }, easeInBack: function (e) { var t = 1.70158; return e * e * ((t + 1) * e - t) }, easeOutBack: function (e) { var t = 1.70158; return (e -= 1) * e * ((t + 1) * e + t) + 1 }, easeInOutBack: function (e) { var t = 1.70158; return (e /= .5) < 1 ? e * e * ((1 + (t *= 1.525)) * e - t) * .5 : .5 * ((e -= 2) * e * ((1 + (t *= 1.525)) * e + t) + 2) }, elastic: function (e) { return -1 * Math.pow(4, -8 * e) * Math.sin((6 * e - 1) * (2 * Math.PI) / 2) + 1 }, swingFromTo: function (e) { var t = 1.70158; return (e /= .5) < 1 ? e * e * ((1 + (t *= 1.525)) * e - t) * .5 : .5 * ((e -= 2) * e * ((1 + (t *= 1.525)) * e + t) + 2) }, swingFrom: function (e) { var t = 1.70158; return e * e * ((t + 1) * e - t) }, swingTo: function (e) { var t = 1.70158; return (e -= 1) * e * ((t + 1) * e + t) + 1 }, bounce: function (e) { return 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375 }, bouncePast: function (e) { return 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 2 - (7.5625 * (e -= 1.5 / 2.75) * e + .75) : 2.5 / 2.75 > e ? 2 - (7.5625 * (e -= 2.25 / 2.75) * e + .9375) : 2 - (7.5625 * (e -= 2.625 / 2.75) * e + .984375) }, easeFromTo: function (e) { return (e /= .5) < 1 ? .5 * Math.pow(e, 4) : -.5 * ((e -= 2) * Math.pow(e, 3) - 2) }, easeFrom: function (e) { return Math.pow(e, 4) }, easeTo: function (e) { return Math.pow(e, .25) } }), function () { function e(e, t, i, n, s, r) { function o(e) { return ((c * e + d) * e + u) * e } function a(e) { return (3 * c * e + 2 * d) * e + u } function l(e) { return e >= 0 ? e : 0 - e } var c = 0, d = 0, u = 0, h = 0, p = 0, f = 0; return c = 1 - (u = 3 * t) - (d = 3 * (n - t) - u), h = 1 - (f = 3 * i) - (p = 3 * (s - i) - f), function (e, t) { return function (e) { return ((h * e + p) * e + f) * e }(function (e, t) { var i, n, s, r, c, d; for (s = e, d = 0; 8 > d; d++) { if (l(r = o(s) - e) < t) return s; if (l(c = a(s)) < 1e-6) break; s -= r / c } if (i = 0, n = 1, s = e, i > s) return i; if (s > n) return n; for (; n > i;) { if (l((r = o(s)) - e) < t) return s; e > r ? i = s : n = s, s = .5 * (n - i) + i } return s }(e, t)) }(e, function (e) { return 1 / (200 * e) }(r)) } function t(t, i, n, s) { return function (r) { return e(r, t, i, n, s, 1) } } n.setBezierFunction = function (e, i, s, r, o) { var a = t(i, s, r, o); return a.displayName = e, a.x1 = i, a.y1 = s, a.x2 = r, a.y2 = o, n.prototype.formula[e] = a }, n.unsetBezierFunction = function (e) { delete n.prototype.formula[e] } }(), function () { var e = new n; e._filterArgs = [], n.interpolate = function (t, i, s, r, o) { var a = n.shallowCopy({}, t), l = o || 0, c = n.composeEasingObject(t, r || "linear"); e.set({}); var d = e._filterArgs; d.length = 0, d[0] = a, d[1] = t, d[2] = i, d[3] = c, n.applyFilter(e, "tweenCreated"), n.applyFilter(e, "beforeTween"); var u = function (e, t, i, s, r, o) { return n.tweenProps(s, t, e, i, 1, o, r) }(t, a, i, s, c, l); return n.applyFilter(e, "afterTween"), u } }(), function (e) { function t(e, t) { var i, n = [], s = e.length; for (i = 0; s > i; i++)n.push("_" + t + "_" + i); return n } function i(e) { var t = e.match(m); return t ? (1 === t.length || e[0].match(f)) && t.unshift("") : t = ["", ""], t.join(w) } function n(t) { e.each(t, (function (e) { var i = t[e]; "string" == typeof i && i.match(b) && (t[e] = function (e) { return o(b, e, s) }(i)) })) } function s(e) { var t = function (e) { return e = e.replace(/#/, ""), 3 === e.length && (e = e.split(""), e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2]), x[0] = r(e.substr(0, 2)), x[1] = r(e.substr(2, 2)), x[2] = r(e.substr(4, 2)), x }(e); return "rgb(" + t[0] + "," + t[1] + "," + t[2] + ")" } function r(e) { return parseInt(e, 16) } function o(e, t, i) { var n = t.match(e), s = t.replace(e, w); if (n) for (var r, o = n.length, a = 0; o > a; a++)r = n.shift(), s = s.replace(w, i(r)); return s } function a(e) { for (var t = e.match(g), i = t.length, n = e.match(y)[0], s = 0; i > s; s++)n += parseInt(t[s], 10) + ","; return n.slice(0, -1) + ")" } function l(n) { var s = {}; return e.each(n, (function (e) { var r = n[e]; if ("string" == typeof r) { var o = u(r); s[e] = { formatString: i(r), chunkNames: t(o, e) } } })), s } function c(t, i) { e.each(i, (function (e) { for (var n = u(t[e]), s = n.length, r = 0; s > r; r++)t[i[e].chunkNames[r]] = +n[r]; delete t[e] })) } function d(t, i) { e.each(i, (function (e) { var n = t[e], s = function (e, t) { for (var i, n = {}, s = t.length, r = 0; s > r; r++)i = t[r], n[i] = e[i], delete e[i]; return n }(t, i[e].chunkNames), r = function (e, t) { _.length = 0; for (var i = t.length, n = 0; i > n; n++)_.push(e[t[n]]); return _ }(s, i[e].chunkNames); n = function (e, t) { for (var i = e, n = t.length, s = 0; n > s; s++)i = i.replace(w, +t[s].toFixed(4)); return i }(i[e].formatString, r), t[e] = function (e) { return o(v, e, a) }(n) })) } function u(e) { return e.match(g) } function h(t, i) { e.each(i, (function (e) { var n, s = i[e].chunkNames, r = s.length, o = t[e]; if ("string" == typeof o) { var a = o.split(" "), l = a[a.length - 1]; for (n = 0; r > n; n++)t[s[n]] = a[n] || l } else for (n = 0; r > n; n++)t[s[n]] = o; delete t[e] })) } function p(t, i) { e.each(i, (function (e) { var n = i[e].chunkNames, s = n.length, r = t[n[0]]; if ("string" === typeof r) { for (var o = "", a = 0; s > a; a++)o += " " + t[n[a]], delete t[n[a]]; t[e] = o.substr(1) } else t[e] = r })) } var f = /(\d|\-|\.)/, m = /([^\-0-9\.]+)/g, g = /[0-9.\-]+/g, v = new RegExp("rgb\\(" + g.source + /,\s*/.source + g.source + /,\s*/.source + g.source + "\\)", "g"), y = /^.*\(/, b = /#([0-9]|[a-f]){3,6}/gi, w = "VAL", x = [], _ = []; e.prototype.filter.token = { tweenCreated: function (e, t, i, s) { n(e), n(t), n(i), this._tokenData = l(e) }, beforeTween: function (e, t, i, n) { h(n, this._tokenData), c(e, this._tokenData), c(t, this._tokenData), c(i, this._tokenData) }, afterTween: function (e, t, i, n) { d(e, this._tokenData), d(t, this._tokenData), d(i, this._tokenData), p(n, this._tokenData) } } }(n) }).call(null) }, {}], 2: [function (e, t, i) { var n = e("./shape"), s = e("./utils"), r = function (e, t) { this._pathTemplate = "M 50,50 m 0,-{radius} a {radius},{radius} 0 1 1 0,{2radius} a {radius},{radius} 0 1 1 0,-{2radius}", this.containerAspectRatio = 1, n.apply(this, arguments) }; (r.prototype = new n).constructor = r, r.prototype._pathString = function (e) { var t = e.strokeWidth; e.trailWidth && e.trailWidth > e.strokeWidth && (t = e.trailWidth); var i = 50 - t / 2; return s.render(this._pathTemplate, { radius: i, "2radius": 2 * i }) }, r.prototype._trailString = function (e) { return this._pathString(e) }, t.exports = r }, { "./shape": 7, "./utils": 8 }], 3: [function (e, t, i) { var n = e("./shape"), s = e("./utils"), r = function (e, t) { this._pathTemplate = "M 0,{center} L 100,{center}", n.apply(this, arguments) }; (r.prototype = new n).constructor = r, r.prototype._initializeSvg = function (e, t) { e.setAttribute("viewBox", "0 0 100 " + t.strokeWidth), e.setAttribute("preserveAspectRatio", "none") }, r.prototype._pathString = function (e) { return s.render(this._pathTemplate, { center: e.strokeWidth / 2 }) }, r.prototype._trailString = function (e) { return this._pathString(e) }, t.exports = r }, { "./shape": 7, "./utils": 8 }], 4: [function (e, t, i) { t.exports = { Line: e("./line"), Circle: e("./circle"), SemiCircle: e("./semicircle"), Path: e("./path"), Shape: e("./shape"), utils: e("./utils") } }, { "./circle": 2, "./line": 3, "./path": 5, "./semicircle": 6, "./shape": 7, "./utils": 8 }], 5: [function (e, t, i) { var n = e("shifty"), s = e("./utils"), r = { easeIn: "easeInCubic", easeOut: "easeOutCubic", easeInOut: "easeInOutCubic" }, o = function e(t, i) { if (!(this instanceof e)) throw new Error("Constructor was called without new keyword"); var n; i = s.extend({ duration: 800, easing: "linear", from: {}, to: {}, step: function () { } }, i), n = s.isString(t) ? document.querySelector(t) : t, this.path = n, this._opts = i, this._tweenable = null; var r = this.path.getTotalLength(); this.path.style.strokeDasharray = r + " " + r, this.set(0) }; o.prototype.value = function () { var e = this._getComputedDashOffset(), t = this.path.getTotalLength(); return parseFloat((1 - e / t).toFixed(6), 10) }, o.prototype.set = function (e) { this.stop(), this.path.style.strokeDashoffset = this._progressToOffset(e); var t = this._opts.step; if (s.isFunction(t)) { var i = this._easing(this._opts.easing); t(this._calculateTo(e, i), this._opts.shape || this, this._opts.attachment) } }, o.prototype.stop = function () { this._stopTween(), this.path.style.strokeDashoffset = this._getComputedDashOffset() }, o.prototype.animate = function (e, t, i) { t = t || {}, s.isFunction(t) && (i = t, t = {}); var r = s.extend({}, t), o = s.extend({}, this._opts); t = s.extend(o, t); var a = this._easing(t.easing), l = this._resolveFromAndTo(e, a, r); this.stop(), this.path.getBoundingClientRect(); var c = this._getComputedDashOffset(), d = this._progressToOffset(e), u = this; this._tweenable = new n, this._tweenable.tween({ from: s.extend({ offset: c }, l.from), to: s.extend({ offset: d }, l.to), duration: t.duration, easing: a, step: function (e) { u.path.style.strokeDashoffset = e.offset; var i = t.shape || u; t.step(e, i, t.attachment) }, finish: function (e) { s.isFunction(i) && i() } }) }, o.prototype._getComputedDashOffset = function () { var e = window.getComputedStyle(this.path, null); return parseFloat(e.getPropertyValue("stroke-dashoffset"), 10) }, o.prototype._progressToOffset = function (e) { var t = this.path.getTotalLength(); return t - e * t }, o.prototype._resolveFromAndTo = function (e, t, i) { return i.from && i.to ? { from: i.from, to: i.to } : { from: this._calculateFrom(t), to: this._calculateTo(e, t) } }, o.prototype._calculateFrom = function (e) { return n.interpolate(this._opts.from, this._opts.to, this.value(), e) }, o.prototype._calculateTo = function (e, t) { return n.interpolate(this._opts.from, this._opts.to, e, t) }, o.prototype._stopTween = function () { null !== this._tweenable && (this._tweenable.stop(), this._tweenable = null) }, o.prototype._easing = function (e) { return r.hasOwnProperty(e) ? r[e] : e }, t.exports = o }, { "./utils": 8, shifty: 1 }], 6: [function (e, t, i) { var n = e("./shape"), s = e("./circle"), r = e("./utils"), o = function (e, t) { this._pathTemplate = "M 50,50 m -{radius},0 a {radius},{radius} 0 1 1 {2radius},0", this.containerAspectRatio = 2, n.apply(this, arguments) }; (o.prototype = new n).constructor = o, o.prototype._initializeSvg = function (e, t) { e.setAttribute("viewBox", "0 0 100 50") }, o.prototype._initializeTextContainer = function (e, t, i) { e.text.style && (i.style.top = "auto", i.style.bottom = "0", e.text.alignToBottom ? r.setStyle(i, "transform", "translate(-50%, 0)") : r.setStyle(i, "transform", "translate(-50%, 50%)")) }, o.prototype._pathString = s.prototype._pathString, o.prototype._trailString = s.prototype._trailString, t.exports = o }, { "./circle": 2, "./shape": 7, "./utils": 8 }], 7: [function (e, t, i) { var n = e("./path"), s = e("./utils"), r = "Object is destroyed", o = function e(t, i) { if (!(this instanceof e)) throw new Error("Constructor was called without new keyword"); if (0 !== arguments.length) { this._opts = s.extend({ color: "#555", strokeWidth: 1, trailColor: null, trailWidth: null, fill: null, text: { style: { color: null, position: "absolute", left: "50%", top: "50%", padding: 0, margin: 0, transform: { prefix: !0, value: "translate(-50%, -50%)" } }, autoStyleContainer: !0, alignToBottom: !0, value: null, className: "progressbar-text" }, svgStyle: { display: "block", width: "100%" }, warnings: !1 }, i, !0), s.isObject(i) && void 0 !== i.svgStyle && (this._opts.svgStyle = i.svgStyle), s.isObject(i) && s.isObject(i.text) && void 0 !== i.text.style && (this._opts.text.style = i.text.style); var r, o = this._createSvgView(this._opts); if (!(r = s.isString(t) ? document.querySelector(t) : t)) throw new Error("Container does not exist: " + t); this._container = r, this._container.appendChild(o.svg), this._opts.warnings && this._warnContainerAspectRatio(this._container), this._opts.svgStyle && s.setStyles(o.svg, this._opts.svgStyle), this.svg = o.svg, this.path = o.path, this.trail = o.trail, this.text = null; var a = s.extend({ attachment: void 0, shape: this }, this._opts); this._progressPath = new n(o.path, a), s.isObject(this._opts.text) && null !== this._opts.text.value && this.setText(this._opts.text.value) } }; o.prototype.animate = function (e, t, i) { if (null === this._progressPath) throw new Error(r); this._progressPath.animate(e, t, i) }, o.prototype.stop = function () { if (null === this._progressPath) throw new Error(r); void 0 !== this._progressPath && this._progressPath.stop() }, o.prototype.destroy = function () { if (null === this._progressPath) throw new Error(r); this.stop(), this.svg.parentNode.removeChild(this.svg), this.svg = null, this.path = null, this.trail = null, this._progressPath = null, null !== this.text && (this.text.parentNode.removeChild(this.text), this.text = null) }, o.prototype.set = function (e) { if (null === this._progressPath) throw new Error(r); this._progressPath.set(e) }, o.prototype.value = function () { if (null === this._progressPath) throw new Error(r); return void 0 === this._progressPath ? 0 : this._progressPath.value() }, o.prototype.setText = function (e) { if (null === this._progressPath) throw new Error(r); null === this.text && (this.text = this._createTextContainer(this._opts, this._container), this._container.appendChild(this.text)), s.isObject(e) ? (s.removeChildren(this.text), this.text.appendChild(e)) : this.text.innerHTML = e }, o.prototype._createSvgView = function (e) { var t = document.createElementNS("http://www.w3.org/2000/svg", "svg"); this._initializeSvg(t, e); var i = null; (e.trailColor || e.trailWidth) && (i = this._createTrail(e), t.appendChild(i)); var n = this._createPath(e); return t.appendChild(n), { svg: t, path: n, trail: i } }, o.prototype._initializeSvg = function (e, t) { e.setAttribute("viewBox", "0 0 100 100") }, o.prototype._createPath = function (e) { var t = this._pathString(e); return this._createPathElement(t, e) }, o.prototype._createTrail = function (e) { var t = this._trailString(e), i = s.extend({}, e); return i.trailColor || (i.trailColor = "#eee"), i.trailWidth || (i.trailWidth = i.strokeWidth), i.color = i.trailColor, i.strokeWidth = i.trailWidth, i.fill = null, this._createPathElement(t, i) }, o.prototype._createPathElement = function (e, t) { var i = document.createElementNS("http://www.w3.org/2000/svg", "path"); return i.setAttribute("d", e), i.setAttribute("stroke", t.color), i.setAttribute("stroke-width", t.strokeWidth), t.fill ? i.setAttribute("fill", t.fill) : i.setAttribute("fill-opacity", "0"), i }, o.prototype._createTextContainer = function (e, t) { var i = document.createElement("div"); i.className = e.text.className; var n = e.text.style; return n && (e.text.autoStyleContainer && (t.style.position = "relative"), s.setStyles(i, n), n.color || (i.style.color = e.color)), this._initializeTextContainer(e, t, i), i }, o.prototype._initializeTextContainer = function (e, t, i) { }, o.prototype._pathString = function (e) { throw new Error("Override this function for each progress bar") }, o.prototype._trailString = function (e) { throw new Error("Override this function for each progress bar") }, o.prototype._warnContainerAspectRatio = function (e) { if (this.containerAspectRatio) { var t = window.getComputedStyle(e, null), i = parseFloat(t.getPropertyValue("width"), 10), n = parseFloat(t.getPropertyValue("height"), 10); s.floatEquals(this.containerAspectRatio, i / n) || (console.warn("Incorrect aspect ratio of container", "#" + e.id, "detected:", t.getPropertyValue("width") + "(width)", "/", t.getPropertyValue("height") + "(height)", "=", i / n), console.warn("Aspect ratio of should be", this.containerAspectRatio)) } }, t.exports = o }, { "./path": 5, "./utils": 8 }], 8: [function (e, t, i) { function n(e, t, i) { for (var n = e.style, r = 0; r < a.length; ++r) { n[a[r] + s(t)] = i } n[t] = i } function s(e) { return e.charAt(0).toUpperCase() + e.slice(1) } function r(e) { return !function (e) { return "[object Array]" === Object.prototype.toString.call(e) }(e) && ("object" === typeof e && !!e) } function o(e, t) { for (var i in e) if (e.hasOwnProperty(i)) { t(e[i], i) } } var a = "Webkit Moz O ms".split(" "), l = .001; t.exports = { extend: function e(t, i, n) { for (var s in t = t || {}, n = n || !1, i = i || {}) if (i.hasOwnProperty(s)) { var o = t[s], a = i[s]; n && r(o) && r(a) ? t[s] = e(o, a, n) : t[s] = a } return t }, render: function (e, t) { var i = e; for (var n in t) if (t.hasOwnProperty(n)) { var s = t[n], r = new RegExp("\\{" + n + "\\}", "g"); i = i.replace(r, s) } return i }, setStyle: n, setStyles: function (e, t) { o(t, (function (t, i) { null != t && (r(t) && !0 === t.prefix ? n(e, i, t.value) : e.style[i] = t) })) }, capitalize: s, isString: function (e) { return "string" == typeof e || e instanceof String }, isFunction: function (e) { return "function" == typeof e }, isObject: r, forEachObject: o, floatEquals: function (e, t) { return Math.abs(e - t) < l }, removeChildren: function (e) { for (; e.firstChild;)e.removeChild(e.firstChild) } } }, {}] }, {}, [4])(4) })),
    /*!
     * RELLAX v1.12.1
     * https://github.com/dixonandmoe/rellax
     */
    function (e, t) { "function" == typeof define && define.amd ? define([], t) : "object" == typeof module && module.exports ? module.exports = t() : e.Rellax = t() }("undefined" != typeof window ? window : global, (function () { var e = function (t, i) { var n = Object.create(e.prototype), s = 0, r = 0, o = 0, a = 0, l = [], c = !0, d = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function (e) { return setTimeout(e, 1e3 / 60) }, u = null, h = !1; try { var p = Object.defineProperty({}, "passive", { get: function () { h = !0 } }); window.addEventListener("testPassive", null, p), window.removeEventListener("testPassive", null, p) } catch (e) { } var f = window.cancelAnimationFrame || window.mozCancelAnimationFrame || clearTimeout, m = window.transformProp || function () { var e = document.createElement("div"); if (null === e.style.transform) { var t, i = ["Webkit", "Moz", "ms"]; for (t in i) if (void 0 !== e.style[i[t] + "Transform"]) return i[t] + "Transform" } return "transform" }(); if (n.options = { speed: -2, verticalSpeed: null, horizontalSpeed: null, breakpoints: [576, 768, 1201], center: !1, wrapper: null, relativeToWrapper: !1, round: !0, vertical: !0, horizontal: !1, verticalScrollAxis: "y", horizontalScrollAxis: "x", callback: function () { } }, i && Object.keys(i).forEach((function (e) { n.options[e] = i[e] })), i && i.breakpoints && function () { if (3 === n.options.breakpoints.length && Array.isArray(n.options.breakpoints)) { var e, t = !0, i = !0; if (n.options.breakpoints.forEach((function (n) { "number" != typeof n && (i = !1), null !== e && n < e && (t = !1), e = n })), t && i) return } n.options.breakpoints = [576, 768, 1201], console.warn("Rellax: You must pass an array of 3 numbers in ascending order to the breakpoints option. Defaults reverted") }(), t || (t = ".rellax"), 0 < (p = "string" == typeof t ? document.querySelectorAll(t) : [t]).length) { if (n.elems = p, n.options.wrapper && !n.options.wrapper.nodeType) { if (!(p = document.querySelector(n.options.wrapper))) return void console.warn("Rellax: The wrapper you're trying to use doesn't exist."); n.options.wrapper = p } var g, v = function () { for (var e = 0; e < l.length; e++)n.elems[e].style.cssText = l[e].style; for (l = [], r = window.innerHeight, a = window.innerWidth, e = n.options.breakpoints, g = a < e[0] ? "xs" : a >= e[0] && a < e[1] ? "sm" : a >= e[1] && a < e[2] ? "md" : "lg", y(), e = 0; e < n.elems.length; e++) { var t = void 0, i = n.elems[e], s = i.getAttribute("data-rellax-percentage"), o = i.getAttribute("data-rellax-speed"), d = i.getAttribute("data-rellax-xs-speed"), u = i.getAttribute("data-rellax-mobile-speed"), h = i.getAttribute("data-rellax-tablet-speed"), p = i.getAttribute("data-rellax-desktop-speed"), f = i.getAttribute("data-rellax-vertical-speed"), m = i.getAttribute("data-rellax-horizontal-speed"), w = i.getAttribute("data-rellax-vertical-scroll-axis"), T = i.getAttribute("data-rellax-horizontal-scroll-axis"), E = i.getAttribute("data-rellax-zindex") || 0, S = i.getAttribute("data-rellax-min"), C = i.getAttribute("data-rellax-max"), k = i.getAttribute("data-rellax-min-x"), A = i.getAttribute("data-rellax-max-x"), $ = i.getAttribute("data-rellax-min-y"), M = i.getAttribute("data-rellax-max-y"), P = !0; d || u || h || p ? t = { xs: d, sm: u, md: h, lg: p } : P = !1, d = n.options.wrapper ? n.options.wrapper.scrollTop : window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop, n.options.relativeToWrapper && (d = (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop) - n.options.wrapper.offsetTop); var I = n.options.vertical && (s || n.options.center) ? d : 0, L = n.options.horizontal && (s || n.options.center) ? n.options.wrapper ? n.options.wrapper.scrollLeft : window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft : 0; d = I + i.getBoundingClientRect().top, u = i.clientHeight || i.offsetHeight || i.scrollHeight, h = L + i.getBoundingClientRect().left, p = i.clientWidth || i.offsetWidth || i.scrollWidth, I = s || (I - d + r) / (u + r), s = s || (L - h + a) / (p + a), n.options.center && (I = s = .5), t = P && null !== t[g] ? Number(t[g]) : o || n.options.speed, f = f || n.options.verticalSpeed, m = m || n.options.horizontalSpeed, w = w || n.options.verticalScrollAxis, T = T || n.options.horizontalScrollAxis, o = b(s, I, t, f, m), i = i.style.cssText, P = "", (s = /transform\s*:/i.exec(i)) && (P = (s = (P = i.slice(s.index)).indexOf(";")) ? " " + P.slice(11, s).replace(/\s/g, "") : " " + P.slice(11).replace(/\s/g, "")), l.push({ baseX: o.x, baseY: o.y, top: d, left: h, height: u, width: p, speed: t, verticalSpeed: f, horizontalSpeed: m, verticalScrollAxis: w, horizontalScrollAxis: T, style: i, transform: P, zindex: E, min: S, max: C, minX: k, maxX: A, minY: $, maxY: M }) } _(), c && (window.addEventListener("resize", v), c = !1, x()) }, y = function () { var e = s, t = o; return s = n.options.wrapper ? n.options.wrapper.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset, o = n.options.wrapper ? n.options.wrapper.scrollLeft : (document.documentElement || document.body.parentNode || document.body).scrollLeft || window.pageXOffset, n.options.relativeToWrapper && (s = ((document.documentElement || document.body.parentNode || document.body).scrollTop || window.pageYOffset) - n.options.wrapper.offsetTop), !!(e != s && n.options.vertical || t != o && n.options.horizontal) }, b = function (e, t, i, s, r) { var o = {}; return e = 100 * (r || i) * (1 - e), t = 100 * (s || i) * (1 - t), o.x = n.options.round ? Math.round(e) : Math.round(100 * e) / 100, o.y = n.options.round ? Math.round(t) : Math.round(100 * t) / 100, o }, w = function () { window.removeEventListener("resize", w), window.removeEventListener("orientationchange", w), (n.options.wrapper ? n.options.wrapper : window).removeEventListener("scroll", w), (n.options.wrapper ? n.options.wrapper : document).removeEventListener("touchmove", w), u = d(x) }, x = function () { y() && !1 === c ? (_(), u = d(x)) : (u = null, window.addEventListener("resize", w), window.addEventListener("orientationchange", w), (n.options.wrapper ? n.options.wrapper : window).addEventListener("scroll", w, !!h && { passive: !0 }), (n.options.wrapper ? n.options.wrapper : document).addEventListener("touchmove", w, !!h && { passive: !0 })) }, _ = function () { for (var e, t = 0; t < n.elems.length; t++) { var i = l[t].verticalScrollAxis.toLowerCase(), c = l[t].horizontalScrollAxis.toLowerCase(); e = -1 != i.indexOf("x") ? s : 0, i = -1 != i.indexOf("y") ? s : 0; var d = -1 != c.indexOf("x") ? o : 0; c = -1 != c.indexOf("y") ? o : 0, c = (e = b((e + d - l[t].left + a) / (l[t].width + a), (i + c - l[t].top + r) / (l[t].height + r), l[t].speed, l[t].verticalSpeed, l[t].horizontalSpeed)).y - l[t].baseY, i = e.x - l[t].baseX, null !== l[t].min && (n.options.vertical && !n.options.horizontal && (c = c <= l[t].min ? l[t].min : c), n.options.horizontal && !n.options.vertical && (i = i <= l[t].min ? l[t].min : i)), null != l[t].minY && (c = c <= l[t].minY ? l[t].minY : c), null != l[t].minX && (i = i <= l[t].minX ? l[t].minX : i), null !== l[t].max && (n.options.vertical && !n.options.horizontal && (c = c >= l[t].max ? l[t].max : c), n.options.horizontal && !n.options.vertical && (i = i >= l[t].max ? l[t].max : i)), null != l[t].maxY && (c = c >= l[t].maxY ? l[t].maxY : c), null != l[t].maxX && (i = i >= l[t].maxX ? l[t].maxX : i), n.elems[t].style[m] = "translate3d(" + (n.options.horizontal ? i : "0") + "px," + (n.options.vertical ? c : "0") + "px," + l[t].zindex + "px) " + l[t].transform } n.options.callback(e) }; return n.destroy = function () { for (var e = 0; e < n.elems.length; e++)n.elems[e].style.cssText = l[e].style; c || (window.removeEventListener("resize", v), c = !0), f(u), u = null }, v(), n.refresh = v, n } console.warn("Rellax: The elements you're trying to select don't exist.") }; return e })), function (e, t) { "use strict"; function i(e, t) { var i = { animation: "animated fadeIn", speed: 2e3, separator: ",", hoverStop: !1, clickChange: !1, loopCount: "infinite", autoRun: !0, onInit: !1, onChange: !1, onComplete: !1 }; if (this.options = "object" == typeof t ? function (e, t) { for (var i in t) t.hasOwnProperty(i) && (e[i] = t[i]); return e }(i, t) : i, void 0 === e) throw new Error('ReplaceMe [constructor]: "element" parameter is required'); if ("object" == typeof e) this.element = e; else { if ("string" != typeof e) throw new Error('ReplaceMe [constructor]: wrong "element" parameter'); this.element = document.querySelector(e) } this.init() } i.prototype.init = function () { "function" == typeof this.options.onInit && this.options.onInit(), this.words = this.escapeHTML(this.element.innerHTML).split(this.options.separator), this.count = this.words.length, this.position = this.loopCount = 0, this.running = !1, this.bindAll(), !0 === this.options.autoRun && this.start() }, i.prototype.bindAll = function () { !0 === this.options.hoverStop && (this.element.addEventListener("mouseover", this.pause.bind(this)), this.element.addEventListener("mouseout", this.start.bind(this))), !0 === this.options.clickChange && this.element.addEventListener("click", this.change.bind(this)) }, i.prototype.changeAnimation = function () { this.change(), this.loop = setTimeout(this.changeAnimation.bind(this), this.options.speed) }, i.prototype.start = function () { !0 !== this.running && (this.running = !0, this.changeWord(this.words[this.position]), this.position++), this.loop = setTimeout(this.changeAnimation.bind(this), this.options.speed) }, i.prototype.change = function () { return this.position > this.count - 1 && (this.position = 0, this.loopCount++, this.loopCount >= this.options.loopCount) ? void this.stop() : (this.changeWord(this.words[this.position]), this.position++, void ("function" == typeof this.options.onChange && this.options.onChange())) }, i.prototype.stop = function () { this.running = !1, this.position = this.loopCount = 0, this.pause(), "function" == typeof this.options.onComplete && this.options.onComplete() }, i.prototype.pause = function () { clearTimeout(this.loop) }, i.prototype.changeWord = function (e) { this.element.innerHTML = '<span class="' + this.options.animation + '" style="display:inline-block;">' + e + "</span>" }, i.prototype.escapeHTML = function (e) { var t = /<\/?\w+\s*[^>]*>/g; return !0 === t.test(e) ? e.replace(t, "") : e }, e.ReplaceMe = i, "function" == typeof t && t.fn.extend({ ReplaceMe: function (e) { return this.each((function () { new i(this, e) })) } }) }(window, window.jQuery);
/*!
 * scrollCue.js v2.0.0
 * https://github.com/prjct-samwest/scrollCue
 */
var $jscomp = $jscomp || {}; $jscomp.scope = {}, $jscomp.arrayIteratorImpl = function (e) { var t = 0; return function () { return t < e.length ? { done: !1, value: e[t++] } : { done: !0 } } }, $jscomp.arrayIterator = function (e) { return { next: $jscomp.arrayIteratorImpl(e) } }, $jscomp.ASSUME_ES5 = !1, $jscomp.ASSUME_NO_NATIVE_MAP = !1, $jscomp.ASSUME_NO_NATIVE_SET = !1, $jscomp.SIMPLE_FROUND_POLYFILL = !1, $jscomp.ISOLATE_POLYFILLS = !1, $jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function (e, t, i) { return e == Array.prototype || e == Object.prototype || (e[t] = i.value), e }, $jscomp.getGlobal = function (e) { e = ["object" == typeof globalThis && globalThis, e, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global]; for (var t = 0; t < e.length; ++t) { var i = e[t]; if (i && i.Math == Math) return i } throw Error("Cannot find global object") }, $jscomp.global = $jscomp.getGlobal(this), $jscomp.IS_SYMBOL_NATIVE = "function" == typeof Symbol && "symbol" == typeof Symbol("x"), $jscomp.TRUST_ES6_POLYFILLS = !$jscomp.ISOLATE_POLYFILLS || $jscomp.IS_SYMBOL_NATIVE, $jscomp.polyfills = {}, $jscomp.propertyToPolyfillSymbol = {}, $jscomp.POLYFILL_PREFIX = "$jscp$"; var $jscomp$lookupPolyfilledValue = function (e, t) { var i = $jscomp.propertyToPolyfillSymbol[t]; return null == i ? e[t] : void 0 !== (i = e[i]) ? i : e[t] }; $jscomp.polyfill = function (e, t, i, n) { t && ($jscomp.ISOLATE_POLYFILLS ? $jscomp.polyfillIsolated(e, t, i, n) : $jscomp.polyfillUnisolated(e, t, i, n)) }, $jscomp.polyfillUnisolated = function (e, t, i, n) { for (i = $jscomp.global, e = e.split("."), n = 0; n < e.length - 1; n++) { var s = e[n]; s in i || (i[s] = {}), i = i[s] } (t = t(n = i[e = e[e.length - 1]])) != n && null != t && $jscomp.defineProperty(i, e, { configurable: !0, writable: !0, value: t }) }, $jscomp.polyfillIsolated = function (e, t, i, n) { var s = e.split("."); e = 1 === s.length, n = s[0], n = !e && n in $jscomp.polyfills ? $jscomp.polyfills : $jscomp.global; for (var r = 0; r < s.length - 1; r++) { var o = s[r]; o in n || (n[o] = {}), n = n[o] } s = s[s.length - 1], null != (t = t(i = $jscomp.IS_SYMBOL_NATIVE && "es6" === i ? n[s] : null)) && (e ? $jscomp.defineProperty($jscomp.polyfills, s, { configurable: !0, writable: !0, value: t }) : t !== i && ($jscomp.propertyToPolyfillSymbol[s] = $jscomp.IS_SYMBOL_NATIVE ? $jscomp.global.Symbol(s) : $jscomp.POLYFILL_PREFIX + s, s = $jscomp.propertyToPolyfillSymbol[s], $jscomp.defineProperty(n, s, { configurable: !0, writable: !0, value: t }))) }, $jscomp.initSymbol = function () { }, $jscomp.polyfill("Symbol", (function (e) { if (e) return e; var t = function (e, t) { this.$jscomp$symbol$id_ = e, $jscomp.defineProperty(this, "description", { configurable: !0, writable: !0, value: t }) }; t.prototype.toString = function () { return this.$jscomp$symbol$id_ }; var i = 0, n = function (e) { if (this instanceof n) throw new TypeError("Symbol is not a constructor"); return new t("jscomp_symbol_" + (e || "") + "_" + i++, e) }; return n }), "es6", "es3"), $jscomp.initSymbolIterator = function () { }, $jscomp.polyfill("Symbol.iterator", (function (e) { if (e) return e; e = Symbol("Symbol.iterator"); for (var t = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), i = 0; i < t.length; i++) { var n = $jscomp.global[t[i]]; "function" == typeof n && "function" != typeof n.prototype[e] && $jscomp.defineProperty(n.prototype, e, { configurable: !0, writable: !0, value: function () { return $jscomp.iteratorPrototype($jscomp.arrayIteratorImpl(this)) } }) } return e }), "es6", "es3"), $jscomp.initSymbolAsyncIterator = function () { }, $jscomp.iteratorPrototype = function (e) { return (e = { next: e })[Symbol.iterator] = function () { return this }, e }, $jscomp.iteratorFromArray = function (e, t) { e instanceof String && (e += ""); var i = 0, n = { next: function () { if (i < e.length) { var s = i++; return { value: t(s, e[s]), done: !1 } } return n.next = function () { return { done: !0, value: void 0 } }, n.next() } }; return n[Symbol.iterator] = function () { return n }, n }, $jscomp.polyfill("Array.prototype.keys", (function (e) { return e || function () { return $jscomp.iteratorFromArray(this, (function (e) { return e })) } }), "es6", "es3"); var scrollCue = function () { var e, t, i, n = {}, s = 0, r = !0, o = !0, a = !1, l = !1, c = { duration: 600, interval: -.7, percentage: .75, enable: !0, docSlider: !1, pageChangeReset: !1 }; return n = { setEvents: function (e) { var t = function () { r && (requestAnimationFrame((function () { r = !0, o && (n.setQuery(), n.runQuery()) })), r = !1) }; if (o && !e && window.addEventListener("load", n.runQuery), window.addEventListener("scroll", t), a) { e = docSlider.getElements().pages; for (var i = 0; i < e.length; i++)e[i].addEventListener("scroll", (function (e) { if (docSlider.getCurrentIndex() + "" !== (e = e.target.getAttribute("data-ds-index"))) return !1; docSlider._getWheelEnable() && t() })) } window.addEventListener("resize", (function () { 0 < s && clearTimeout(s), s = setTimeout((function () { o && (n.searchElements(), n.setQuery(), n.runQuery()) }), 200) })) }, setOptions: function (e, t) { var i = {}; if (void 0 !== e) return Object.keys(e).forEach((function (s) { "[object Object]" === Object.prototype.toString.call(e[s]) ? i[s] = n.setOptions(e[s], t[s]) : (i[s] = e[s], void 0 !== t && void 0 !== t[s] && (i[s] = t[s])) })), i }, searchElements: function () { e = []; for (var t = document.querySelectorAll("[data-cues]:not([data-disabled])"), s = 0; s < t.length; s++) { for (var r = t[s], o = 0; o < r.children.length; o++) { var l = r.children[o]; n.setAttrPtoC(l, "data-cue", r, "data-cues", ""), n.setAttrPtoC(l, "data-duration", r, "data-duration", !1), n.setAttrPtoC(l, "data-interval", r, "data-interval", !1), n.setAttrPtoC(l, "data-sort", r, "data-sort", !1), n.setAttrPtoC(l, "data-addClass", r, "data-addClass", !1), n.setAttrPtoC(l, "data-group", r, "data-group", !1), n.setAttrPtoC(l, "data-delay", r, "data-delay", !1) } r.setAttribute("data-disabled", "true") } for (t = document.querySelectorAll('[data-cue]:not([data-show="true"])'), s = 0; s < t.length; s++)r = t[s], e.push({ elm: r, cue: n.getAttr(r, "data-cue", "fadeIn"), duration: Number(n.getAttr(r, "data-duration", i.duration)), interval: Number(n.getAttr(r, "data-interval", i.interval)), order: n.getOrderNumber(r), sort: n.getAttr(r, "data-sort", null), addClass: n.getAttr(r, "data-addClass", null), group: n.getAttr(r, "data-group", null), delay: Number(n.getAttr(r, "data-delay", 0)) }); if (a) for (t = docSlider.getElements().pages.length, s = 0; s < t; s++)for (r = document.querySelectorAll('[data-ds-index="' + s + '"] [data-cue]:not([data-scpage])'), o = 0; o < r.length; o++)r[o].setAttribute("data-scpage", s) }, sortElements: function () { for (var e = arguments[0], t = [].slice.call(arguments).slice(1), i = { $jscomp$loop$prop$i$4: 0 }; i.$jscomp$loop$prop$i$4 < t.length; (i = { $jscomp$loop$prop$i$4: i.$jscomp$loop$prop$i$4 }).$jscomp$loop$prop$i$4++)e.sort(function (e) { return function (i, n) { var s = void 0 === t[e.$jscomp$loop$prop$i$4][1] || t[e.$jscomp$loop$prop$i$4][1], r = t[e.$jscomp$loop$prop$i$4][0]; return i[r] > n[r] ? s ? 1 : -1 : i[r] < n[r] ? s ? -1 : 1 : 0 } }(i)) }, randElements: function (e) { for (var t = e.length - 1; 0 < t; t--) { var i = Math.floor(Math.random() * (t + 1)), n = e[t]; e[t] = e[i], e[i] = n } return e }, setDurationValue: function (e, t, i) { return void 0 === t ? e : (t = t.duration, 0 > (e = -1 === (i + "").indexOf(".") ? e + t + i : e + t + t * i) ? 0 : e) }, getOrderNumber: function (e) { return e.hasAttribute("data-order") ? 0 <= (e = Number(e.getAttribute("data-order"))) ? e : Math.pow(2, 53) - 1 + e : Math.pow(2, 52) - 1 }, setAttrPtoC: function (e, t, i, n, s) { i.hasAttribute(n) ? e.hasAttribute(t) || e.setAttribute(t, i.getAttribute(n)) : !1 !== s && e.setAttribute(t, s) }, getAttr: function (e, t, i) { return e.hasAttribute(t) ? e.getAttribute(t) : i }, getOffsetTop: function (e) { return e.getBoundingClientRect().top + (window.pageYOffset || document.documentElement.scrollTop) }, setClassNames: function (e, t) { if (t) { t = t.split(" "); for (var i = 0; i < t.length; i++)e.classList.add(t[i]) } }, setQuery: function () { t = {}; for (var i = 0; i < e.length; i++) { var s = e[i], r = s.group ? s.group : "$" + n.getOffsetTop(s.elm); if (!s.elm.hasAttribute("data-show")) { if (a) { var o = s.elm.getAttribute("data-scpage"); if (o !== docSlider.getCurrentIndex() + "" && null !== o) continue } void 0 === t[r] && (t[r] = []), t[r].push(s) } } }, runQuery: function () { for (var e = Object.keys(t), i = {}, s = 0; s < e.length; i = { $jscomp$loop$prop$elms$6: i.$jscomp$loop$prop$elms$6, $jscomp$loop$prop$interval$7: i.$jscomp$loop$prop$interval$7 }, s++)if (i.$jscomp$loop$prop$elms$6 = t[e[s]], n.isElementIn(i.$jscomp$loop$prop$elms$6[0].elm)) { "reverse" === i.$jscomp$loop$prop$elms$6[0].sort ? i.$jscomp$loop$prop$elms$6.reverse() : "random" === i.$jscomp$loop$prop$elms$6[0].sort && n.randElements(i.$jscomp$loop$prop$elms$6), n.sortElements(i.$jscomp$loop$prop$elms$6, ["order"]); for (var r = i.$jscomp$loop$prop$interval$7 = 0; r < i.$jscomp$loop$prop$elms$6.length; r++)!function (e) { return function (t) { e.$jscomp$loop$prop$elms$6[t].elm.setAttribute("data-show", "true"), n.setClassNames(e.$jscomp$loop$prop$elms$6[t].elm, e.$jscomp$loop$prop$elms$6[t].addClass), e.$jscomp$loop$prop$interval$7 = n.setDurationValue(e.$jscomp$loop$prop$interval$7, e.$jscomp$loop$prop$elms$6[t - 1], e.$jscomp$loop$prop$elms$6[t].interval), e.$jscomp$loop$prop$elms$6[t].elm.style.animationName = e.$jscomp$loop$prop$elms$6[t].cue, e.$jscomp$loop$prop$elms$6[t].elm.style.animationDuration = e.$jscomp$loop$prop$elms$6[t].duration + "ms", e.$jscomp$loop$prop$elms$6[t].elm.style.animationTimingFunction = "ease", e.$jscomp$loop$prop$elms$6[t].elm.style.animationDelay = e.$jscomp$loop$prop$interval$7 + e.$jscomp$loop$prop$elms$6[t].delay + "ms", e.$jscomp$loop$prop$elms$6[t].elm.style.animationDirection = "normal", e.$jscomp$loop$prop$elms$6[t].elm.style.animationFillMode = "both" } }(i)(r); delete t[e[s]] } }, isElementIn: function (e) { var t = e.hasAttribute("data-scpage") ? n.isScrollEndWithDocSlider : n.isScrollEnd; return window.pageYOffset > n.getOffsetTop(e) - window.innerHeight * i.percentage || t() }, isScrollEnd: function () { var e = window.document.documentElement; return (window.document.body.scrollTop || e.scrollTop) >= e.scrollHeight - e.clientHeight }, isScrollEndWithDocSlider: function () { var e = docSlider.getCurrentPage(); return e.scrollTop >= e.scrollHeight - e.clientHeight } }, { init: function (e) { i = n.setOptions(c, e), o = i.enable, a = i.docSlider, l = i.pageChangeReset, a || (n.setEvents(), n.searchElements(), n.setQuery()) }, update: function () { o && (n.searchElements(), n.setQuery(), n.runQuery()) }, enable: function (e) { o = void 0 === e ? !o : e, scrollCue.update() }, _hasDocSlider: function () { return a }, _hasPageChangeReset: function () { return l }, _initWithDocSlider: function (e) { n.setEvents(e), n.searchElements(), n.setQuery() }, _updateWithDocSlider: function () { o && (n.setQuery(), n.runQuery()) }, _searchElements: function () { n.searchElements() } } }();
/*!
 * Smooth Scroll behavior polyfill
 * https://iamdustan.github.io/smoothscroll
 */function polyfill() { var e = window, t = document; if (!("scrollBehavior" in t.documentElement.style) || !0 === e.__forceSmoothScrollPolyfill__) { var i, n = e.HTMLElement || e.Element, s = 468, r = { scroll: e.scroll || e.scrollTo, scrollBy: e.scrollBy, elementScroll: n.prototype.scroll || l, scrollIntoView: n.prototype.scrollIntoView }, o = e.performance && e.performance.now ? e.performance.now.bind(e.performance) : Date.now, a = (i = e.navigator.userAgent, new RegExp(["MSIE ", "Trident/", "Edge/"].join("|")).test(i) ? 1 : 0); e.scroll = e.scrollTo = function () { void 0 !== arguments[0] && (!0 !== c(arguments[0]) ? f.call(e, t.body, void 0 !== arguments[0].left ? ~~arguments[0].left : e.scrollX || e.pageXOffset, void 0 !== arguments[0].top ? ~~arguments[0].top : e.scrollY || e.pageYOffset) : r.scroll.call(e, void 0 !== arguments[0].left ? arguments[0].left : "object" != typeof arguments[0] ? arguments[0] : e.scrollX || e.pageXOffset, void 0 !== arguments[0].top ? arguments[0].top : void 0 !== arguments[1] ? arguments[1] : e.scrollY || e.pageYOffset)) }, e.scrollBy = function () { void 0 !== arguments[0] && (c(arguments[0]) ? r.scrollBy.call(e, void 0 !== arguments[0].left ? arguments[0].left : "object" != typeof arguments[0] ? arguments[0] : 0, void 0 !== arguments[0].top ? arguments[0].top : void 0 !== arguments[1] ? arguments[1] : 0) : f.call(e, t.body, ~~arguments[0].left + (e.scrollX || e.pageXOffset), ~~arguments[0].top + (e.scrollY || e.pageYOffset))) }, n.prototype.scroll = n.prototype.scrollTo = function () { if (void 0 !== arguments[0]) if (!0 !== c(arguments[0])) { var e = arguments[0].left, t = arguments[0].top; f.call(this, this, void 0 === e ? this.scrollLeft : ~~e, void 0 === t ? this.scrollTop : ~~t) } else { if ("number" == typeof arguments[0] && void 0 === arguments[1]) throw new SyntaxError("Value could not be converted"); r.elementScroll.call(this, void 0 !== arguments[0].left ? ~~arguments[0].left : "object" != typeof arguments[0] ? ~~arguments[0] : this.scrollLeft, void 0 !== arguments[0].top ? ~~arguments[0].top : void 0 !== arguments[1] ? ~~arguments[1] : this.scrollTop) } }, n.prototype.scrollBy = function () { void 0 !== arguments[0] && (!0 !== c(arguments[0]) ? this.scroll({ left: ~~arguments[0].left + this.scrollLeft, top: ~~arguments[0].top + this.scrollTop, behavior: arguments[0].behavior }) : r.elementScroll.call(this, void 0 !== arguments[0].left ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, void 0 !== arguments[0].top ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop)) }, n.prototype.scrollIntoView = function () { if (!0 !== c(arguments[0])) { var i = function (e) { for (; e !== t.body && !1 === h(e);)e = e.parentNode || e.host; return e }(this), n = i.getBoundingClientRect(), s = this.getBoundingClientRect(); i !== t.body ? (f.call(this, i, i.scrollLeft + s.left - n.left, i.scrollTop + s.top - n.top), "fixed" !== e.getComputedStyle(i).position && e.scrollBy({ left: n.left, top: n.top, behavior: "smooth" })) : e.scrollBy({ left: s.left, top: s.top, behavior: "smooth" }) } else r.scrollIntoView.call(this, void 0 === arguments[0] || arguments[0]) } } function l(e, t) { this.scrollLeft = e, this.scrollTop = t } function c(e) { if (null === e || "object" != typeof e || void 0 === e.behavior || "auto" === e.behavior || "instant" === e.behavior) return !0; if ("object" == typeof e && "smooth" === e.behavior) return !1; throw new TypeError("behavior member of ScrollOptions " + e.behavior + " is not a valid value for enumeration ScrollBehavior.") } function d(e, t) { return "Y" === t ? e.clientHeight + a < e.scrollHeight : "X" === t ? e.clientWidth + a < e.scrollWidth : void 0 } function u(t, i) { var n = e.getComputedStyle(t, null)["overflow" + i]; return "auto" === n || "scroll" === n } function h(e) { var t = d(e, "Y") && u(e, "Y"), i = d(e, "X") && u(e, "X"); return t || i } function p(t) { var i, n, r, a, l = (o() - t.startTime) / s; a = l = l > 1 ? 1 : l, i = .5 * (1 - Math.cos(Math.PI * a)), n = t.startX + (t.x - t.startX) * i, r = t.startY + (t.y - t.startY) * i, t.method.call(t.scrollable, n, r), n === t.x && r === t.y || e.requestAnimationFrame(p.bind(e, t)) } function f(i, n, s) { var a, c, d, u, h = o(); i === t.body ? (a = e, c = e.scrollX || e.pageXOffset, d = e.scrollY || e.pageYOffset, u = r.scroll) : (a = i, c = i.scrollLeft, d = i.scrollTop, u = l), p({ scrollable: a, method: u, startTime: h, startX: c, startY: d, x: n, y: s }) } } "object" == typeof exports && "undefined" != typeof module ? module.exports = { polyfill: polyfill } : polyfill()
/*!
 * SVGInject v1.2.3
 * https://github.com/iconfu/svg-inject
 */, function (e, t) { var i, n, s = "createElement", r = "getElementsByTagName", o = "length", a = "style", l = "title", c = "undefined", d = "setAttribute", u = "getAttribute", h = null, p = "__svgInject", f = "--inject-", m = new RegExp(f + "\\d+", "g"), g = "LOAD_FAIL", v = "SVG_INVALID", y = ["src", "alt", "onload", "onerror"], b = t[s]("a"), w = typeof SVGRect != c, x = { useCache: !0, copyAttributes: !0, makeIdsUnique: !0 }, _ = { clipPath: ["clip-path"], "color-profile": h, cursor: h, filter: h, linearGradient: ["fill", "stroke"], marker: ["marker", "marker-end", "marker-mid", "marker-start"], mask: h, pattern: ["fill", "stroke"], radialGradient: ["fill", "stroke"] }, T = 2, E = 1; function S(e) { return (i = i || new XMLSerializer).serializeToString(e) } function C(e, t) { var i, n, s, l, c = f + E++, p = /url\("?#([a-zA-Z][\w:.-]*)"?\)/g, m = e.querySelectorAll("[id]"), g = t ? [] : h, v = {}, y = [], b = !1; if (m[o]) { for (s = 0; s < m[o]; s++)(n = m[s].localName) in _ && (v[n] = 1); for (n in v) (_[n] || [n]).forEach((function (e) { y.indexOf(e) < 0 && y.push(e) })); y[o] && y.push(a); var w, x, T, S = e[r]("*"), C = e; for (s = -1; C != h;) { if (C.localName == a) (T = (x = C.textContent) && x.replace(p, (function (e, t) { return g && (g[t] = 1), "url(#" + t + c + ")" }))) !== x && (C.textContent = T); else if (C.hasAttributes()) { for (l = 0; l < y[o]; l++)w = y[l], (T = (x = C[u](w)) && x.replace(p, (function (e, t) { return g && (g[t] = 1), "url(#" + t + c + ")" }))) !== x && C[d](w, T);["xlink:href", "href"].forEach((function (e) { var t = C[u](e); /^\s*#/.test(t) && (t = t.trim(), C[d](e, t + c), g && (g[t.substring(1)] = 1)) })) } C = S[++s] } for (s = 0; s < m[o]; s++)i = m[s], g && !g[i.id] || (i.id += c, b = !0) } return b } function k(e, i, n, r) { if (i) { i[d]("data-inject-url", n); var a = e.parentNode; if (a) { r.copyAttributes && function (e, i) { for (var n, r, a, c = e.attributes, u = 0; u < c[o]; u++)if (r = (n = c[u]).name, -1 == y.indexOf(r)) if (a = n.value, r == l) { var h, p = i.firstElementChild; p && p.localName.toLowerCase() == l ? h = p : (h = t[s + "NS"]("http://www.w3.org/2000/svg", l), i.insertBefore(h, p)), h.textContent = a } else i[d](r, a) }(e, i); var c = r.beforeInject, u = c && c(e, i) || i; a.replaceChild(u, e), e[p] = 1, M(e); var h = r.afterInject; h && h(e, u) } } else L(e, r) } function A() { for (var e = {}, t = arguments, i = 0; i < t[o]; i++) { var n = t[i]; for (var s in n) n.hasOwnProperty(s) && (e[s] = n[s]) } return e } function $(e, i) { if (i) { var s; try { s = function (e) { return (n = n || new DOMParser).parseFromString(e, "text/xml") }(e) } catch (e) { return h } return s[r]("parsererror")[o] ? h : s.documentElement } var a = t.createElement("div"); return a.innerHTML = e, a.firstElementChild } function M(e) { e.removeAttribute("onload") } function P(e) { console.error("SVGInject: " + e) } function I(e, t, i) { e[p] = T, i.onFail ? i.onFail(e, t) : P(t) } function L(e, t) { M(e), I(e, v, t) } function O(e, t) { M(e), I(e, "SVG_NOT_SUPPORTED", t) } function z(e, t) { I(e, g, t) } function D(e) { e.onload = h, e.onerror = h } function N(e) { P("no img element") } var j = function i(n, l) { var d = A(x, l), y = {}; function _(e, t) { t = A(d, t); var i = function (i) { var n = function () { var e = t.onAllFinish; e && e(), i && i() }; if (e && typeof e[o] != c) { var s = 0, r = e[o]; if (0 == r) n(); else for (var a = function () { ++s == r && n() }, l = 0; l < r; l++)P(e[l], t, a) } else P(e, t, n) }; return typeof Promise == c ? i() : new Promise(i) } function P(e, t, i) { if (e) { var n = e[p]; if (n) Array.isArray(n) ? n.push(i) : i(); else { if (D(e), !w) return O(e, t), void i(); var s = t.beforeLoad, r = s && s(e) || e[u]("src"); if (!r) return "" === r && z(e, t), void i(); var o = []; e[p] = o; var a = function () { i(), o.forEach((function (e) { e() })) }, l = function (e) { return b.href = e, b.href }(r), d = t.useCache, x = t.makeIdsUnique, _ = function (e) { d && (y[l].forEach((function (t) { t(e) })), y[l] = e) }; if (d) { var T, A = function (i) { if (i === g) z(e, t); else if (i === v) L(e, t); else { var n, s = i[0], r = i[1], o = i[2]; x && (s === h ? (s = C(n = $(r, !1), !1), i[0] = s, i[2] = s && S(n)) : s && (r = function (e) { return e.replace(m, f + E++) }(o))), n = n || $(r, !1), k(e, n, l, t) } a() }; if (typeof (T = y[l]) != c) return void (T.isCallbackQueue ? T.push(A) : A(T)); (T = []).isCallbackQueue = !0, y[l] = T } !function (e, t, i) { if (e) { var n = new XMLHttpRequest; n.onreadystatechange = function () { if (4 == n.readyState) { var e = n.status; 200 == e ? t(n.responseXML, n.responseText.trim()) : (400 <= e || 0 == e) && i() } }, n.open("GET", e, !0), n.send() } }(l, (function (i, n) { var s = i instanceof Document ? i.documentElement : $(n, !0), r = t.afterLoad; if (r) { var o = r(s, n) || s; if (o) { var c = "string" == typeof o; n = c ? o : S(s), s = c ? $(o, !0) : o } } if (s instanceof SVGElement) { var u = h; if (x && (u = C(s, !1)), d) { var p = u && S(s); _([u, n, p]) } k(e, s, l, t) } else L(e, t), _(v); a() }), (function () { z(e, t), _(g), a() })) } } else N() } return w && function (e) { var i = t[r]("head")[0]; if (i) { var n = t[s](a); n.type = "text/css", n.appendChild(t.createTextNode(e)), i.appendChild(n) } }('img[onload^="' + n + '("]{visibility:hidden;}'), _.setOptions = function (e) { d = A(d, e) }, _.create = i, _.err = function (e, t) { e ? e[p] != T && (D(e), w ? (M(e), z(e, d)) : O(e, d), t && (M(e), e.src = t)) : N() }, e[n] = _ }("SVGInject"); "object" == typeof module && "object" == typeof module.exports && (module.exports = j) }(window, document), function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).Swiper = t() }(this, (function () { "use strict"; function e(e) { return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object } function t(i, n) { void 0 === i && (i = {}), void 0 === n && (n = {}), Object.keys(n).forEach((s => { void 0 === i[s] ? i[s] = n[s] : e(n[s]) && e(i[s]) && Object.keys(n[s]).length > 0 && t(i[s], n[s]) })) } const i = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector: () => null, querySelectorAll: () => [], getElementById: () => null, createEvent: () => ({ initEvent() { } }), createElement: () => ({ children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName: () => [] }), createElementNS: () => ({}), importNode: () => null, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function n() { const e = "undefined" != typeof document ? document : {}; return t(e, i), e } const s = { document: i, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle: () => ({ getPropertyValue: () => "" }), Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia: () => ({}), requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0), cancelAnimationFrame(e) { "undefined" != typeof setTimeout && clearTimeout(e) } }; function r() { const e = "undefined" != typeof window ? window : {}; return t(e, s), e } class o extends Array { constructor(e) { "number" == typeof e ? super(e) : (super(...e || []), function (e) { const t = e.__proto__; Object.defineProperty(e, "__proto__", { get: () => t, set(e) { t.__proto__ = e } }) }(this)) } } function a(e) { void 0 === e && (e = []); const t = []; return e.forEach((e => { Array.isArray(e) ? t.push(...a(e)) : t.push(e) })), t } function l(e, t) { return Array.prototype.filter.call(e, t) } function c(e, t) { const i = r(), s = n(); let a = []; if (!t && e instanceof o) return e; if (!e) return new o(a); if ("string" == typeof e) { const i = e.trim(); if (i.indexOf("<") >= 0 && i.indexOf(">") >= 0) { let e = "div"; 0 === i.indexOf("<li") && (e = "ul"), 0 === i.indexOf("<tr") && (e = "tbody"), 0 !== i.indexOf("<td") && 0 !== i.indexOf("<th") || (e = "tr"), 0 === i.indexOf("<tbody") && (e = "table"), 0 === i.indexOf("<option") && (e = "select"); const t = s.createElement(e); t.innerHTML = i; for (let e = 0; e < t.childNodes.length; e += 1)a.push(t.childNodes[e]) } else a = function (e, t) { if ("string" != typeof e) return [e]; const i = [], n = t.querySelectorAll(e); for (let e = 0; e < n.length; e += 1)i.push(n[e]); return i }(e.trim(), t || s) } else if (e.nodeType || e === i || e === s) a.push(e); else if (Array.isArray(e)) { if (e instanceof o) return e; a = e } return new o(function (e) { const t = []; for (let i = 0; i < e.length; i += 1)-1 === t.indexOf(e[i]) && t.push(e[i]); return t }(a)) } c.fn = o.prototype; const d = { addClass: function () { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; const n = a(t.map((e => e.split(" ")))); return this.forEach((e => { e.classList.add(...n) })), this }, removeClass: function () { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; const n = a(t.map((e => e.split(" ")))); return this.forEach((e => { e.classList.remove(...n) })), this }, hasClass: function () { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; const n = a(t.map((e => e.split(" ")))); return l(this, (e => n.filter((t => e.classList.contains(t))).length > 0)).length > 0 }, toggleClass: function () { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; const n = a(t.map((e => e.split(" ")))); this.forEach((e => { n.forEach((t => { e.classList.toggle(t) })) })) }, attr: function (e, t) { if (1 === arguments.length && "string" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0; for (let i = 0; i < this.length; i += 1)if (2 === arguments.length) this[i].setAttribute(e, t); else for (const t in e) this[i][t] = e[t], this[i].setAttribute(t, e[t]); return this }, removeAttr: function (e) { for (let t = 0; t < this.length; t += 1)this[t].removeAttribute(e); return this }, transform: function (e) { for (let t = 0; t < this.length; t += 1)this[t].style.transform = e; return this }, transition: function (e) { for (let t = 0; t < this.length; t += 1)this[t].style.transitionDuration = "string" != typeof e ? `${e}ms` : e; return this }, on: function () { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; let [n, s, r, o] = t; function a(e) { const t = e.target; if (!t) return; const i = e.target.dom7EventData || []; if (i.indexOf(e) < 0 && i.unshift(e), c(t).is(s)) r.apply(t, i); else { const e = c(t).parents(); for (let t = 0; t < e.length; t += 1)c(e[t]).is(s) && r.apply(e[t], i) } } function l(e) { const t = e && e.target && e.target.dom7EventData || []; t.indexOf(e) < 0 && t.unshift(e), r.apply(this, t) } "function" == typeof t[1] && ([n, r, o] = t, s = void 0), o || (o = !1); const d = n.split(" "); let u; for (let e = 0; e < this.length; e += 1) { const t = this[e]; if (s) for (u = 0; u < d.length; u += 1) { const e = d[u]; t.dom7LiveListeners || (t.dom7LiveListeners = {}), t.dom7LiveListeners[e] || (t.dom7LiveListeners[e] = []), t.dom7LiveListeners[e].push({ listener: r, proxyListener: a }), t.addEventListener(e, a, o) } else for (u = 0; u < d.length; u += 1) { const e = d[u]; t.dom7Listeners || (t.dom7Listeners = {}), t.dom7Listeners[e] || (t.dom7Listeners[e] = []), t.dom7Listeners[e].push({ listener: r, proxyListener: l }), t.addEventListener(e, l, o) } } return this }, off: function () { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; let [n, s, r, o] = t; "function" == typeof t[1] && ([n, r, o] = t, s = void 0), o || (o = !1); const a = n.split(" "); for (let e = 0; e < a.length; e += 1) { const t = a[e]; for (let e = 0; e < this.length; e += 1) { const i = this[e]; let n; if (!s && i.dom7Listeners ? n = i.dom7Listeners[t] : s && i.dom7LiveListeners && (n = i.dom7LiveListeners[t]), n && n.length) for (let e = n.length - 1; e >= 0; e -= 1) { const s = n[e]; r && s.listener === r || r && s.listener && s.listener.dom7proxy && s.listener.dom7proxy === r ? (i.removeEventListener(t, s.proxyListener, o), n.splice(e, 1)) : r || (i.removeEventListener(t, s.proxyListener, o), n.splice(e, 1)) } } } return this }, trigger: function () { const e = r(); for (var t = arguments.length, i = new Array(t), n = 0; n < t; n++)i[n] = arguments[n]; const s = i[0].split(" "), o = i[1]; for (let t = 0; t < s.length; t += 1) { const n = s[t]; for (let t = 0; t < this.length; t += 1) { const s = this[t]; if (e.CustomEvent) { const t = new e.CustomEvent(n, { detail: o, bubbles: !0, cancelable: !0 }); s.dom7EventData = i.filter(((e, t) => t > 0)), s.dispatchEvent(t), s.dom7EventData = [], delete s.dom7EventData } } } return this }, transitionEnd: function (e) { const t = this; return e && t.on("transitionend", (function i(n) { n.target === this && (e.call(this, n), t.off("transitionend", i)) })), this }, outerWidth: function (e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left")) } return this[0].offsetWidth } return null }, outerHeight: function (e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom")) } return this[0].offsetHeight } return null }, styles: function () { const e = r(); return this[0] ? e.getComputedStyle(this[0], null) : {} }, offset: function () { if (this.length > 0) { const e = r(), t = n(), i = this[0], s = i.getBoundingClientRect(), o = t.body, a = i.clientTop || o.clientTop || 0, l = i.clientLeft || o.clientLeft || 0, c = i === e ? e.scrollY : i.scrollTop, d = i === e ? e.scrollX : i.scrollLeft; return { top: s.top + c - a, left: s.left + d - l } } return null }, css: function (e, t) { const i = r(); let n; if (1 === arguments.length) { if ("string" != typeof e) { for (n = 0; n < this.length; n += 1)for (const t in e) this[n].style[t] = e[t]; return this } if (this[0]) return i.getComputedStyle(this[0], null).getPropertyValue(e) } if (2 === arguments.length && "string" == typeof e) { for (n = 0; n < this.length; n += 1)this[n].style[e] = t; return this } return this }, each: function (e) { return e ? (this.forEach(((t, i) => { e.apply(t, [t, i]) })), this) : this }, html: function (e) { if (void 0 === e) return this[0] ? this[0].innerHTML : null; for (let t = 0; t < this.length; t += 1)this[t].innerHTML = e; return this }, text: function (e) { if (void 0 === e) return this[0] ? this[0].textContent.trim() : null; for (let t = 0; t < this.length; t += 1)this[t].textContent = e; return this }, is: function (e) { const t = r(), i = n(), s = this[0]; let a, l; if (!s || void 0 === e) return !1; if ("string" == typeof e) { if (s.matches) return s.matches(e); if (s.webkitMatchesSelector) return s.webkitMatchesSelector(e); if (s.msMatchesSelector) return s.msMatchesSelector(e); for (a = c(e), l = 0; l < a.length; l += 1)if (a[l] === s) return !0; return !1 } if (e === i) return s === i; if (e === t) return s === t; if (e.nodeType || e instanceof o) { for (a = e.nodeType ? [e] : e, l = 0; l < a.length; l += 1)if (a[l] === s) return !0; return !1 } return !1 }, index: function () { let e, t = this[0]; if (t) { for (e = 0; null !== (t = t.previousSibling);)1 === t.nodeType && (e += 1); return e } }, eq: function (e) { if (void 0 === e) return this; const t = this.length; if (e > t - 1) return c([]); if (e < 0) { const i = t + e; return c(i < 0 ? [] : [this[i]]) } return c([this[e]]) }, append: function () { let e; const t = n(); for (let i = 0; i < arguments.length; i += 1) { e = i < 0 || arguments.length <= i ? void 0 : arguments[i]; for (let i = 0; i < this.length; i += 1)if ("string" == typeof e) { const n = t.createElement("div"); for (n.innerHTML = e; n.firstChild;)this[i].appendChild(n.firstChild) } else if (e instanceof o) for (let t = 0; t < e.length; t += 1)this[i].appendChild(e[t]); else this[i].appendChild(e) } return this }, prepend: function (e) { const t = n(); let i, s; for (i = 0; i < this.length; i += 1)if ("string" == typeof e) { const n = t.createElement("div"); for (n.innerHTML = e, s = n.childNodes.length - 1; s >= 0; s -= 1)this[i].insertBefore(n.childNodes[s], this[i].childNodes[0]) } else if (e instanceof o) for (s = 0; s < e.length; s += 1)this[i].insertBefore(e[s], this[i].childNodes[0]); else this[i].insertBefore(e, this[i].childNodes[0]); return this }, next: function (e) { return this.length > 0 ? e ? this[0].nextElementSibling && c(this[0].nextElementSibling).is(e) ? c([this[0].nextElementSibling]) : c([]) : this[0].nextElementSibling ? c([this[0].nextElementSibling]) : c([]) : c([]) }, nextAll: function (e) { const t = []; let i = this[0]; if (!i) return c([]); for (; i.nextElementSibling;) { const n = i.nextElementSibling; e ? c(n).is(e) && t.push(n) : t.push(n), i = n } return c(t) }, prev: function (e) { if (this.length > 0) { const t = this[0]; return e ? t.previousElementSibling && c(t.previousElementSibling).is(e) ? c([t.previousElementSibling]) : c([]) : t.previousElementSibling ? c([t.previousElementSibling]) : c([]) } return c([]) }, prevAll: function (e) { const t = []; let i = this[0]; if (!i) return c([]); for (; i.previousElementSibling;) { const n = i.previousElementSibling; e ? c(n).is(e) && t.push(n) : t.push(n), i = n } return c(t) }, parent: function (e) { const t = []; for (let i = 0; i < this.length; i += 1)null !== this[i].parentNode && (e ? c(this[i].parentNode).is(e) && t.push(this[i].parentNode) : t.push(this[i].parentNode)); return c(t) }, parents: function (e) { const t = []; for (let i = 0; i < this.length; i += 1) { let n = this[i].parentNode; for (; n;)e ? c(n).is(e) && t.push(n) : t.push(n), n = n.parentNode } return c(t) }, closest: function (e) { let t = this; return void 0 === e ? c([]) : (t.is(e) || (t = t.parents(e).eq(0)), t) }, find: function (e) { const t = []; for (let i = 0; i < this.length; i += 1) { const n = this[i].querySelectorAll(e); for (let e = 0; e < n.length; e += 1)t.push(n[e]) } return c(t) }, children: function (e) { const t = []; for (let i = 0; i < this.length; i += 1) { const n = this[i].children; for (let i = 0; i < n.length; i += 1)e && !c(n[i]).is(e) || t.push(n[i]) } return c(t) }, filter: function (e) { return c(l(this, e)) }, remove: function () { for (let e = 0; e < this.length; e += 1)this[e].parentNode && this[e].parentNode.removeChild(this[e]); return this } }; function u(e, t) { return void 0 === t && (t = 0), setTimeout(e, t) } function h() { return Date.now() } function p(e, t) { void 0 === t && (t = "x"); const i = r(); let n, s, o; const a = function (e) { const t = r(); let i; return t.getComputedStyle && (i = t.getComputedStyle(e, null)), !i && e.currentStyle && (i = e.currentStyle), i || (i = e.style), i }(e); return i.WebKitCSSMatrix ? (s = a.transform || a.webkitTransform, s.split(",").length > 6 && (s = s.split(", ").map((e => e.replace(",", "."))).join(", ")), o = new i.WebKitCSSMatrix("none" === s ? "" : s)) : (o = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), n = o.toString().split(",")), "x" === t && (s = i.WebKitCSSMatrix ? o.m41 : 16 === n.length ? parseFloat(n[12]) : parseFloat(n[4])), "y" === t && (s = i.WebKitCSSMatrix ? o.m42 : 16 === n.length ? parseFloat(n[13]) : parseFloat(n[5])), s || 0 } function f(e) { return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1) } function m(e) { return "undefined" != typeof window && void 0 !== window.HTMLElement ? e instanceof HTMLElement : e && (1 === e.nodeType || 11 === e.nodeType) } function g() { const e = Object(arguments.length <= 0 ? void 0 : arguments[0]), t = ["__proto__", "constructor", "prototype"]; for (let i = 1; i < arguments.length; i += 1) { const n = i < 0 || arguments.length <= i ? void 0 : arguments[i]; if (null != n && !m(n)) { const i = Object.keys(Object(n)).filter((e => t.indexOf(e) < 0)); for (let t = 0, s = i.length; t < s; t += 1) { const s = i[t], r = Object.getOwnPropertyDescriptor(n, s); void 0 !== r && r.enumerable && (f(e[s]) && f(n[s]) ? n[s].__swiper__ ? e[s] = n[s] : g(e[s], n[s]) : !f(e[s]) && f(n[s]) ? (e[s] = {}, n[s].__swiper__ ? e[s] = n[s] : g(e[s], n[s])) : e[s] = n[s]) } } } return e } function v(e, t, i) { e.style.setProperty(t, i) } function y(e) { let { swiper: t, targetPosition: i, side: n } = e; const s = r(), o = -t.translate; let a, l = null; const c = t.params.speed; t.wrapperEl.style.scrollSnapType = "none", s.cancelAnimationFrame(t.cssModeFrameID); const d = i > o ? "next" : "prev", u = (e, t) => "next" === d && e >= t || "prev" === d && e <= t, h = () => { a = (new Date).getTime(), null === l && (l = a); const e = Math.max(Math.min((a - l) / c, 1), 0), r = .5 - Math.cos(e * Math.PI) / 2; let d = o + r * (i - o); if (u(d, i) && (d = i), t.wrapperEl.scrollTo({ [n]: d }), u(d, i)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout((() => { t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({ [n]: d }) })), void s.cancelAnimationFrame(t.cssModeFrameID); t.cssModeFrameID = s.requestAnimationFrame(h) }; h() } let b, w, x; function _() { return b || (b = function () { const e = r(), t = n(); return { smoothScroll: t.documentElement && "scrollBehavior" in t.documentElement.style, touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch), passiveListener: function () { let t = !1; try { const i = Object.defineProperty({}, "passive", { get() { t = !0 } }); e.addEventListener("testPassiveListener", null, i) } catch (e) { } return t }(), gestures: "ongesturestart" in e } }()), b } function T(e) { return void 0 === e && (e = {}), w || (w = function (e) { let { userAgent: t } = void 0 === e ? {} : e; const i = _(), n = r(), s = n.navigator.platform, o = t || n.navigator.userAgent, a = { ios: !1, android: !1 }, l = n.screen.width, c = n.screen.height, d = o.match(/(Android);?[\s\/]+([\d.]+)?/); let u = o.match(/(iPad).*OS\s([\d_]+)/); const h = o.match(/(iPod)(.*OS\s([\d_]+))?/), p = !u && o.match(/(iPhone\sOS|iOS)\s([\d_]+)/), f = "Win32" === s; let m = "MacIntel" === s; return !u && m && i.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${l}x${c}`) >= 0 && (u = o.match(/(Version)\/([\d.]+)/), u || (u = [0, 1, "13_0_0"]), m = !1), d && !f && (a.os = "android", a.android = !0), (u || p || h) && (a.os = "ios", a.ios = !0), a }(e)), w } function E() { return x || (x = function () { const e = r(); return { isSafari: function () { const t = e.navigator.userAgent.toLowerCase(); return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0 }(), isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent) } }()), x } Object.keys(d).forEach((e => { Object.defineProperty(c.fn, e, { value: d[e], writable: !0 }) })); var S = { on(e, t, i) { const n = this; if (!n.eventsListeners || n.destroyed) return n; if ("function" != typeof t) return n; const s = i ? "unshift" : "push"; return e.split(" ").forEach((e => { n.eventsListeners[e] || (n.eventsListeners[e] = []), n.eventsListeners[e][s](t) })), n }, once(e, t, i) { const n = this; if (!n.eventsListeners || n.destroyed) return n; if ("function" != typeof t) return n; function s() { n.off(e, s), s.__emitterProxy && delete s.__emitterProxy; for (var i = arguments.length, r = new Array(i), o = 0; o < i; o++)r[o] = arguments[o]; t.apply(n, r) } return s.__emitterProxy = t, n.on(e, s, i) }, onAny(e, t) { const i = this; if (!i.eventsListeners || i.destroyed) return i; if ("function" != typeof e) return i; const n = t ? "unshift" : "push"; return i.eventsAnyListeners.indexOf(e) < 0 && i.eventsAnyListeners[n](e), i }, offAny(e) { const t = this; if (!t.eventsListeners || t.destroyed) return t; if (!t.eventsAnyListeners) return t; const i = t.eventsAnyListeners.indexOf(e); return i >= 0 && t.eventsAnyListeners.splice(i, 1), t }, off(e, t) { const i = this; return !i.eventsListeners || i.destroyed ? i : i.eventsListeners ? (e.split(" ").forEach((e => { void 0 === t ? i.eventsListeners[e] = [] : i.eventsListeners[e] && i.eventsListeners[e].forEach(((n, s) => { (n === t || n.__emitterProxy && n.__emitterProxy === t) && i.eventsListeners[e].splice(s, 1) })) })), i) : i }, emit() { const e = this; if (!e.eventsListeners || e.destroyed) return e; if (!e.eventsListeners) return e; let t, i, n; for (var s = arguments.length, r = new Array(s), o = 0; o < s; o++)r[o] = arguments[o]; return "string" == typeof r[0] || Array.isArray(r[0]) ? (t = r[0], i = r.slice(1, r.length), n = e) : (t = r[0].events, i = r[0].data, n = r[0].context || e), i.unshift(n), (Array.isArray(t) ? t : t.split(" ")).forEach((t => { e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e => { e.apply(n, [t, ...i]) })), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((e => { e.apply(n, i) })) })), e } }, C = { updateSize: function () { const e = this; let t, i; const n = e.$el; t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : n[0].clientWidth, i = void 0 !== e.params.height && null !== e.params.height ? e.params.height : n[0].clientHeight, 0 === t && e.isHorizontal() || 0 === i && e.isVertical() || (t = t - parseInt(n.css("padding-left") || 0, 10) - parseInt(n.css("padding-right") || 0, 10), i = i - parseInt(n.css("padding-top") || 0, 10) - parseInt(n.css("padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(i) && (i = 0), Object.assign(e, { width: t, height: i, size: e.isHorizontal() ? t : i })) }, updateSlides: function () { const e = this; function t(t) { return e.isHorizontal() ? t : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[t] } function i(e, i) { return parseFloat(e.getPropertyValue(t(i)) || 0) } const n = e.params, { $wrapperEl: s, size: r, rtlTranslate: o, wrongRTL: a } = e, l = e.virtual && n.virtual.enabled, c = l ? e.virtual.slides.length : e.slides.length, d = s.children(`.${e.params.slideClass}`), u = l ? e.virtual.slides.length : d.length; let h = []; const p = [], f = []; let m = n.slidesOffsetBefore; "function" == typeof m && (m = n.slidesOffsetBefore.call(e)); let g = n.slidesOffsetAfter; "function" == typeof g && (g = n.slidesOffsetAfter.call(e)); const y = e.snapGrid.length, b = e.slidesGrid.length; let w = n.spaceBetween, x = -m, _ = 0, T = 0; if (void 0 === r) return; "string" == typeof w && w.indexOf("%") >= 0 && (w = parseFloat(w.replace("%", "")) / 100 * r), e.virtualSize = -w, o ? d.css({ marginLeft: "", marginBottom: "", marginTop: "" }) : d.css({ marginRight: "", marginBottom: "", marginTop: "" }), n.centeredSlides && n.cssMode && (v(e.wrapperEl, "--swiper-centered-offset-before", ""), v(e.wrapperEl, "--swiper-centered-offset-after", "")); const E = n.grid && n.grid.rows > 1 && e.grid; let S; E && e.grid.initSlides(u); const C = "auto" === n.slidesPerView && n.breakpoints && Object.keys(n.breakpoints).filter((e => void 0 !== n.breakpoints[e].slidesPerView)).length > 0; for (let s = 0; s < u; s += 1) { S = 0; const o = d.eq(s); if (E && e.grid.updateSlide(s, o, u, t), "none" !== o.css("display")) { if ("auto" === n.slidesPerView) { C && (d[s].style[t("width")] = ""); const r = getComputedStyle(o[0]), a = o[0].style.transform, l = o[0].style.webkitTransform; if (a && (o[0].style.transform = "none"), l && (o[0].style.webkitTransform = "none"), n.roundLengths) S = e.isHorizontal() ? o.outerWidth(!0) : o.outerHeight(!0); else { const e = i(r, "width"), t = i(r, "padding-left"), n = i(r, "padding-right"), s = i(r, "margin-left"), a = i(r, "margin-right"), l = r.getPropertyValue("box-sizing"); if (l && "border-box" === l) S = e + s + a; else { const { clientWidth: i, offsetWidth: r } = o[0]; S = e + t + n + s + a + (r - i) } } a && (o[0].style.transform = a), l && (o[0].style.webkitTransform = l), n.roundLengths && (S = Math.floor(S)) } else S = (r - (n.slidesPerView - 1) * w) / n.slidesPerView, n.roundLengths && (S = Math.floor(S)), d[s] && (d[s].style[t("width")] = `${S}px`); d[s] && (d[s].swiperSlideSize = S), f.push(S), n.centeredSlides ? (x = x + S / 2 + _ / 2 + w, 0 === _ && 0 !== s && (x = x - r / 2 - w), 0 === s && (x = x - r / 2 - w), Math.abs(x) < .001 && (x = 0), n.roundLengths && (x = Math.floor(x)), T % n.slidesPerGroup == 0 && h.push(x), p.push(x)) : (n.roundLengths && (x = Math.floor(x)), (T - Math.min(e.params.slidesPerGroupSkip, T)) % e.params.slidesPerGroup == 0 && h.push(x), p.push(x), x = x + S + w), e.virtualSize += S + w, _ = S, T += 1 } } if (e.virtualSize = Math.max(e.virtualSize, r) + g, o && a && ("slide" === n.effect || "coverflow" === n.effect) && s.css({ width: `${e.virtualSize + n.spaceBetween}px` }), n.setWrapperSize && s.css({ [t("width")]: `${e.virtualSize + n.spaceBetween}px` }), E && e.grid.updateWrapperSize(S, h, t), !n.centeredSlides) { const t = []; for (let i = 0; i < h.length; i += 1) { let s = h[i]; n.roundLengths && (s = Math.floor(s)), h[i] <= e.virtualSize - r && t.push(s) } h = t, Math.floor(e.virtualSize - r) - Math.floor(h[h.length - 1]) > 1 && h.push(e.virtualSize - r) } if (0 === h.length && (h = [0]), 0 !== n.spaceBetween) { const i = e.isHorizontal() && o ? "marginLeft" : t("marginRight"); d.filter(((e, t) => !n.cssMode || t !== d.length - 1)).css({ [i]: `${w}px` }) } if (n.centeredSlides && n.centeredSlidesBounds) { let e = 0; f.forEach((t => { e += t + (n.spaceBetween ? n.spaceBetween : 0) })), e -= n.spaceBetween; const t = e - r; h = h.map((e => e < 0 ? -m : e > t ? t + g : e)) } if (n.centerInsufficientSlides) { let e = 0; if (f.forEach((t => { e += t + (n.spaceBetween ? n.spaceBetween : 0) })), e -= n.spaceBetween, e < r) { const t = (r - e) / 2; h.forEach(((e, i) => { h[i] = e - t })), p.forEach(((e, i) => { p[i] = e + t })) } } if (Object.assign(e, { slides: d, snapGrid: h, slidesGrid: p, slidesSizesGrid: f }), n.centeredSlides && n.cssMode && !n.centeredSlidesBounds) { v(e.wrapperEl, "--swiper-centered-offset-before", -h[0] + "px"), v(e.wrapperEl, "--swiper-centered-offset-after", e.size / 2 - f[f.length - 1] / 2 + "px"); const t = -e.snapGrid[0], i = -e.slidesGrid[0]; e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + i)) } if (u !== c && e.emit("slidesLengthChange"), h.length !== y && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), p.length !== b && e.emit("slidesGridLengthChange"), n.watchSlidesProgress && e.updateSlidesOffset(), !(l || n.cssMode || "slide" !== n.effect && "fade" !== n.effect)) { const t = `${n.containerModifierClass}backface-hidden`, i = e.$el.hasClass(t); u <= n.maxBackfaceHiddenSlides ? i || e.$el.addClass(t) : i && e.$el.removeClass(t) } }, updateAutoHeight: function (e) { const t = this, i = [], n = t.virtual && t.params.virtual.enabled; let s, r = 0; "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed); const o = e => n ? t.slides.filter((t => parseInt(t.getAttribute("data-swiper-slide-index"), 10) === e))[0] : t.slides.eq(e)[0]; if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1) if (t.params.centeredSlides) (t.visibleSlides || c([])).each((e => { i.push(e) })); else for (s = 0; s < Math.ceil(t.params.slidesPerView); s += 1) { const e = t.activeIndex + s; if (e > t.slides.length && !n) break; i.push(o(e)) } else i.push(o(t.activeIndex)); for (s = 0; s < i.length; s += 1)if (void 0 !== i[s]) { const e = i[s].offsetHeight; r = e > r ? e : r } (r || 0 === r) && t.$wrapperEl.css("height", `${r}px`) }, updateSlidesOffset: function () { const e = this, t = e.slides; for (let i = 0; i < t.length; i += 1)t[i].swiperSlideOffset = e.isHorizontal() ? t[i].offsetLeft : t[i].offsetTop }, updateSlidesProgress: function (e) { void 0 === e && (e = this && this.translate || 0); const t = this, i = t.params, { slides: n, rtlTranslate: s, snapGrid: r } = t; if (0 === n.length) return; void 0 === n[0].swiperSlideOffset && t.updateSlidesOffset(); let o = -e; s && (o = e), n.removeClass(i.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = []; for (let e = 0; e < n.length; e += 1) { const a = n[e]; let l = a.swiperSlideOffset; i.cssMode && i.centeredSlides && (l -= n[0].swiperSlideOffset); const c = (o + (i.centeredSlides ? t.minTranslate() : 0) - l) / (a.swiperSlideSize + i.spaceBetween), d = (o - r[0] + (i.centeredSlides ? t.minTranslate() : 0) - l) / (a.swiperSlideSize + i.spaceBetween), u = -(o - l), h = u + t.slidesSizesGrid[e]; (u >= 0 && u < t.size - 1 || h > 1 && h <= t.size || u <= 0 && h >= t.size) && (t.visibleSlides.push(a), t.visibleSlidesIndexes.push(e), n.eq(e).addClass(i.slideVisibleClass)), a.progress = s ? -c : c, a.originalProgress = s ? -d : d } t.visibleSlides = c(t.visibleSlides) }, updateProgress: function (e) { const t = this; if (void 0 === e) { const i = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * i || 0 } const i = t.params, n = t.maxTranslate() - t.minTranslate(); let { progress: s, isBeginning: r, isEnd: o } = t; const a = r, l = o; 0 === n ? (s = 0, r = !0, o = !0) : (s = (e - t.minTranslate()) / n, r = s <= 0, o = s >= 1), Object.assign(t, { progress: s, isBeginning: r, isEnd: o }), (i.watchSlidesProgress || i.centeredSlides && i.autoHeight) && t.updateSlidesProgress(e), r && !a && t.emit("reachBeginning toEdge"), o && !l && t.emit("reachEnd toEdge"), (a && !r || l && !o) && t.emit("fromEdge"), t.emit("progress", s) }, updateSlidesClasses: function () { const e = this, { slides: t, params: i, $wrapperEl: n, activeIndex: s, realIndex: r } = e, o = e.virtual && i.virtual.enabled; let a; t.removeClass(`${i.slideActiveClass} ${i.slideNextClass} ${i.slidePrevClass} ${i.slideDuplicateActiveClass} ${i.slideDuplicateNextClass} ${i.slideDuplicatePrevClass}`), a = o ? e.$wrapperEl.find(`.${i.slideClass}[data-swiper-slide-index="${s}"]`) : t.eq(s), a.addClass(i.slideActiveClass), i.loop && (a.hasClass(i.slideDuplicateClass) ? n.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${r}"]`).addClass(i.slideDuplicateActiveClass) : n.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${r}"]`).addClass(i.slideDuplicateActiveClass)); let l = a.nextAll(`.${i.slideClass}`).eq(0).addClass(i.slideNextClass); i.loop && 0 === l.length && (l = t.eq(0), l.addClass(i.slideNextClass)); let c = a.prevAll(`.${i.slideClass}`).eq(0).addClass(i.slidePrevClass); i.loop && 0 === c.length && (c = t.eq(-1), c.addClass(i.slidePrevClass)), i.loop && (l.hasClass(i.slideDuplicateClass) ? n.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicateNextClass) : n.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicateNextClass), c.hasClass(i.slideDuplicateClass) ? n.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicatePrevClass) : n.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicatePrevClass)), e.emitSlidesClasses() }, updateActiveIndex: function (e) { const t = this, i = t.rtlTranslate ? t.translate : -t.translate, { slidesGrid: n, snapGrid: s, params: r, activeIndex: o, realIndex: a, snapIndex: l } = t; let c, d = e; if (void 0 === d) { for (let e = 0; e < n.length; e += 1)void 0 !== n[e + 1] ? i >= n[e] && i < n[e + 1] - (n[e + 1] - n[e]) / 2 ? d = e : i >= n[e] && i < n[e + 1] && (d = e + 1) : i >= n[e] && (d = e); r.normalizeSlideIndex && (d < 0 || void 0 === d) && (d = 0) } if (s.indexOf(i) >= 0) c = s.indexOf(i); else { const e = Math.min(r.slidesPerGroupSkip, d); c = e + Math.floor((d - e) / r.slidesPerGroup) } if (c >= s.length && (c = s.length - 1), d === o) return void (c !== l && (t.snapIndex = c, t.emit("snapIndexChange"))); const u = parseInt(t.slides.eq(d).attr("data-swiper-slide-index") || d, 10); Object.assign(t, { snapIndex: c, realIndex: u, previousIndex: o, activeIndex: d }), t.emit("activeIndexChange"), t.emit("snapIndexChange"), a !== u && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange") }, updateClickedSlide: function (e) { const t = this, i = t.params, n = c(e).closest(`.${i.slideClass}`)[0]; let s, r = !1; if (n) for (let e = 0; e < t.slides.length; e += 1)if (t.slides[e] === n) { r = !0, s = e; break } if (!n || !r) return t.clickedSlide = void 0, void (t.clickedIndex = void 0); t.clickedSlide = n, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(c(n).attr("data-swiper-slide-index"), 10) : t.clickedIndex = s, i.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide() } }, k = { getTranslate: function (e) { void 0 === e && (e = this.isHorizontal() ? "x" : "y"); const { params: t, rtlTranslate: i, translate: n, $wrapperEl: s } = this; if (t.virtualTranslate) return i ? -n : n; if (t.cssMode) return n; let r = p(s[0], e); return i && (r = -r), r || 0 }, setTranslate: function (e, t) { const i = this, { rtlTranslate: n, params: s, $wrapperEl: r, wrapperEl: o, progress: a } = i; let l, c = 0, d = 0; i.isHorizontal() ? c = n ? -e : e : d = e, s.roundLengths && (c = Math.floor(c), d = Math.floor(d)), s.cssMode ? o[i.isHorizontal() ? "scrollLeft" : "scrollTop"] = i.isHorizontal() ? -c : -d : s.virtualTranslate || r.transform(`translate3d(${c}px, ${d}px, 0px)`), i.previousTranslate = i.translate, i.translate = i.isHorizontal() ? c : d; const u = i.maxTranslate() - i.minTranslate(); l = 0 === u ? 0 : (e - i.minTranslate()) / u, l !== a && i.updateProgress(e), i.emit("setTranslate", i.translate, t) }, minTranslate: function () { return -this.snapGrid[0] }, maxTranslate: function () { return -this.snapGrid[this.snapGrid.length - 1] }, translateTo: function (e, t, i, n, s) { void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === i && (i = !0), void 0 === n && (n = !0); const r = this, { params: o, wrapperEl: a } = r; if (r.animating && o.preventInteractionOnTransition) return !1; const l = r.minTranslate(), c = r.maxTranslate(); let d; if (d = n && e > l ? l : n && e < c ? c : e, r.updateProgress(d), o.cssMode) { const e = r.isHorizontal(); if (0 === t) a[e ? "scrollLeft" : "scrollTop"] = -d; else { if (!r.support.smoothScroll) return y({ swiper: r, targetPosition: -d, side: e ? "left" : "top" }), !0; a.scrollTo({ [e ? "left" : "top"]: -d, behavior: "smooth" }) } return !0 } return 0 === t ? (r.setTransition(0), r.setTranslate(d), i && (r.emit("beforeTransitionStart", t, s), r.emit("transitionEnd"))) : (r.setTransition(t), r.setTranslate(d), i && (r.emit("beforeTransitionStart", t, s), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, i && r.emit("transitionEnd")) }), r.$wrapperEl[0].addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd))), !0 } }; function A(e) { let { swiper: t, runCallbacks: i, direction: n, step: s } = e; const { activeIndex: r, previousIndex: o } = t; let a = n; if (a || (a = r > o ? "next" : r < o ? "prev" : "reset"), t.emit(`transition${s}`), i && r !== o) { if ("reset" === a) return void t.emit(`slideResetTransition${s}`); t.emit(`slideChangeTransition${s}`), "next" === a ? t.emit(`slideNextTransition${s}`) : t.emit(`slidePrevTransition${s}`) } } var $ = { slideTo: function (e, t, i, n, s) { if (void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === i && (i = !0), "number" != typeof e && "string" != typeof e) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`); if ("string" == typeof e) { const t = parseInt(e, 10); if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`); e = t } const r = this; let o = e; o < 0 && (o = 0); const { params: a, snapGrid: l, slidesGrid: c, previousIndex: d, activeIndex: u, rtlTranslate: h, wrapperEl: p, enabled: f } = r; if (r.animating && a.preventInteractionOnTransition || !f && !n && !s) return !1; const m = Math.min(r.params.slidesPerGroupSkip, o); let g = m + Math.floor((o - m) / r.params.slidesPerGroup); g >= l.length && (g = l.length - 1), (u || a.initialSlide || 0) === (d || 0) && i && r.emit("beforeSlideChangeStart"); const v = -l[g]; if (r.updateProgress(v), a.normalizeSlideIndex) for (let e = 0; e < c.length; e += 1) { const t = -Math.floor(100 * v), i = Math.floor(100 * c[e]), n = Math.floor(100 * c[e + 1]); void 0 !== c[e + 1] ? t >= i && t < n - (n - i) / 2 ? o = e : t >= i && t < n && (o = e + 1) : t >= i && (o = e) } if (r.initialized && o !== u) { if (!r.allowSlideNext && v < r.translate && v < r.minTranslate()) return !1; if (!r.allowSlidePrev && v > r.translate && v > r.maxTranslate() && (u || 0) !== o) return !1 } let b; if (b = o > u ? "next" : o < u ? "prev" : "reset", h && -v === r.translate || !h && v === r.translate) return r.updateActiveIndex(o), a.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== a.effect && r.setTranslate(v), "reset" !== b && (r.transitionStart(i, b), r.transitionEnd(i, b)), !1; if (a.cssMode) { const e = r.isHorizontal(), i = h ? v : -v; if (0 === t) { const t = r.virtual && r.params.virtual.enabled; t && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), p[e ? "scrollLeft" : "scrollTop"] = i, t && requestAnimationFrame((() => { r.wrapperEl.style.scrollSnapType = "", r._swiperImmediateVirtual = !1 })) } else { if (!r.support.smoothScroll) return y({ swiper: r, targetPosition: i, side: e ? "left" : "top" }), !0; p.scrollTo({ [e ? "left" : "top"]: i, behavior: "smooth" }) } return !0 } return r.setTransition(t), r.setTranslate(v), r.updateActiveIndex(o), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, n), r.transitionStart(i, b), 0 === t ? r.transitionEnd(i, b) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(i, b)) }), r.$wrapperEl[0].addEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd)), !0 }, slideToLoop: function (e, t, i, n) { if (void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === i && (i = !0), "string" == typeof e) { const t = parseInt(e, 10); if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`); e = t } const s = this; let r = e; return s.params.loop && (r += s.loopedSlides), s.slideTo(r, t, i, n) }, slideNext: function (e, t, i) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const n = this, { animating: s, enabled: r, params: o } = n; if (!r) return n; let a = o.slidesPerGroup; "auto" === o.slidesPerView && 1 === o.slidesPerGroup && o.slidesPerGroupAuto && (a = Math.max(n.slidesPerViewDynamic("current", !0), 1)); const l = n.activeIndex < o.slidesPerGroupSkip ? 1 : a; if (o.loop) { if (s && o.loopPreventsSlide) return !1; n.loopFix(), n._clientLeft = n.$wrapperEl[0].clientLeft } return o.rewind && n.isEnd ? n.slideTo(0, e, t, i) : n.slideTo(n.activeIndex + l, e, t, i) }, slidePrev: function (e, t, i) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const n = this, { params: s, animating: r, snapGrid: o, slidesGrid: a, rtlTranslate: l, enabled: c } = n; if (!c) return n; if (s.loop) { if (r && s.loopPreventsSlide) return !1; n.loopFix(), n._clientLeft = n.$wrapperEl[0].clientLeft } function d(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } const u = d(l ? n.translate : -n.translate), h = o.map((e => d(e))); let p = o[h.indexOf(u) - 1]; if (void 0 === p && s.cssMode) { let e; o.forEach(((t, i) => { u >= t && (e = i) })), void 0 !== e && (p = o[e > 0 ? e - 1 : e]) } let f = 0; if (void 0 !== p && (f = a.indexOf(p), f < 0 && (f = n.activeIndex - 1), "auto" === s.slidesPerView && 1 === s.slidesPerGroup && s.slidesPerGroupAuto && (f = f - n.slidesPerViewDynamic("previous", !0) + 1, f = Math.max(f, 0))), s.rewind && n.isBeginning) { const s = n.params.virtual && n.params.virtual.enabled && n.virtual ? n.virtual.slides.length - 1 : n.slides.length - 1; return n.slideTo(s, e, t, i) } return n.slideTo(f, e, t, i) }, slideReset: function (e, t, i) { return void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), this.slideTo(this.activeIndex, e, t, i) }, slideToClosest: function (e, t, i, n) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), void 0 === n && (n = .5); const s = this; let r = s.activeIndex; const o = Math.min(s.params.slidesPerGroupSkip, r), a = o + Math.floor((r - o) / s.params.slidesPerGroup), l = s.rtlTranslate ? s.translate : -s.translate; if (l >= s.snapGrid[a]) { const e = s.snapGrid[a]; l - e > (s.snapGrid[a + 1] - e) * n && (r += s.params.slidesPerGroup) } else { const e = s.snapGrid[a - 1]; l - e <= (s.snapGrid[a] - e) * n && (r -= s.params.slidesPerGroup) } return r = Math.max(r, 0), r = Math.min(r, s.slidesGrid.length - 1), s.slideTo(r, e, t, i) }, slideToClickedSlide: function () { const e = this, { params: t, $wrapperEl: i } = e, n = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView; let s, r = e.clickedIndex; if (t.loop) { if (e.animating) return; s = parseInt(c(e.clickedSlide).attr("data-swiper-slide-index"), 10), t.centeredSlides ? r < e.loopedSlides - n / 2 || r > e.slides.length - e.loopedSlides + n / 2 ? (e.loopFix(), r = i.children(`.${t.slideClass}[data-swiper-slide-index="${s}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), u((() => { e.slideTo(r) }))) : e.slideTo(r) : r > e.slides.length - n ? (e.loopFix(), r = i.children(`.${t.slideClass}[data-swiper-slide-index="${s}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), u((() => { e.slideTo(r) }))) : e.slideTo(r) } else e.slideTo(r) } }, M = { loopCreate: function () { const e = this, t = n(), { params: i, $wrapperEl: s } = e, r = s.children().length > 0 ? c(s.children()[0].parentNode) : s; r.children(`.${i.slideClass}.${i.slideDuplicateClass}`).remove(); let o = r.children(`.${i.slideClass}`); if (i.loopFillGroupWithBlank) { const e = i.slidesPerGroup - o.length % i.slidesPerGroup; if (e !== i.slidesPerGroup) { for (let n = 0; n < e; n += 1) { const e = c(t.createElement("div")).addClass(`${i.slideClass} ${i.slideBlankClass}`); r.append(e) } o = r.children(`.${i.slideClass}`) } } "auto" !== i.slidesPerView || i.loopedSlides || (i.loopedSlides = o.length), e.loopedSlides = Math.ceil(parseFloat(i.loopedSlides || i.slidesPerView, 10)), e.loopedSlides += i.loopAdditionalSlides, e.loopedSlides > o.length && e.params.loopedSlidesLimit && (e.loopedSlides = o.length); const a = [], l = []; o.each(((e, t) => { c(e).attr("data-swiper-slide-index", t) })); for (let t = 0; t < e.loopedSlides; t += 1) { const e = t - Math.floor(t / o.length) * o.length; l.push(o.eq(e)[0]), a.unshift(o.eq(o.length - e - 1)[0]) } for (let e = 0; e < l.length; e += 1)r.append(c(l[e].cloneNode(!0)).addClass(i.slideDuplicateClass)); for (let e = a.length - 1; e >= 0; e -= 1)r.prepend(c(a[e].cloneNode(!0)).addClass(i.slideDuplicateClass)) }, loopFix: function () { const e = this; e.emit("beforeLoopFix"); const { activeIndex: t, slides: i, loopedSlides: n, allowSlidePrev: s, allowSlideNext: r, snapGrid: o, rtlTranslate: a } = e; let l; e.allowSlidePrev = !0, e.allowSlideNext = !0; const c = -o[t] - e.getTranslate(); t < n ? (l = i.length - 3 * n + t, l += n, e.slideTo(l, 0, !1, !0) && 0 !== c && e.setTranslate((a ? -e.translate : e.translate) - c)) : t >= i.length - n && (l = -i.length + t + n, l += n, e.slideTo(l, 0, !1, !0) && 0 !== c && e.setTranslate((a ? -e.translate : e.translate) - c)), e.allowSlidePrev = s, e.allowSlideNext = r, e.emit("loopFix") }, loopDestroy: function () { const { $wrapperEl: e, params: t, slides: i } = this; e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), i.removeAttr("data-swiper-slide-index") } }; function P(e) { const t = this, i = n(), s = r(), o = t.touchEventsData, { params: a, touches: l, enabled: d } = t; if (!d) return; if (t.animating && a.preventInteractionOnTransition) return; !t.animating && a.cssMode && a.loop && t.loopFix(); let u = e; u.originalEvent && (u = u.originalEvent); let p = c(u.target); if ("wrapper" === a.touchEventsTarget && !p.closest(t.wrapperEl).length) return; if (o.isTouchEvent = "touchstart" === u.type, !o.isTouchEvent && "which" in u && 3 === u.which) return; if (!o.isTouchEvent && "button" in u && u.button > 0) return; if (o.isTouched && o.isMoved) return; a.noSwipingClass && "" !== a.noSwipingClass && u.target && u.target.shadowRoot && e.path && e.path[0] && (p = c(e.path[0])); const f = a.noSwipingSelector ? a.noSwipingSelector : `.${a.noSwipingClass}`, m = !(!u.target || !u.target.shadowRoot); if (a.noSwiping && (m ? function (e, t) { return void 0 === t && (t = this), function t(i) { if (!i || i === n() || i === r()) return null; i.assignedSlot && (i = i.assignedSlot); const s = i.closest(e); return s || i.getRootNode ? s || t(i.getRootNode().host) : null }(t) }(f, p[0]) : p.closest(f)[0])) return void (t.allowClick = !0); if (a.swipeHandler && !p.closest(a.swipeHandler)[0]) return; l.currentX = "touchstart" === u.type ? u.targetTouches[0].pageX : u.pageX, l.currentY = "touchstart" === u.type ? u.targetTouches[0].pageY : u.pageY; const g = l.currentX, v = l.currentY, y = a.edgeSwipeDetection || a.iOSEdgeSwipeDetection, b = a.edgeSwipeThreshold || a.iOSEdgeSwipeThreshold; if (y && (g <= b || g >= s.innerWidth - b)) { if ("prevent" !== y) return; e.preventDefault() } if (Object.assign(o, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), l.startX = g, l.startY = v, o.touchStartTime = h(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, a.threshold > 0 && (o.allowThresholdMove = !1), "touchstart" !== u.type) { let e = !0; p.is(o.focusableElements) && (e = !1, "SELECT" === p[0].nodeName && (o.isTouched = !1)), i.activeElement && c(i.activeElement).is(o.focusableElements) && i.activeElement !== p[0] && i.activeElement.blur(); const n = e && t.allowTouchMove && a.touchStartPreventDefault; !a.touchStartForcePreventDefault && !n || p[0].isContentEditable || u.preventDefault() } t.params.freeMode && t.params.freeMode.enabled && t.freeMode && t.animating && !a.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", u) } function I(e) { const t = n(), i = this, s = i.touchEventsData, { params: r, touches: o, rtlTranslate: a, enabled: l } = i; if (!l) return; let d = e; if (d.originalEvent && (d = d.originalEvent), !s.isTouched) return void (s.startMoving && s.isScrolling && i.emit("touchMoveOpposite", d)); if (s.isTouchEvent && "touchmove" !== d.type) return; const u = "touchmove" === d.type && d.targetTouches && (d.targetTouches[0] || d.changedTouches[0]), p = "touchmove" === d.type ? u.pageX : d.pageX, f = "touchmove" === d.type ? u.pageY : d.pageY; if (d.preventedByNestedSwiper) return o.startX = p, void (o.startY = f); if (!i.allowTouchMove) return c(d.target).is(s.focusableElements) || (i.allowClick = !1), void (s.isTouched && (Object.assign(o, { startX: p, startY: f, currentX: p, currentY: f }), s.touchStartTime = h())); if (s.isTouchEvent && r.touchReleaseOnEdges && !r.loop) if (i.isVertical()) { if (f < o.startY && i.translate <= i.maxTranslate() || f > o.startY && i.translate >= i.minTranslate()) return s.isTouched = !1, void (s.isMoved = !1) } else if (p < o.startX && i.translate <= i.maxTranslate() || p > o.startX && i.translate >= i.minTranslate()) return; if (s.isTouchEvent && t.activeElement && d.target === t.activeElement && c(d.target).is(s.focusableElements)) return s.isMoved = !0, void (i.allowClick = !1); if (s.allowTouchCallbacks && i.emit("touchMove", d), d.targetTouches && d.targetTouches.length > 1) return; o.currentX = p, o.currentY = f; const m = o.currentX - o.startX, g = o.currentY - o.startY; if (i.params.threshold && Math.sqrt(m ** 2 + g ** 2) < i.params.threshold) return; if (void 0 === s.isScrolling) { let e; i.isHorizontal() && o.currentY === o.startY || i.isVertical() && o.currentX === o.startX ? s.isScrolling = !1 : m * m + g * g >= 25 && (e = 180 * Math.atan2(Math.abs(g), Math.abs(m)) / Math.PI, s.isScrolling = i.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle) } if (s.isScrolling && i.emit("touchMoveOpposite", d), void 0 === s.startMoving && (o.currentX === o.startX && o.currentY === o.startY || (s.startMoving = !0)), s.isScrolling) return void (s.isTouched = !1); if (!s.startMoving) return; i.allowClick = !1, !r.cssMode && d.cancelable && d.preventDefault(), r.touchMoveStopPropagation && !r.nested && d.stopPropagation(), s.isMoved || (r.loop && !r.cssMode && i.loopFix(), s.startTranslate = i.getTranslate(), i.setTransition(0), i.animating && i.$wrapperEl.trigger("webkitTransitionEnd transitionend"), s.allowMomentumBounce = !1, !r.grabCursor || !0 !== i.allowSlideNext && !0 !== i.allowSlidePrev || i.setGrabCursor(!0), i.emit("sliderFirstMove", d)), i.emit("sliderMove", d), s.isMoved = !0; let v = i.isHorizontal() ? m : g; o.diff = v, v *= r.touchRatio, a && (v = -v), i.swipeDirection = v > 0 ? "prev" : "next", s.currentTranslate = v + s.startTranslate; let y = !0, b = r.resistanceRatio; if (r.touchReleaseOnEdges && (b = 0), v > 0 && s.currentTranslate > i.minTranslate() ? (y = !1, r.resistance && (s.currentTranslate = i.minTranslate() - 1 + (-i.minTranslate() + s.startTranslate + v) ** b)) : v < 0 && s.currentTranslate < i.maxTranslate() && (y = !1, r.resistance && (s.currentTranslate = i.maxTranslate() + 1 - (i.maxTranslate() - s.startTranslate - v) ** b)), y && (d.preventedByNestedSwiper = !0), !i.allowSlideNext && "next" === i.swipeDirection && s.currentTranslate < s.startTranslate && (s.currentTranslate = s.startTranslate), !i.allowSlidePrev && "prev" === i.swipeDirection && s.currentTranslate > s.startTranslate && (s.currentTranslate = s.startTranslate), i.allowSlidePrev || i.allowSlideNext || (s.currentTranslate = s.startTranslate), r.threshold > 0) { if (!(Math.abs(v) > r.threshold || s.allowThresholdMove)) return void (s.currentTranslate = s.startTranslate); if (!s.allowThresholdMove) return s.allowThresholdMove = !0, o.startX = o.currentX, o.startY = o.currentY, s.currentTranslate = s.startTranslate, void (o.diff = i.isHorizontal() ? o.currentX - o.startX : o.currentY - o.startY) } r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && i.freeMode || r.watchSlidesProgress) && (i.updateActiveIndex(), i.updateSlidesClasses()), i.params.freeMode && r.freeMode.enabled && i.freeMode && i.freeMode.onTouchMove(), i.updateProgress(s.currentTranslate), i.setTranslate(s.currentTranslate)) } function L(e) { const t = this, i = t.touchEventsData, { params: n, touches: s, rtlTranslate: r, slidesGrid: o, enabled: a } = t; if (!a) return; let l = e; if (l.originalEvent && (l = l.originalEvent), i.allowTouchCallbacks && t.emit("touchEnd", l), i.allowTouchCallbacks = !1, !i.isTouched) return i.isMoved && n.grabCursor && t.setGrabCursor(!1), i.isMoved = !1, void (i.startMoving = !1); n.grabCursor && i.isMoved && i.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); const c = h(), d = c - i.touchStartTime; if (t.allowClick) { const e = l.path || l.composedPath && l.composedPath(); t.updateClickedSlide(e && e[0] || l.target), t.emit("tap click", l), d < 300 && c - i.lastClickTime < 300 && t.emit("doubleTap doubleClick", l) } if (i.lastClickTime = h(), u((() => { t.destroyed || (t.allowClick = !0) })), !i.isTouched || !i.isMoved || !t.swipeDirection || 0 === s.diff || i.currentTranslate === i.startTranslate) return i.isTouched = !1, i.isMoved = !1, void (i.startMoving = !1); let p; if (i.isTouched = !1, i.isMoved = !1, i.startMoving = !1, p = n.followFinger ? r ? t.translate : -t.translate : -i.currentTranslate, n.cssMode) return; if (t.params.freeMode && n.freeMode.enabled) return void t.freeMode.onTouchEnd({ currentPos: p }); let f = 0, m = t.slidesSizesGrid[0]; for (let e = 0; e < o.length; e += e < n.slidesPerGroupSkip ? 1 : n.slidesPerGroup) { const t = e < n.slidesPerGroupSkip - 1 ? 1 : n.slidesPerGroup; void 0 !== o[e + t] ? p >= o[e] && p < o[e + t] && (f = e, m = o[e + t] - o[e]) : p >= o[e] && (f = e, m = o[o.length - 1] - o[o.length - 2]) } let g = null, v = null; n.rewind && (t.isBeginning ? v = t.params.virtual && t.params.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (g = 0)); const y = (p - o[f]) / m, b = f < n.slidesPerGroupSkip - 1 ? 1 : n.slidesPerGroup; if (d > n.longSwipesMs) { if (!n.longSwipes) return void t.slideTo(t.activeIndex); "next" === t.swipeDirection && (y >= n.longSwipesRatio ? t.slideTo(n.rewind && t.isEnd ? g : f + b) : t.slideTo(f)), "prev" === t.swipeDirection && (y > 1 - n.longSwipesRatio ? t.slideTo(f + b) : null !== v && y < 0 && Math.abs(y) > n.longSwipesRatio ? t.slideTo(v) : t.slideTo(f)) } else { if (!n.shortSwipes) return void t.slideTo(t.activeIndex); !t.navigation || l.target !== t.navigation.nextEl && l.target !== t.navigation.prevEl ? ("next" === t.swipeDirection && t.slideTo(null !== g ? g : f + b), "prev" === t.swipeDirection && t.slideTo(null !== v ? v : f)) : l.target === t.navigation.nextEl ? t.slideTo(f + b) : t.slideTo(f) } } function O() { const e = this, { params: t, el: i } = e; if (i && 0 === i.offsetWidth) return; t.breakpoints && e.setBreakpoint(); const { allowSlideNext: n, allowSlidePrev: s, snapGrid: r } = e; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), ("auto" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = s, e.allowSlideNext = n, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow() } function z(e) { const t = this; t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))) } function D() { const e = this, { wrapperEl: t, rtlTranslate: i, enabled: n } = e; if (!n) return; let s; e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const r = e.maxTranslate() - e.minTranslate(); s = 0 === r ? 0 : (e.translate - e.minTranslate()) / r, s !== e.progress && e.updateProgress(i ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1) } let N = !1; function j() { } const F = (e, t) => { const i = n(), { params: s, touchEvents: r, el: o, wrapperEl: a, device: l, support: c } = e, d = !!s.nested, u = "on" === t ? "addEventListener" : "removeEventListener", h = t; if (c.touch) { const t = !("touchstart" !== r.start || !c.passiveListener || !s.passiveListeners) && { passive: !0, capture: !1 }; o[u](r.start, e.onTouchStart, t), o[u](r.move, e.onTouchMove, c.passiveListener ? { passive: !1, capture: d } : d), o[u](r.end, e.onTouchEnd, t), r.cancel && o[u](r.cancel, e.onTouchEnd, t) } else o[u](r.start, e.onTouchStart, !1), i[u](r.move, e.onTouchMove, d), i[u](r.end, e.onTouchEnd, !1); (s.preventClicks || s.preventClicksPropagation) && o[u]("click", e.onClick, !0), s.cssMode && a[u]("scroll", e.onScroll), s.updateOnWindowResize ? e[h](l.ios || l.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", O, !0) : e[h]("observerUpdate", O, !0) }; var H = { attachEvents: function () { const e = this, t = n(), { params: i, support: s } = e; e.onTouchStart = P.bind(e), e.onTouchMove = I.bind(e), e.onTouchEnd = L.bind(e), i.cssMode && (e.onScroll = D.bind(e)), e.onClick = z.bind(e), s.touch && !N && (t.addEventListener("touchstart", j), N = !0), F(e, "on") }, detachEvents: function () { F(this, "off") } }; const q = (e, t) => e.grid && t.grid && t.grid.rows > 1; var B = { addClasses: function () { const e = this, { classNames: t, params: i, rtl: n, $el: s, device: r, support: o } = e, a = function (e, t) { const i = []; return e.forEach((e => { "object" == typeof e ? Object.keys(e).forEach((n => { e[n] && i.push(t + n) })) : "string" == typeof e && i.push(t + e) })), i }(["initialized", i.direction, { "pointer-events": !o.touch }, { "free-mode": e.params.freeMode && i.freeMode.enabled }, { autoheight: i.autoHeight }, { rtl: n }, { grid: i.grid && i.grid.rows > 1 }, { "grid-column": i.grid && i.grid.rows > 1 && "column" === i.grid.fill }, { android: r.android }, { ios: r.ios }, { "css-mode": i.cssMode }, { centered: i.cssMode && i.centeredSlides }, { "watch-progress": i.watchSlidesProgress }], i.containerModifierClass); t.push(...a), s.addClass([...t].join(" ")), e.emitContainerClasses() }, removeClasses: function () { const { $el: e, classNames: t } = this; e.removeClass(t.join(" ")), this.emitContainerClasses() } }, R = { init: !0, direction: "horizontal", touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 0, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, loopedSlidesLimit: !0, loopFillGroupWithBlank: !1, loopPreventsSlide: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-invisible-blank", slideActiveClass: "swiper-slide-active", slideDuplicateActiveClass: "swiper-slide-duplicate-active", slideVisibleClass: "swiper-slide-visible", slideDuplicateClass: "swiper-slide-duplicate", slideNextClass: "swiper-slide-next", slideDuplicateNextClass: "swiper-slide-duplicate-next", slidePrevClass: "swiper-slide-prev", slideDuplicatePrevClass: "swiper-slide-duplicate-prev", wrapperClass: "swiper-wrapper", runCallbacksOnInit: !0, _emitClasses: !1 }; function W(e, t) { return function (i) { void 0 === i && (i = {}); const n = Object.keys(i)[0], s = i[n]; "object" == typeof s && null !== s ? (["navigation", "pagination", "scrollbar"].indexOf(n) >= 0 && !0 === e[n] && (e[n] = { auto: !0 }), n in e && "enabled" in s ? (!0 === e[n] && (e[n] = { enabled: !0 }), "object" != typeof e[n] || "enabled" in e[n] || (e[n].enabled = !0), e[n] || (e[n] = { enabled: !1 }), g(t, i)) : g(t, i)) : g(t, i) } } const Y = { eventsEmitter: S, update: C, translate: k, transition: { setTransition: function (e, t) { const i = this; i.params.cssMode || i.$wrapperEl.transition(e), i.emit("setTransition", e, t) }, transitionStart: function (e, t) { void 0 === e && (e = !0); const i = this, { params: n } = i; n.cssMode || (n.autoHeight && i.updateAutoHeight(), A({ swiper: i, runCallbacks: e, direction: t, step: "Start" })) }, transitionEnd: function (e, t) { void 0 === e && (e = !0); const i = this, { params: n } = i; i.animating = !1, n.cssMode || (i.setTransition(0), A({ swiper: i, runCallbacks: e, direction: t, step: "End" })) } }, slide: $, loop: M, grabCursor: { setGrabCursor: function (e) { const t = this; if (t.support.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return; const i = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl; i.style.cursor = "move", i.style.cursor = e ? "grabbing" : "grab" }, unsetGrabCursor: function () { const e = this; e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "") } }, events: H, breakpoints: { setBreakpoint: function () { const e = this, { activeIndex: t, initialized: i, loopedSlides: n = 0, params: s, $el: r } = e, o = s.breakpoints; if (!o || o && 0 === Object.keys(o).length) return; const a = e.getBreakpoint(o, e.params.breakpointsBase, e.el); if (!a || e.currentBreakpoint === a) return; const l = (a in o ? o[a] : void 0) || e.originalParams, c = q(e, s), d = q(e, l), u = s.enabled; c && !d ? (r.removeClass(`${s.containerModifierClass}grid ${s.containerModifierClass}grid-column`), e.emitContainerClasses()) : !c && d && (r.addClass(`${s.containerModifierClass}grid`), (l.grid.fill && "column" === l.grid.fill || !l.grid.fill && "column" === s.grid.fill) && r.addClass(`${s.containerModifierClass}grid-column`), e.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((t => { const i = s[t] && s[t].enabled, n = l[t] && l[t].enabled; i && !n && e[t].disable(), !i && n && e[t].enable() })); const h = l.direction && l.direction !== s.direction, p = s.loop && (l.slidesPerView !== s.slidesPerView || h); h && i && e.changeDirection(), g(e.params, l); const f = e.params.enabled; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), u && !f ? e.disable() : !u && f && e.enable(), e.currentBreakpoint = a, e.emit("_beforeBreakpoint", l), p && i && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - n + e.loopedSlides, 0, !1)), e.emit("breakpoint", l) }, getBreakpoint: function (e, t, i) { if (void 0 === t && (t = "window"), !e || "container" === t && !i) return; let n = !1; const s = r(), o = "window" === t ? s.innerHeight : i.clientHeight, a = Object.keys(e).map((e => { if ("string" == typeof e && 0 === e.indexOf("@")) { const t = parseFloat(e.substr(1)); return { value: o * t, point: e } } return { value: e, point: e } })); a.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10))); for (let e = 0; e < a.length; e += 1) { const { point: r, value: o } = a[e]; "window" === t ? s.matchMedia(`(min-width: ${o}px)`).matches && (n = r) : o <= i.clientWidth && (n = r) } return n || "max" } }, checkOverflow: { checkOverflow: function () { const e = this, { isLocked: t, params: i } = e, { slidesOffsetBefore: n } = i; if (n) { const t = e.slides.length - 1, i = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * n; e.isLocked = e.size > i } else e.isLocked = 1 === e.snapGrid.length; !0 === i.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === i.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock") } }, classes: B, images: { loadImage: function (e, t, i, n, s, o) { const a = r(); let l; function d() { o && o() } c(e).parent("picture")[0] || e.complete && s ? d() : t ? (l = new a.Image, l.onload = d, l.onerror = d, n && (l.sizes = n), i && (l.srcset = i), t && (l.src = t)) : d() }, preloadImages: function () { const e = this; function t() { null != e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady"))) } e.imagesToLoad = e.$el.find("img"); for (let i = 0; i < e.imagesToLoad.length; i += 1) { const n = e.imagesToLoad[i]; e.loadImage(n, n.currentSrc || n.getAttribute("src"), n.srcset || n.getAttribute("srcset"), n.sizes || n.getAttribute("sizes"), !0, t) } } } }, X = {}; class V { constructor() { let e, t; for (var i = arguments.length, n = new Array(i), s = 0; s < i; s++)n[s] = arguments[s]; if (1 === n.length && n[0].constructor && "Object" === Object.prototype.toString.call(n[0]).slice(8, -1) ? t = n[0] : [e, t] = n, t || (t = {}), t = g({}, t), e && !t.el && (t.el = e), t.el && c(t.el).length > 1) { const e = []; return c(t.el).each((i => { const n = g({}, t, { el: i }); e.push(new V(n)) })), e } const r = this; r.__swiper__ = !0, r.support = _(), r.device = T({ userAgent: t.userAgent }), r.browser = E(), r.eventsListeners = {}, r.eventsAnyListeners = [], r.modules = [...r.__modules__], t.modules && Array.isArray(t.modules) && r.modules.push(...t.modules); const o = {}; r.modules.forEach((e => { e({ swiper: r, extendParams: W(t, o), on: r.on.bind(r), once: r.once.bind(r), off: r.off.bind(r), emit: r.emit.bind(r) }) })); const a = g({}, R, o); return r.params = g({}, a, X, t), r.originalParams = g({}, r.params), r.passedParams = g({}, t), r.params && r.params.on && Object.keys(r.params.on).forEach((e => { r.on(e, r.params.on[e]) })), r.params && r.params.onAny && r.onAny(r.params.onAny), r.$ = c, Object.assign(r, { enabled: r.params.enabled, el: e, classNames: [], slides: c(), slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal: () => "horizontal" === r.params.direction, isVertical: () => "vertical" === r.params.direction, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, allowSlideNext: r.params.allowSlideNext, allowSlidePrev: r.params.allowSlidePrev, touchEvents: function () { const e = ["touchstart", "touchmove", "touchend", "touchcancel"], t = ["pointerdown", "pointermove", "pointerup"]; return r.touchEventsTouch = { start: e[0], move: e[1], end: e[2], cancel: e[3] }, r.touchEventsDesktop = { start: t[0], move: t[1], end: t[2] }, r.support.touch || !r.params.simulateTouch ? r.touchEventsTouch : r.touchEventsDesktop }(), touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: r.params.focusableElements, lastClickTime: h(), clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, isTouchEvent: void 0, startMoving: void 0 }, allowClick: !0, allowTouchMove: r.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), r.emit("_swiper"), r.params.init && r.init(), r } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, t) { const i = this; e = Math.min(Math.max(e, 0), 1); const n = i.minTranslate(), s = (i.maxTranslate() - n) * e + n; i.translateTo(s, void 0 === t ? 0 : t), i.updateActiveIndex(), i.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass))); e.emit("_containerClasses", t.join(" ")) } getSlideClasses(e) { const t = this; return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = []; e.slides.each((i => { const n = e.getSlideClasses(i); t.push({ slideEl: i, classNames: n }), e.emit("_slideClass", i, n) })), e.emit("_slideClasses", t) } slidesPerViewDynamic(e, t) { void 0 === e && (e = "current"), void 0 === t && (t = !1); const { params: i, slides: n, slidesGrid: s, slidesSizesGrid: r, size: o, activeIndex: a } = this; let l = 1; if (i.centeredSlides) { let e, t = n[a].swiperSlideSize; for (let i = a + 1; i < n.length; i += 1)n[i] && !e && (t += n[i].swiperSlideSize, l += 1, t > o && (e = !0)); for (let i = a - 1; i >= 0; i -= 1)n[i] && !e && (t += n[i].swiperSlideSize, l += 1, t > o && (e = !0)) } else if ("current" === e) for (let e = a + 1; e < n.length; e += 1)(t ? s[e] + r[e] - s[a] < o : s[e] - s[a] < o) && (l += 1); else for (let e = a - 1; e >= 0; e -= 1)s[a] - s[e] < o && (l += 1); return l } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: i } = e; function n() { const t = e.rtlTranslate ? -1 * e.translate : e.translate, i = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(i), e.updateActiveIndex(), e.updateSlidesClasses() } let s; i.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode && e.params.freeMode.enabled ? (n(), e.params.autoHeight && e.updateAutoHeight()) : (s = ("auto" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), s || n()), i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e, t) { void 0 === t && (t = !0); const i = this, n = i.params.direction; return e || (e = "horizontal" === n ? "vertical" : "horizontal"), e === n || "horizontal" !== e && "vertical" !== e || (i.$el.removeClass(`${i.params.containerModifierClass}${n}`).addClass(`${i.params.containerModifierClass}${e}`), i.emitContainerClasses(), i.params.direction = e, i.slides.each((t => { "vertical" === e ? t.style.width = "" : t.style.height = "" })), i.emit("changeDirection"), t && i.update()), i } changeLanguageDirection(e) { const t = this; t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.$el.addClass(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.$el.removeClass(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update()) } mount(e) { const t = this; if (t.mounted) return !0; const i = c(e || t.params.el); if (!(e = i[0])) return !1; e.swiper = t; const s = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`; let r = (() => { if (e && e.shadowRoot && e.shadowRoot.querySelector) { const t = c(e.shadowRoot.querySelector(s())); return t.children = e => i.children(e), t } return i.children ? i.children(s()) : c(i).children(s()) })(); if (0 === r.length && t.params.createElements) { const e = n().createElement("div"); r = c(e), e.className = t.params.wrapperClass, i.append(e), i.children(`.${t.params.slideClass}`).each((e => { r.append(e) })) } return Object.assign(t, { $el: i, el: e, $wrapperEl: r, wrapperEl: r[0], mounted: !0, rtl: "rtl" === e.dir.toLowerCase() || "rtl" === i.css("direction"), rtlTranslate: "horizontal" === t.params.direction && ("rtl" === e.dir.toLowerCase() || "rtl" === i.css("direction")), wrongRTL: "-webkit-box" === r.css("display") }), !0 } init(e) { const t = this; return t.initialized || !1 === t.mount(e) || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.params.loop && t.loopCreate(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.preloadImages && t.preloadImages(), t.params.loop ? t.slideTo(t.params.initialSlide + t.loopedSlides, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.attachEvents(), t.initialized = !0, t.emit("init"), t.emit("afterInit")), t } destroy(e, t) { void 0 === e && (e = !0), void 0 === t && (t = !0); const i = this, { params: n, $el: s, $wrapperEl: r, slides: o } = i; return void 0 === i.params || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), n.loop && i.loopDestroy(), t && (i.removeClasses(), s.removeAttr("style"), r.removeAttr("style"), o && o.length && o.removeClass([n.slideVisibleClass, n.slideActiveClass, n.slideNextClass, n.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), i.emit("destroy"), Object.keys(i.eventsListeners).forEach((e => { i.off(e) })), !1 !== e && (i.$el[0].swiper = null, function (e) { const t = e; Object.keys(t).forEach((e => { try { t[e] = null } catch (e) { } try { delete t[e] } catch (e) { } })) }(i)), i.destroyed = !0), null } static extendDefaults(e) { g(X, e) } static get extendedDefaults() { return X } static get defaults() { return R } static installModule(e) { V.prototype.__modules__ || (V.prototype.__modules__ = []); const t = V.prototype.__modules__; "function" == typeof e && t.indexOf(e) < 0 && t.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach((e => V.installModule(e))), V) : (V.installModule(e), V) } } function G(e, t, i, s) { const r = n(); return e.params.createElements && Object.keys(s).forEach((n => { if (!i[n] && !0 === i.auto) { let o = e.$el.children(`.${s[n]}`)[0]; o || (o = r.createElement("div"), o.className = s[n], e.$el.append(o)), i[n] = o, t[n] = o } })), i } function U(e) { return void 0 === e && (e = ""), `.${e.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}` } function Q(e) { const t = this, { $wrapperEl: i, params: n } = t; if (n.loop && t.loopDestroy(), "object" == typeof e && "length" in e) for (let t = 0; t < e.length; t += 1)e[t] && i.append(e[t]); else i.append(e); n.loop && t.loopCreate(), n.observer || t.update() } function K(e) { const t = this, { params: i, $wrapperEl: n, activeIndex: s } = t; i.loop && t.loopDestroy(); let r = s + 1; if ("object" == typeof e && "length" in e) { for (let t = 0; t < e.length; t += 1)e[t] && n.prepend(e[t]); r = s + e.length } else n.prepend(e); i.loop && t.loopCreate(), i.observer || t.update(), t.slideTo(r, 0, !1) } function Z(e, t) { const i = this, { $wrapperEl: n, params: s, activeIndex: r } = i; let o = r; s.loop && (o -= i.loopedSlides, i.loopDestroy(), i.slides = n.children(`.${s.slideClass}`)); const a = i.slides.length; if (e <= 0) return void i.prependSlide(t); if (e >= a) return void i.appendSlide(t); let l = o > e ? o + 1 : o; const c = []; for (let t = a - 1; t >= e; t -= 1) { const e = i.slides.eq(t); e.remove(), c.unshift(e) } if ("object" == typeof t && "length" in t) { for (let e = 0; e < t.length; e += 1)t[e] && n.append(t[e]); l = o > e ? o + t.length : o } else n.append(t); for (let e = 0; e < c.length; e += 1)n.append(c[e]); s.loop && i.loopCreate(), s.observer || i.update(), s.loop ? i.slideTo(l + i.loopedSlides, 0, !1) : i.slideTo(l, 0, !1) } function J(e) { const t = this, { params: i, $wrapperEl: n, activeIndex: s } = t; let r = s; i.loop && (r -= t.loopedSlides, t.loopDestroy(), t.slides = n.children(`.${i.slideClass}`)); let o, a = r; if ("object" == typeof e && "length" in e) { for (let i = 0; i < e.length; i += 1)o = e[i], t.slides[o] && t.slides.eq(o).remove(), o < a && (a -= 1); a = Math.max(a, 0) } else o = e, t.slides[o] && t.slides.eq(o).remove(), o < a && (a -= 1), a = Math.max(a, 0); i.loop && t.loopCreate(), i.observer || t.update(), i.loop ? t.slideTo(a + t.loopedSlides, 0, !1) : t.slideTo(a, 0, !1) } function ee() { const e = this, t = []; for (let i = 0; i < e.slides.length; i += 1)t.push(i); e.removeSlide(t) } function te(e) { const { effect: t, swiper: i, on: n, setTranslate: s, setTransition: r, overwriteParams: o, perspective: a, recreateShadows: l, getEffectParams: c } = e; let d; n("beforeInit", (() => { if (i.params.effect !== t) return; i.classNames.push(`${i.params.containerModifierClass}${t}`), a && a() && i.classNames.push(`${i.params.containerModifierClass}3d`); const e = o ? o() : {}; Object.assign(i.params, e), Object.assign(i.originalParams, e) })), n("setTranslate", (() => { i.params.effect === t && s() })), n("setTransition", ((e, n) => { i.params.effect === t && r(n) })), n("transitionEnd", (() => { if (i.params.effect === t && l) { if (!c || !c().slideShadows) return; i.slides.each((e => { i.$(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").remove() })), l() } })), n("virtualUpdate", (() => { i.params.effect === t && (i.slides.length || (d = !0), requestAnimationFrame((() => { d && i.slides && i.slides.length && (s(), d = !1) }))) })) } function ie(e, t) { return e.transformEl ? t.find(e.transformEl).css({ "backface-visibility": "hidden", "-webkit-backface-visibility": "hidden" }) : t } function ne(e) { let { swiper: t, duration: i, transformEl: n, allSlides: s } = e; const { slides: r, activeIndex: o, $wrapperEl: a } = t; if (t.params.virtualTranslate && 0 !== i) { let e, i = !1; e = s ? n ? r.find(n) : r : n ? r.eq(o).find(n) : r.eq(o), e.transitionEnd((() => { if (i) return; if (!t || t.destroyed) return; i = !0, t.animating = !1; const e = ["webkitTransitionEnd", "transitionend"]; for (let t = 0; t < e.length; t += 1)a.trigger(e[t]) })) } } function se(e, t, i) { const n = "swiper-slide-shadow" + (i ? `-${i}` : ""), s = e.transformEl ? t.find(e.transformEl) : t; let r = s.children(`.${n}`); return r.length || (r = c(`<div class="swiper-slide-shadow${i ? `-${i}` : ""}"></div>`), s.append(r)), r } Object.keys(Y).forEach((e => { Object.keys(Y[e]).forEach((t => { V.prototype[t] = Y[e][t] })) })), V.use([function (e) { let { swiper: t, on: i, emit: n } = e; const s = r(); let o = null, a = null; const l = () => { t && !t.destroyed && t.initialized && (n("beforeResize"), n("resize")) }, c = () => { t && !t.destroyed && t.initialized && n("orientationchange") }; i("init", (() => { t.params.resizeObserver && void 0 !== s.ResizeObserver ? t && !t.destroyed && t.initialized && (o = new ResizeObserver((e => { a = s.requestAnimationFrame((() => { const { width: i, height: n } = t; let s = i, r = n; e.forEach((e => { let { contentBoxSize: i, contentRect: n, target: o } = e; o && o !== t.el || (s = n ? n.width : (i[0] || i).inlineSize, r = n ? n.height : (i[0] || i).blockSize) })), s === i && r === n || l() })) })), o.observe(t.el)) : (s.addEventListener("resize", l), s.addEventListener("orientationchange", c)) })), i("destroy", (() => { a && s.cancelAnimationFrame(a), o && o.unobserve && t.el && (o.unobserve(t.el), o = null), s.removeEventListener("resize", l), s.removeEventListener("orientationchange", c) })) }, function (e) { let { swiper: t, extendParams: i, on: n, emit: s } = e; const o = [], a = r(), l = function (e, t) { void 0 === t && (t = {}); const i = new (a.MutationObserver || a.WebkitMutationObserver)((e => { if (1 === e.length) return void s("observerUpdate", e[0]); const t = function () { s("observerUpdate", e[0]) }; a.requestAnimationFrame ? a.requestAnimationFrame(t) : a.setTimeout(t, 0) })); i.observe(e, { attributes: void 0 === t.attributes || t.attributes, childList: void 0 === t.childList || t.childList, characterData: void 0 === t.characterData || t.characterData }), o.push(i) }; i({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), n("init", (() => { if (t.params.observer) { if (t.params.observeParents) { const e = t.$el.parents(); for (let t = 0; t < e.length; t += 1)l(e[t]) } l(t.$el[0], { childList: t.params.observeSlideChildren }), l(t.$wrapperEl[0], { attributes: !1 }) } })), n("destroy", (() => { o.forEach((e => { e.disconnect() })), o.splice(0, o.length) })) }]); const re = [function (e) { let t, { swiper: i, extendParams: n, on: s, emit: r } = e; function o(e, t) { const n = i.params.virtual; if (n.cache && i.virtual.cache[t]) return i.virtual.cache[t]; const s = n.renderSlide ? c(n.renderSlide.call(i, e, t)) : c(`<div class="${i.params.slideClass}" data-swiper-slide-index="${t}">${e}</div>`); return s.attr("data-swiper-slide-index") || s.attr("data-swiper-slide-index", t), n.cache && (i.virtual.cache[t] = s), s } function a(e) { const { slidesPerView: t, slidesPerGroup: n, centeredSlides: s } = i.params, { addSlidesBefore: a, addSlidesAfter: l } = i.params.virtual, { from: c, to: d, slides: u, slidesGrid: h, offset: p } = i.virtual; i.params.cssMode || i.updateActiveIndex(); const f = i.activeIndex || 0; let m, g, v; m = i.rtlTranslate ? "right" : i.isHorizontal() ? "left" : "top", s ? (g = Math.floor(t / 2) + n + l, v = Math.floor(t / 2) + n + a) : (g = t + (n - 1) + l, v = n + a); const y = Math.max((f || 0) - v, 0), b = Math.min((f || 0) + g, u.length - 1), w = (i.slidesGrid[y] || 0) - (i.slidesGrid[0] || 0); function x() { i.updateSlides(), i.updateProgress(), i.updateSlidesClasses(), i.lazy && i.params.lazy.enabled && i.lazy.load(), r("virtualUpdate") } if (Object.assign(i.virtual, { from: y, to: b, offset: w, slidesGrid: i.slidesGrid }), c === y && d === b && !e) return i.slidesGrid !== h && w !== p && i.slides.css(m, `${w}px`), i.updateProgress(), void r("virtualUpdate"); if (i.params.virtual.renderExternal) return i.params.virtual.renderExternal.call(i, { offset: w, from: y, to: b, slides: function () { const e = []; for (let t = y; t <= b; t += 1)e.push(u[t]); return e }() }), void (i.params.virtual.renderExternalUpdate ? x() : r("virtualUpdate")); const _ = [], T = []; if (e) i.$wrapperEl.find(`.${i.params.slideClass}`).remove(); else for (let e = c; e <= d; e += 1)(e < y || e > b) && i.$wrapperEl.find(`.${i.params.slideClass}[data-swiper-slide-index="${e}"]`).remove(); for (let t = 0; t < u.length; t += 1)t >= y && t <= b && (void 0 === d || e ? T.push(t) : (t > d && T.push(t), t < c && _.push(t))); T.forEach((e => { i.$wrapperEl.append(o(u[e], e)) })), _.sort(((e, t) => t - e)).forEach((e => { i.$wrapperEl.prepend(o(u[e], e)) })), i.$wrapperEl.children(".swiper-slide").css(m, `${w}px`), x() } n({ virtual: { enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, renderExternalUpdate: !0, addSlidesBefore: 0, addSlidesAfter: 0 } }), i.virtual = { cache: {}, from: void 0, to: void 0, slides: [], offset: 0, slidesGrid: [] }, s("beforeInit", (() => { i.params.virtual.enabled && (i.virtual.slides = i.params.virtual.slides, i.classNames.push(`${i.params.containerModifierClass}virtual`), i.params.watchSlidesProgress = !0, i.originalParams.watchSlidesProgress = !0, i.params.initialSlide || a()) })), s("setTranslate", (() => { i.params.virtual.enabled && (i.params.cssMode && !i._immediateVirtual ? (clearTimeout(t), t = setTimeout((() => { a() }), 100)) : a()) })), s("init update resize", (() => { i.params.virtual.enabled && i.params.cssMode && v(i.wrapperEl, "--swiper-virtual-size", `${i.virtualSize}px`) })), Object.assign(i.virtual, { appendSlide: function (e) { if ("object" == typeof e && "length" in e) for (let t = 0; t < e.length; t += 1)e[t] && i.virtual.slides.push(e[t]); else i.virtual.slides.push(e); a(!0) }, prependSlide: function (e) { const t = i.activeIndex; let n = t + 1, s = 1; if (Array.isArray(e)) { for (let t = 0; t < e.length; t += 1)e[t] && i.virtual.slides.unshift(e[t]); n = t + e.length, s = e.length } else i.virtual.slides.unshift(e); if (i.params.virtual.cache) { const e = i.virtual.cache, t = {}; Object.keys(e).forEach((i => { const n = e[i], r = n.attr("data-swiper-slide-index"); r && n.attr("data-swiper-slide-index", parseInt(r, 10) + s), t[parseInt(i, 10) + s] = n })), i.virtual.cache = t } a(!0), i.slideTo(n, 0) }, removeSlide: function (e) { if (null == e) return; let t = i.activeIndex; if (Array.isArray(e)) for (let n = e.length - 1; n >= 0; n -= 1)i.virtual.slides.splice(e[n], 1), i.params.virtual.cache && delete i.virtual.cache[e[n]], e[n] < t && (t -= 1), t = Math.max(t, 0); else i.virtual.slides.splice(e, 1), i.params.virtual.cache && delete i.virtual.cache[e], e < t && (t -= 1), t = Math.max(t, 0); a(!0), i.slideTo(t, 0) }, removeAllSlides: function () { i.virtual.slides = [], i.params.virtual.cache && (i.virtual.cache = {}), a(!0), i.slideTo(0, 0) }, update: a }) }, function (e) { let { swiper: t, extendParams: i, on: s, emit: o } = e; const a = n(), l = r(); function d(e) { if (!t.enabled) return; const { rtlTranslate: i } = t; let n = e; n.originalEvent && (n = n.originalEvent); const s = n.keyCode || n.charCode, r = t.params.keyboard.pageUpDown, c = r && 33 === s, d = r && 34 === s, u = 37 === s, h = 39 === s, p = 38 === s, f = 40 === s; if (!t.allowSlideNext && (t.isHorizontal() && h || t.isVertical() && f || d)) return !1; if (!t.allowSlidePrev && (t.isHorizontal() && u || t.isVertical() && p || c)) return !1; if (!(n.shiftKey || n.altKey || n.ctrlKey || n.metaKey || a.activeElement && a.activeElement.nodeName && ("input" === a.activeElement.nodeName.toLowerCase() || "textarea" === a.activeElement.nodeName.toLowerCase()))) { if (t.params.keyboard.onlyInViewport && (c || d || u || h || p || f)) { let e = !1; if (t.$el.parents(`.${t.params.slideClass}`).length > 0 && 0 === t.$el.parents(`.${t.params.slideActiveClass}`).length) return; const n = t.$el, s = n[0].clientWidth, r = n[0].clientHeight, o = l.innerWidth, a = l.innerHeight, c = t.$el.offset(); i && (c.left -= t.$el[0].scrollLeft); const d = [[c.left, c.top], [c.left + s, c.top], [c.left, c.top + r], [c.left + s, c.top + r]]; for (let t = 0; t < d.length; t += 1) { const i = d[t]; if (i[0] >= 0 && i[0] <= o && i[1] >= 0 && i[1] <= a) { if (0 === i[0] && 0 === i[1]) continue; e = !0 } } if (!e) return } t.isHorizontal() ? ((c || d || u || h) && (n.preventDefault ? n.preventDefault() : n.returnValue = !1), ((d || h) && !i || (c || u) && i) && t.slideNext(), ((c || u) && !i || (d || h) && i) && t.slidePrev()) : ((c || d || p || f) && (n.preventDefault ? n.preventDefault() : n.returnValue = !1), (d || f) && t.slideNext(), (c || p) && t.slidePrev()), o("keyPress", s) } } function u() { t.keyboard.enabled || (c(a).on("keydown", d), t.keyboard.enabled = !0) } function h() { t.keyboard.enabled && (c(a).off("keydown", d), t.keyboard.enabled = !1) } t.keyboard = { enabled: !1 }, i({ keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } }), s("init", (() => { t.params.keyboard.enabled && u() })), s("destroy", (() => { t.keyboard.enabled && h() })), Object.assign(t.keyboard, { enable: u, disable: h }) }, function (e) { let { swiper: t, extendParams: i, on: n, emit: s } = e; const o = r(); let a; i({ mousewheel: { enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarget: "container", thresholdDelta: null, thresholdTime: null } }), t.mousewheel = { enabled: !1 }; let l, d = h(); const p = []; function f() { t.enabled && (t.mouseEntered = !0) } function m() { t.enabled && (t.mouseEntered = !1) } function g(e) { return !(t.params.mousewheel.thresholdDelta && e.delta < t.params.mousewheel.thresholdDelta || t.params.mousewheel.thresholdTime && h() - d < t.params.mousewheel.thresholdTime || !(e.delta >= 6 && h() - d < 60) && (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), s("scroll", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), s("scroll", e.raw)), d = (new o.Date).getTime(), 1)) } function v(e) { let i = e, n = !0; if (!t.enabled) return; const r = t.params.mousewheel; t.params.cssMode && i.preventDefault(); let o = t.$el; if ("container" !== t.params.mousewheel.eventsTarget && (o = c(t.params.mousewheel.eventsTarget)), !t.mouseEntered && !o[0].contains(i.target) && !r.releaseOnEdges) return !0; i.originalEvent && (i = i.originalEvent); let d = 0; const f = t.rtlTranslate ? -1 : 1, m = function (e) { let t = 0, i = 0, n = 0, s = 0; return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = i, i = 0), n = 10 * t, s = 10 * i, "deltaY" in e && (s = e.deltaY), "deltaX" in e && (n = e.deltaX), e.shiftKey && !n && (n = s, s = 0), (n || s) && e.deltaMode && (1 === e.deltaMode ? (n *= 40, s *= 40) : (n *= 800, s *= 800)), n && !t && (t = n < 1 ? -1 : 1), s && !i && (i = s < 1 ? -1 : 1), { spinX: t, spinY: i, pixelX: n, pixelY: s } }(i); if (r.forceToAxis) if (t.isHorizontal()) { if (!(Math.abs(m.pixelX) > Math.abs(m.pixelY))) return !0; d = -m.pixelX * f } else { if (!(Math.abs(m.pixelY) > Math.abs(m.pixelX))) return !0; d = -m.pixelY } else d = Math.abs(m.pixelX) > Math.abs(m.pixelY) ? -m.pixelX * f : -m.pixelY; if (0 === d) return !0; r.invert && (d = -d); let v = t.getTranslate() + d * r.sensitivity; if (v >= t.minTranslate() && (v = t.minTranslate()), v <= t.maxTranslate() && (v = t.maxTranslate()), n = !!t.params.loop || !(v === t.minTranslate() || v === t.maxTranslate()), n && t.params.nested && i.stopPropagation(), t.params.freeMode && t.params.freeMode.enabled) { const e = { time: h(), delta: Math.abs(d), direction: Math.sign(d) }, n = l && e.time < l.time + 500 && e.delta <= l.delta && e.direction === l.direction; if (!n) { l = void 0, t.params.loop && t.loopFix(); let o = t.getTranslate() + d * r.sensitivity; const c = t.isBeginning, h = t.isEnd; if (o >= t.minTranslate() && (o = t.minTranslate()), o <= t.maxTranslate() && (o = t.maxTranslate()), t.setTransition(0), t.setTranslate(o), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses(), (!c && t.isBeginning || !h && t.isEnd) && t.updateSlidesClasses(), t.params.freeMode.sticky) { clearTimeout(a), a = void 0, p.length >= 15 && p.shift(); const i = p.length ? p[p.length - 1] : void 0, n = p[0]; if (p.push(e), i && (e.delta > i.delta || e.direction !== i.direction)) p.splice(0); else if (p.length >= 15 && e.time - n.time < 500 && n.delta - e.delta >= 1 && e.delta <= 6) { const i = d > 0 ? .8 : .2; l = e, p.splice(0), a = u((() => { t.slideToClosest(t.params.speed, !0, void 0, i) }), 0) } a || (a = u((() => { l = e, p.splice(0), t.slideToClosest(t.params.speed, !0, void 0, .5) }), 500)) } if (n || s("scroll", i), t.params.autoplay && t.params.autoplayDisableOnInteraction && t.autoplay.stop(), o === t.minTranslate() || o === t.maxTranslate()) return !0 } } else { const i = { time: h(), delta: Math.abs(d), direction: Math.sign(d), raw: e }; p.length >= 2 && p.shift(); const n = p.length ? p[p.length - 1] : void 0; if (p.push(i), n ? (i.direction !== n.direction || i.delta > n.delta || i.time > n.time + 150) && g(i) : g(i), function (e) { const i = t.params.mousewheel; if (e.direction < 0) { if (t.isEnd && !t.params.loop && i.releaseOnEdges) return !0 } else if (t.isBeginning && !t.params.loop && i.releaseOnEdges) return !0; return !1 }(i)) return !0 } return i.preventDefault ? i.preventDefault() : i.returnValue = !1, !1 } function y(e) { let i = t.$el; "container" !== t.params.mousewheel.eventsTarget && (i = c(t.params.mousewheel.eventsTarget)), i[e]("mouseenter", f), i[e]("mouseleave", m), i[e]("wheel", v) } function b() { return t.params.cssMode ? (t.wrapperEl.removeEventListener("wheel", v), !0) : !t.mousewheel.enabled && (y("on"), t.mousewheel.enabled = !0, !0) } function w() { return t.params.cssMode ? (t.wrapperEl.addEventListener(event, v), !0) : !!t.mousewheel.enabled && (y("off"), t.mousewheel.enabled = !1, !0) } n("init", (() => { !t.params.mousewheel.enabled && t.params.cssMode && w(), t.params.mousewheel.enabled && b() })), n("destroy", (() => { t.params.cssMode && b(), t.mousewheel.enabled && w() })), Object.assign(t.mousewheel, { enable: b, disable: w }) }, function (e) { let { swiper: t, extendParams: i, on: n, emit: s } = e; function r(e) { let i; return e && (i = c(e), t.params.uniqueNavElements && "string" == typeof e && i.length > 1 && 1 === t.$el.find(e).length && (i = t.$el.find(e))), i } function o(e, i) { const n = t.params.navigation; e && e.length > 0 && (e[i ? "addClass" : "removeClass"](n.disabledClass), e[0] && "BUTTON" === e[0].tagName && (e[0].disabled = i), t.params.watchOverflow && t.enabled && e[t.isLocked ? "addClass" : "removeClass"](n.lockClass)) } function a() { if (t.params.loop) return; const { $nextEl: e, $prevEl: i } = t.navigation; o(i, t.isBeginning && !t.params.rewind), o(e, t.isEnd && !t.params.rewind) } function l(e) { e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), s("navigationPrev")) } function d(e) { e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), s("navigationNext")) } function u() { const e = t.params.navigation; if (t.params.navigation = G(t, t.originalParams.navigation, t.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !e.nextEl && !e.prevEl) return; const i = r(e.nextEl), n = r(e.prevEl); i && i.length > 0 && i.on("click", d), n && n.length > 0 && n.on("click", l), Object.assign(t.navigation, { $nextEl: i, nextEl: i && i[0], $prevEl: n, prevEl: n && n[0] }), t.enabled || (i && i.addClass(e.lockClass), n && n.addClass(e.lockClass)) } function h() { const { $nextEl: e, $prevEl: i } = t.navigation; e && e.length && (e.off("click", d), e.removeClass(t.params.navigation.disabledClass)), i && i.length && (i.off("click", l), i.removeClass(t.params.navigation.disabledClass)) } i({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), t.navigation = { nextEl: null, $nextEl: null, prevEl: null, $prevEl: null }, n("init", (() => { !1 === t.params.navigation.enabled ? p() : (u(), a()) })), n("toEdge fromEdge lock unlock", (() => { a() })), n("destroy", (() => { h() })), n("enable disable", (() => { const { $nextEl: e, $prevEl: i } = t.navigation; e && e[t.enabled ? "removeClass" : "addClass"](t.params.navigation.lockClass), i && i[t.enabled ? "removeClass" : "addClass"](t.params.navigation.lockClass) })), n("click", ((e, i) => { const { $nextEl: n, $prevEl: r } = t.navigation, o = i.target; if (t.params.navigation.hideOnClick && !c(o).is(r) && !c(o).is(n)) { if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === o || t.pagination.el.contains(o))) return; let e; n ? e = n.hasClass(t.params.navigation.hiddenClass) : r && (e = r.hasClass(t.params.navigation.hiddenClass)), s(!0 === e ? "navigationShow" : "navigationHide"), n && n.toggleClass(t.params.navigation.hiddenClass), r && r.toggleClass(t.params.navigation.hiddenClass) } })); const p = () => { t.$el.addClass(t.params.navigation.navigationDisabledClass), h() }; Object.assign(t.navigation, { enable: () => { t.$el.removeClass(t.params.navigation.navigationDisabledClass), u(), a() }, disable: p, update: a, init: u, destroy: h }) }, function (e) { let { swiper: t, extendParams: i, on: n, emit: s } = e; const r = "swiper-pagination"; let o; i({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: e => e, formatFractionTotal: e => e, bulletClass: `${r}-bullet`, bulletActiveClass: `${r}-bullet-active`, modifierClass: `${r}-`, currentClass: `${r}-current`, totalClass: `${r}-total`, hiddenClass: `${r}-hidden`, progressbarFillClass: `${r}-progressbar-fill`, progressbarOppositeClass: `${r}-progressbar-opposite`, clickableClass: `${r}-clickable`, lockClass: `${r}-lock`, horizontalClass: `${r}-horizontal`, verticalClass: `${r}-vertical`, paginationDisabledClass: `${r}-disabled` } }), t.pagination = { el: null, $el: null, bullets: [] }; let a = 0; function l() { return !t.params.pagination.el || !t.pagination.el || !t.pagination.$el || 0 === t.pagination.$el.length } function d(e, i) { const { bulletActiveClass: n } = t.params.pagination; e[i]().addClass(`${n}-${i}`)[i]().addClass(`${n}-${i}-${i}`) } function u() { const e = t.rtl, i = t.params.pagination; if (l()) return; const n = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length, r = t.pagination.$el; let u; const h = t.params.loop ? Math.ceil((n - 2 * t.loopedSlides) / t.params.slidesPerGroup) : t.snapGrid.length; if (t.params.loop ? (u = Math.ceil((t.activeIndex - t.loopedSlides) / t.params.slidesPerGroup), u > n - 1 - 2 * t.loopedSlides && (u -= n - 2 * t.loopedSlides), u > h - 1 && (u -= h), u < 0 && "bullets" !== t.params.paginationType && (u = h + u)) : u = void 0 !== t.snapIndex ? t.snapIndex : t.activeIndex || 0, "bullets" === i.type && t.pagination.bullets && t.pagination.bullets.length > 0) { const n = t.pagination.bullets; let s, l, h; if (i.dynamicBullets && (o = n.eq(0)[t.isHorizontal() ? "outerWidth" : "outerHeight"](!0), r.css(t.isHorizontal() ? "width" : "height", o * (i.dynamicMainBullets + 4) + "px"), i.dynamicMainBullets > 1 && void 0 !== t.previousIndex && (a += u - (t.previousIndex - t.loopedSlides || 0), a > i.dynamicMainBullets - 1 ? a = i.dynamicMainBullets - 1 : a < 0 && (a = 0)), s = Math.max(u - a, 0), l = s + (Math.min(n.length, i.dynamicMainBullets) - 1), h = (l + s) / 2), n.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => `${i.bulletActiveClass}${e}`)).join(" ")), r.length > 1) n.each((e => { const t = c(e), n = t.index(); n === u && t.addClass(i.bulletActiveClass), i.dynamicBullets && (n >= s && n <= l && t.addClass(`${i.bulletActiveClass}-main`), n === s && d(t, "prev"), n === l && d(t, "next")) })); else { const e = n.eq(u), r = e.index(); if (e.addClass(i.bulletActiveClass), i.dynamicBullets) { const e = n.eq(s), o = n.eq(l); for (let e = s; e <= l; e += 1)n.eq(e).addClass(`${i.bulletActiveClass}-main`); if (t.params.loop) if (r >= n.length) { for (let e = i.dynamicMainBullets; e >= 0; e -= 1)n.eq(n.length - e).addClass(`${i.bulletActiveClass}-main`); n.eq(n.length - i.dynamicMainBullets - 1).addClass(`${i.bulletActiveClass}-prev`) } else d(e, "prev"), d(o, "next"); else d(e, "prev"), d(o, "next") } } if (i.dynamicBullets) { const s = Math.min(n.length, i.dynamicMainBullets + 4), r = (o * s - o) / 2 - h * o, a = e ? "right" : "left"; n.css(t.isHorizontal() ? a : "top", `${r}px`) } } if ("fraction" === i.type && (r.find(U(i.currentClass)).text(i.formatFractionCurrent(u + 1)), r.find(U(i.totalClass)).text(i.formatFractionTotal(h))), "progressbar" === i.type) { let e; e = i.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical"; const n = (u + 1) / h; let s = 1, o = 1; "horizontal" === e ? s = n : o = n, r.find(U(i.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${s}) scaleY(${o})`).transition(t.params.speed) } "custom" === i.type && i.renderCustom ? (r.html(i.renderCustom(t, u + 1, h)), s("paginationRender", r[0])) : s("paginationUpdate", r[0]), t.params.watchOverflow && t.enabled && r[t.isLocked ? "addClass" : "removeClass"](i.lockClass) } function h() { const e = t.params.pagination; if (l()) return; const i = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length, n = t.pagination.$el; let r = ""; if ("bullets" === e.type) { let s = t.params.loop ? Math.ceil((i - 2 * t.loopedSlides) / t.params.slidesPerGroup) : t.snapGrid.length; t.params.freeMode && t.params.freeMode.enabled && !t.params.loop && s > i && (s = i); for (let i = 0; i < s; i += 1)e.renderBullet ? r += e.renderBullet.call(t, i, e.bulletClass) : r += `<${e.bulletElement} class="${e.bulletClass}"></${e.bulletElement}>`; n.html(r), t.pagination.bullets = n.find(U(e.bulletClass)) } "fraction" === e.type && (r = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`, n.html(r)), "progressbar" === e.type && (r = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`, n.html(r)), "custom" !== e.type && s("paginationRender", t.pagination.$el[0]) } function p() { t.params.pagination = G(t, t.originalParams.pagination, t.params.pagination, { el: "swiper-pagination" }); const e = t.params.pagination; if (!e.el) return; let i = c(e.el); 0 !== i.length && (t.params.uniqueNavElements && "string" == typeof e.el && i.length > 1 && (i = t.$el.find(e.el), i.length > 1 && (i = i.filter((e => c(e).parents(".swiper")[0] === t.el)))), "bullets" === e.type && e.clickable && i.addClass(e.clickableClass), i.addClass(e.modifierClass + e.type), i.addClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass), "bullets" === e.type && e.dynamicBullets && (i.addClass(`${e.modifierClass}${e.type}-dynamic`), a = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && i.addClass(e.progressbarOppositeClass), e.clickable && i.on("click", U(e.bulletClass), (function (e) { e.preventDefault(); let i = c(this).index() * t.params.slidesPerGroup; t.params.loop && (i += t.loopedSlides), t.slideTo(i) })), Object.assign(t.pagination, { $el: i, el: i[0] }), t.enabled || i.addClass(e.lockClass)) } function f() { const e = t.params.pagination; if (l()) return; const i = t.pagination.$el; i.removeClass(e.hiddenClass), i.removeClass(e.modifierClass + e.type), i.removeClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass), t.pagination.bullets && t.pagination.bullets.removeClass && t.pagination.bullets.removeClass(e.bulletActiveClass), e.clickable && i.off("click", U(e.bulletClass)) } n("init", (() => { !1 === t.params.pagination.enabled ? m() : (p(), h(), u()) })), n("activeIndexChange", (() => { (t.params.loop || void 0 === t.snapIndex) && u() })), n("snapIndexChange", (() => { t.params.loop || u() })), n("slidesLengthChange", (() => { t.params.loop && (h(), u()) })), n("snapGridLengthChange", (() => { t.params.loop || (h(), u()) })), n("destroy", (() => { f() })), n("enable disable", (() => { const { $el: e } = t.pagination; e && e[t.enabled ? "removeClass" : "addClass"](t.params.pagination.lockClass) })), n("lock unlock", (() => { u() })), n("click", ((e, i) => { const n = i.target, { $el: r } = t.pagination; if (t.params.pagination.el && t.params.pagination.hideOnClick && r && r.length > 0 && !c(n).hasClass(t.params.pagination.bulletClass)) { if (t.navigation && (t.navigation.nextEl && n === t.navigation.nextEl || t.navigation.prevEl && n === t.navigation.prevEl)) return; const e = r.hasClass(t.params.pagination.hiddenClass); s(!0 === e ? "paginationShow" : "paginationHide"), r.toggleClass(t.params.pagination.hiddenClass) } })); const m = () => { t.$el.addClass(t.params.pagination.paginationDisabledClass), t.pagination.$el && t.pagination.$el.addClass(t.params.pagination.paginationDisabledClass), f() }; Object.assign(t.pagination, { enable: () => { t.$el.removeClass(t.params.pagination.paginationDisabledClass), t.pagination.$el && t.pagination.$el.removeClass(t.params.pagination.paginationDisabledClass), p(), h(), u() }, disable: m, render: h, update: u, init: p, destroy: f }) }, function (e) { let { swiper: t, extendParams: i, on: s, emit: r } = e; const o = n(); let a, l, d, h, p = !1, f = null, m = null; function g() { if (!t.params.scrollbar.el || !t.scrollbar.el) return; const { scrollbar: e, rtlTranslate: i, progress: n } = t, { $dragEl: s, $el: r } = e, o = t.params.scrollbar; let a = l, c = (d - l) * n; i ? (c = -c, c > 0 ? (a = l - c, c = 0) : -c + l > d && (a = d + c)) : c < 0 ? (a = l + c, c = 0) : c + l > d && (a = d - c), t.isHorizontal() ? (s.transform(`translate3d(${c}px, 0, 0)`), s[0].style.width = `${a}px`) : (s.transform(`translate3d(0px, ${c}px, 0)`), s[0].style.height = `${a}px`), o.hide && (clearTimeout(f), r[0].style.opacity = 1, f = setTimeout((() => { r[0].style.opacity = 0, r.transition(400) }), 1e3)) } function v() { if (!t.params.scrollbar.el || !t.scrollbar.el) return; const { scrollbar: e } = t, { $dragEl: i, $el: n } = e; i[0].style.width = "", i[0].style.height = "", d = t.isHorizontal() ? n[0].offsetWidth : n[0].offsetHeight, h = t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0)), l = "auto" === t.params.scrollbar.dragSize ? d * h : parseInt(t.params.scrollbar.dragSize, 10), t.isHorizontal() ? i[0].style.width = `${l}px` : i[0].style.height = `${l}px`, n[0].style.display = h >= 1 ? "none" : "", t.params.scrollbar.hide && (n[0].style.opacity = 0), t.params.watchOverflow && t.enabled && e.$el[t.isLocked ? "addClass" : "removeClass"](t.params.scrollbar.lockClass) } function y(e) { return t.isHorizontal() ? "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].clientX : e.clientX : "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].clientY : e.clientY } function b(e) { const { scrollbar: i, rtlTranslate: n } = t, { $el: s } = i; let r; r = (y(e) - s.offset()[t.isHorizontal() ? "left" : "top"] - (null !== a ? a : l / 2)) / (d - l), r = Math.max(Math.min(r, 1), 0), n && (r = 1 - r); const o = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * r; t.updateProgress(o), t.setTranslate(o), t.updateActiveIndex(), t.updateSlidesClasses() } function w(e) { const i = t.params.scrollbar, { scrollbar: n, $wrapperEl: s } = t, { $el: o, $dragEl: l } = n; p = !0, a = e.target === l[0] || e.target === l ? y(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"] : null, e.preventDefault(), e.stopPropagation(), s.transition(100), l.transition(100), b(e), clearTimeout(m), o.transition(0), i.hide && o.css("opacity", 1), t.params.cssMode && t.$wrapperEl.css("scroll-snap-type", "none"), r("scrollbarDragStart", e) } function x(e) { const { scrollbar: i, $wrapperEl: n } = t, { $el: s, $dragEl: o } = i; p && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, b(e), n.transition(0), s.transition(0), o.transition(0), r("scrollbarDragMove", e)) } function _(e) { const i = t.params.scrollbar, { scrollbar: n, $wrapperEl: s } = t, { $el: o } = n; p && (p = !1, t.params.cssMode && (t.$wrapperEl.css("scroll-snap-type", ""), s.transition("")), i.hide && (clearTimeout(m), m = u((() => { o.css("opacity", 0), o.transition(400) }), 1e3)), r("scrollbarDragEnd", e), i.snapOnRelease && t.slideToClosest()) } function T(e) { const { scrollbar: i, touchEventsTouch: n, touchEventsDesktop: s, params: r, support: a } = t, l = i.$el; if (!l) return; const c = l[0], d = !(!a.passiveListener || !r.passiveListeners) && { passive: !1, capture: !1 }, u = !(!a.passiveListener || !r.passiveListeners) && { passive: !0, capture: !1 }; if (!c) return; const h = "on" === e ? "addEventListener" : "removeEventListener"; a.touch ? (c[h](n.start, w, d), c[h](n.move, x, d), c[h](n.end, _, u)) : (c[h](s.start, w, d), o[h](s.move, x, d), o[h](s.end, _, u)) } function E() { const { scrollbar: e, $el: i } = t; t.params.scrollbar = G(t, t.originalParams.scrollbar, t.params.scrollbar, { el: "swiper-scrollbar" }); const n = t.params.scrollbar; if (!n.el) return; let s = c(n.el); t.params.uniqueNavElements && "string" == typeof n.el && s.length > 1 && 1 === i.find(n.el).length && (s = i.find(n.el)), s.addClass(t.isHorizontal() ? n.horizontalClass : n.verticalClass); let r = s.find(`.${t.params.scrollbar.dragClass}`); 0 === r.length && (r = c(`<div class="${t.params.scrollbar.dragClass}"></div>`), s.append(r)), Object.assign(e, { $el: s, el: s[0], $dragEl: r, dragEl: r[0] }), n.draggable && t.params.scrollbar.el && t.scrollbar.el && T("on"), s && s[t.enabled ? "removeClass" : "addClass"](t.params.scrollbar.lockClass) } function S() { const e = t.params.scrollbar, i = t.scrollbar.$el; i && i.removeClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass), t.params.scrollbar.el && t.scrollbar.el && T("off") } i({ scrollbar: { el: null, dragSize: "auto", hide: !1, draggable: !1, snapOnRelease: !0, lockClass: "swiper-scrollbar-lock", dragClass: "swiper-scrollbar-drag", scrollbarDisabledClass: "swiper-scrollbar-disabled", horizontalClass: "swiper-scrollbar-horizontal", verticalClass: "swiper-scrollbar-vertical" } }), t.scrollbar = { el: null, dragEl: null, $el: null, $dragEl: null }, s("init", (() => { !1 === t.params.scrollbar.enabled ? C() : (E(), v(), g()) })), s("update resize observerUpdate lock unlock", (() => { v() })), s("setTranslate", (() => { g() })), s("setTransition", ((e, i) => { !function (e) { t.params.scrollbar.el && t.scrollbar.el && t.scrollbar.$dragEl.transition(e) }(i) })), s("enable disable", (() => { const { $el: e } = t.scrollbar; e && e[t.enabled ? "removeClass" : "addClass"](t.params.scrollbar.lockClass) })), s("destroy", (() => { S() })); const C = () => { t.$el.addClass(t.params.scrollbar.scrollbarDisabledClass), t.scrollbar.$el && t.scrollbar.$el.addClass(t.params.scrollbar.scrollbarDisabledClass), S() }; Object.assign(t.scrollbar, { enable: () => { t.$el.removeClass(t.params.scrollbar.scrollbarDisabledClass), t.scrollbar.$el && t.scrollbar.$el.removeClass(t.params.scrollbar.scrollbarDisabledClass), E(), v(), g() }, disable: C, updateSize: v, setTranslate: g, init: E, destroy: S }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; i({ parallax: { enabled: !1 } }); const s = (e, i) => { const { rtl: n } = t, s = c(e), r = n ? -1 : 1, o = s.attr("data-swiper-parallax") || "0"; let a = s.attr("data-swiper-parallax-x"), l = s.attr("data-swiper-parallax-y"); const d = s.attr("data-swiper-parallax-scale"), u = s.attr("data-swiper-parallax-opacity"); if (a || l ? (a = a || "0", l = l || "0") : t.isHorizontal() ? (a = o, l = "0") : (l = o, a = "0"), a = a.indexOf("%") >= 0 ? parseInt(a, 10) * i * r + "%" : a * i * r + "px", l = l.indexOf("%") >= 0 ? parseInt(l, 10) * i + "%" : l * i + "px", null != u) { const e = u - (u - 1) * (1 - Math.abs(i)); s[0].style.opacity = e } if (null == d) s.transform(`translate3d(${a}, ${l}, 0px)`); else { const e = d - (d - 1) * (1 - Math.abs(i)); s.transform(`translate3d(${a}, ${l}, 0px) scale(${e})`) } }, r = () => { const { $el: e, slides: i, progress: n, snapGrid: r } = t; e.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e => { s(e, n) })), i.each(((e, i) => { let o = e.progress; t.params.slidesPerGroup > 1 && "auto" !== t.params.slidesPerView && (o += Math.ceil(i / 2) - n * (r.length - 1)), o = Math.min(Math.max(o, -1), 1), c(e).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e => { s(e, o) })) })) }; n("beforeInit", (() => { t.params.parallax.enabled && (t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0) })), n("init", (() => { t.params.parallax.enabled && r() })), n("setTranslate", (() => { t.params.parallax.enabled && r() })), n("setTransition", ((e, i) => { t.params.parallax.enabled && function (e) { void 0 === e && (e = t.params.speed); const { $el: i } = t; i.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t => { const i = c(t); let n = parseInt(i.attr("data-swiper-parallax-duration"), 10) || e; 0 === e && (n = 0), i.transition(n) })) }(i) })) }, function (e) { let { swiper: t, extendParams: i, on: n, emit: s } = e; const o = r(); i({ zoom: { enabled: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: "swiper-zoom-container", zoomedSlideClass: "swiper-slide-zoomed" } }), t.zoom = { enabled: !1 }; let a, l, d, u = 1, h = !1; const f = { $slideEl: void 0, slideWidth: void 0, slideHeight: void 0, $imageEl: void 0, $imageWrapEl: void 0, maxRatio: 3 }, m = { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} }, g = { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 }; let v = 1; function y(e) { if (e.targetTouches.length < 2) return 1; const t = e.targetTouches[0].pageX, i = e.targetTouches[0].pageY, n = e.targetTouches[1].pageX, s = e.targetTouches[1].pageY; return Math.sqrt((n - t) ** 2 + (s - i) ** 2) } function b(e) { const i = t.support, n = t.params.zoom; if (l = !1, d = !1, !i.gestures) { if ("touchstart" !== e.type || "touchstart" === e.type && e.targetTouches.length < 2) return; l = !0, f.scaleStart = y(e) } f.$slideEl && f.$slideEl.length || (f.$slideEl = c(e.target).closest(`.${t.params.slideClass}`), 0 === f.$slideEl.length && (f.$slideEl = t.slides.eq(t.activeIndex)), f.$imageEl = f.$slideEl.find(`.${n.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), f.$imageWrapEl = f.$imageEl.parent(`.${n.containerClass}`), f.maxRatio = f.$imageWrapEl.attr("data-swiper-zoom") || n.maxRatio, 0 !== f.$imageWrapEl.length) ? (f.$imageEl && f.$imageEl.transition(0), h = !0) : f.$imageEl = void 0 } function w(e) { const i = t.support, n = t.params.zoom, s = t.zoom; if (!i.gestures) { if ("touchmove" !== e.type || "touchmove" === e.type && e.targetTouches.length < 2) return; d = !0, f.scaleMove = y(e) } f.$imageEl && 0 !== f.$imageEl.length ? (i.gestures ? s.scale = e.scale * u : s.scale = f.scaleMove / f.scaleStart * u, s.scale > f.maxRatio && (s.scale = f.maxRatio - 1 + (s.scale - f.maxRatio + 1) ** .5), s.scale < n.minRatio && (s.scale = n.minRatio + 1 - (n.minRatio - s.scale + 1) ** .5), f.$imageEl.transform(`translate3d(0,0,0) scale(${s.scale})`)) : "gesturechange" === e.type && b(e) } function x(e) { const i = t.device, n = t.support, s = t.params.zoom, r = t.zoom; if (!n.gestures) { if (!l || !d) return; if ("touchend" !== e.type || "touchend" === e.type && e.changedTouches.length < 2 && !i.android) return; l = !1, d = !1 } f.$imageEl && 0 !== f.$imageEl.length && (r.scale = Math.max(Math.min(r.scale, f.maxRatio), s.minRatio), f.$imageEl.transition(t.params.speed).transform(`translate3d(0,0,0) scale(${r.scale})`), u = r.scale, h = !1, 1 === r.scale && (f.$slideEl = void 0)) } function _(e) { const i = t.zoom; if (!f.$imageEl || 0 === f.$imageEl.length) return; if (t.allowClick = !1, !m.isTouched || !f.$slideEl) return; m.isMoved || (m.width = f.$imageEl[0].offsetWidth, m.height = f.$imageEl[0].offsetHeight, m.startX = p(f.$imageWrapEl[0], "x") || 0, m.startY = p(f.$imageWrapEl[0], "y") || 0, f.slideWidth = f.$slideEl[0].offsetWidth, f.slideHeight = f.$slideEl[0].offsetHeight, f.$imageWrapEl.transition(0)); const n = m.width * i.scale, s = m.height * i.scale; if (!(n < f.slideWidth && s < f.slideHeight)) { if (m.minX = Math.min(f.slideWidth / 2 - n / 2, 0), m.maxX = -m.minX, m.minY = Math.min(f.slideHeight / 2 - s / 2, 0), m.maxY = -m.minY, m.touchesCurrent.x = "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX, m.touchesCurrent.y = "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY, !m.isMoved && !h) { if (t.isHorizontal() && (Math.floor(m.minX) === Math.floor(m.startX) && m.touchesCurrent.x < m.touchesStart.x || Math.floor(m.maxX) === Math.floor(m.startX) && m.touchesCurrent.x > m.touchesStart.x)) return void (m.isTouched = !1); if (!t.isHorizontal() && (Math.floor(m.minY) === Math.floor(m.startY) && m.touchesCurrent.y < m.touchesStart.y || Math.floor(m.maxY) === Math.floor(m.startY) && m.touchesCurrent.y > m.touchesStart.y)) return void (m.isTouched = !1) } e.cancelable && e.preventDefault(), e.stopPropagation(), m.isMoved = !0, m.currentX = m.touchesCurrent.x - m.touchesStart.x + m.startX, m.currentY = m.touchesCurrent.y - m.touchesStart.y + m.startY, m.currentX < m.minX && (m.currentX = m.minX + 1 - (m.minX - m.currentX + 1) ** .8), m.currentX > m.maxX && (m.currentX = m.maxX - 1 + (m.currentX - m.maxX + 1) ** .8), m.currentY < m.minY && (m.currentY = m.minY + 1 - (m.minY - m.currentY + 1) ** .8), m.currentY > m.maxY && (m.currentY = m.maxY - 1 + (m.currentY - m.maxY + 1) ** .8), g.prevPositionX || (g.prevPositionX = m.touchesCurrent.x), g.prevPositionY || (g.prevPositionY = m.touchesCurrent.y), g.prevTime || (g.prevTime = Date.now()), g.x = (m.touchesCurrent.x - g.prevPositionX) / (Date.now() - g.prevTime) / 2, g.y = (m.touchesCurrent.y - g.prevPositionY) / (Date.now() - g.prevTime) / 2, Math.abs(m.touchesCurrent.x - g.prevPositionX) < 2 && (g.x = 0), Math.abs(m.touchesCurrent.y - g.prevPositionY) < 2 && (g.y = 0), g.prevPositionX = m.touchesCurrent.x, g.prevPositionY = m.touchesCurrent.y, g.prevTime = Date.now(), f.$imageWrapEl.transform(`translate3d(${m.currentX}px, ${m.currentY}px,0)`) } } function T() { const e = t.zoom; f.$slideEl && t.previousIndex !== t.activeIndex && (f.$imageEl && f.$imageEl.transform("translate3d(0,0,0) scale(1)"), f.$imageWrapEl && f.$imageWrapEl.transform("translate3d(0,0,0)"), e.scale = 1, u = 1, f.$slideEl = void 0, f.$imageEl = void 0, f.$imageWrapEl = void 0) } function E(e) { const i = t.zoom, n = t.params.zoom; if (f.$slideEl || (e && e.target && (f.$slideEl = c(e.target).closest(`.${t.params.slideClass}`)), f.$slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? f.$slideEl = t.$wrapperEl.children(`.${t.params.slideActiveClass}`) : f.$slideEl = t.slides.eq(t.activeIndex)), f.$imageEl = f.$slideEl.find(`.${n.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), f.$imageWrapEl = f.$imageEl.parent(`.${n.containerClass}`)), !f.$imageEl || 0 === f.$imageEl.length || !f.$imageWrapEl || 0 === f.$imageWrapEl.length) return; let s, r, a, l, d, h, p, g, v, y, b, w, x, _, T, E, S, C; t.params.cssMode && (t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.touchAction = "none"), f.$slideEl.addClass(`${n.zoomedSlideClass}`), void 0 === m.touchesStart.x && e ? (s = "touchend" === e.type ? e.changedTouches[0].pageX : e.pageX, r = "touchend" === e.type ? e.changedTouches[0].pageY : e.pageY) : (s = m.touchesStart.x, r = m.touchesStart.y), i.scale = f.$imageWrapEl.attr("data-swiper-zoom") || n.maxRatio, u = f.$imageWrapEl.attr("data-swiper-zoom") || n.maxRatio, e ? (S = f.$slideEl[0].offsetWidth, C = f.$slideEl[0].offsetHeight, a = f.$slideEl.offset().left + o.scrollX, l = f.$slideEl.offset().top + o.scrollY, d = a + S / 2 - s, h = l + C / 2 - r, v = f.$imageEl[0].offsetWidth, y = f.$imageEl[0].offsetHeight, b = v * i.scale, w = y * i.scale, x = Math.min(S / 2 - b / 2, 0), _ = Math.min(C / 2 - w / 2, 0), T = -x, E = -_, p = d * i.scale, g = h * i.scale, p < x && (p = x), p > T && (p = T), g < _ && (g = _), g > E && (g = E)) : (p = 0, g = 0), f.$imageWrapEl.transition(300).transform(`translate3d(${p}px, ${g}px,0)`), f.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${i.scale})`) } function S() { const e = t.zoom, i = t.params.zoom; f.$slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? f.$slideEl = t.$wrapperEl.children(`.${t.params.slideActiveClass}`) : f.$slideEl = t.slides.eq(t.activeIndex), f.$imageEl = f.$slideEl.find(`.${i.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), f.$imageWrapEl = f.$imageEl.parent(`.${i.containerClass}`)), f.$imageEl && 0 !== f.$imageEl.length && f.$imageWrapEl && 0 !== f.$imageWrapEl.length && (t.params.cssMode && (t.wrapperEl.style.overflow = "", t.wrapperEl.style.touchAction = ""), e.scale = 1, u = 1, f.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), f.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), f.$slideEl.removeClass(`${i.zoomedSlideClass}`), f.$slideEl = void 0) } function C(e) { const i = t.zoom; i.scale && 1 !== i.scale ? S() : E(e) } function k() { const e = t.support; return { passiveListener: !("touchstart" !== t.touchEvents.start || !e.passiveListener || !t.params.passiveListeners) && { passive: !0, capture: !1 }, activeListenerWithCapture: !e.passiveListener || { passive: !1, capture: !0 } } } function A() { return `.${t.params.slideClass}` } function $(e) { const { passiveListener: i } = k(), n = A(); t.$wrapperEl[e]("gesturestart", n, b, i), t.$wrapperEl[e]("gesturechange", n, w, i), t.$wrapperEl[e]("gestureend", n, x, i) } function M() { a || (a = !0, $("on")) } function P() { a && (a = !1, $("off")) } function I() { const e = t.zoom; if (e.enabled) return; e.enabled = !0; const i = t.support, { passiveListener: n, activeListenerWithCapture: s } = k(), r = A(); i.gestures ? (t.$wrapperEl.on(t.touchEvents.start, M, n), t.$wrapperEl.on(t.touchEvents.end, P, n)) : "touchstart" === t.touchEvents.start && (t.$wrapperEl.on(t.touchEvents.start, r, b, n), t.$wrapperEl.on(t.touchEvents.move, r, w, s), t.$wrapperEl.on(t.touchEvents.end, r, x, n), t.touchEvents.cancel && t.$wrapperEl.on(t.touchEvents.cancel, r, x, n)), t.$wrapperEl.on(t.touchEvents.move, `.${t.params.zoom.containerClass}`, _, s) } function L() { const e = t.zoom; if (!e.enabled) return; const i = t.support; e.enabled = !1; const { passiveListener: n, activeListenerWithCapture: s } = k(), r = A(); i.gestures ? (t.$wrapperEl.off(t.touchEvents.start, M, n), t.$wrapperEl.off(t.touchEvents.end, P, n)) : "touchstart" === t.touchEvents.start && (t.$wrapperEl.off(t.touchEvents.start, r, b, n), t.$wrapperEl.off(t.touchEvents.move, r, w, s), t.$wrapperEl.off(t.touchEvents.end, r, x, n), t.touchEvents.cancel && t.$wrapperEl.off(t.touchEvents.cancel, r, x, n)), t.$wrapperEl.off(t.touchEvents.move, `.${t.params.zoom.containerClass}`, _, s) } Object.defineProperty(t.zoom, "scale", { get: () => v, set(e) { if (v !== e) { const t = f.$imageEl ? f.$imageEl[0] : void 0, i = f.$slideEl ? f.$slideEl[0] : void 0; s("zoomChange", e, t, i) } v = e } }), n("init", (() => { t.params.zoom.enabled && I() })), n("destroy", (() => { L() })), n("touchStart", ((e, i) => { t.zoom.enabled && function (e) { const i = t.device; f.$imageEl && 0 !== f.$imageEl.length && (m.isTouched || (i.android && e.cancelable && e.preventDefault(), m.isTouched = !0, m.touchesStart.x = "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX, m.touchesStart.y = "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY)) }(i) })), n("touchEnd", ((e, i) => { t.zoom.enabled && function () { const e = t.zoom; if (!f.$imageEl || 0 === f.$imageEl.length) return; if (!m.isTouched || !m.isMoved) return m.isTouched = !1, void (m.isMoved = !1); m.isTouched = !1, m.isMoved = !1; let i = 300, n = 300; const s = g.x * i, r = m.currentX + s, o = g.y * n, a = m.currentY + o; 0 !== g.x && (i = Math.abs((r - m.currentX) / g.x)), 0 !== g.y && (n = Math.abs((a - m.currentY) / g.y)); const l = Math.max(i, n); m.currentX = r, m.currentY = a; const c = m.width * e.scale, d = m.height * e.scale; m.minX = Math.min(f.slideWidth / 2 - c / 2, 0), m.maxX = -m.minX, m.minY = Math.min(f.slideHeight / 2 - d / 2, 0), m.maxY = -m.minY, m.currentX = Math.max(Math.min(m.currentX, m.maxX), m.minX), m.currentY = Math.max(Math.min(m.currentY, m.maxY), m.minY), f.$imageWrapEl.transition(l).transform(`translate3d(${m.currentX}px, ${m.currentY}px,0)`) }() })), n("doubleTap", ((e, i) => { !t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && C(i) })), n("transitionEnd", (() => { t.zoom.enabled && t.params.zoom.enabled && T() })), n("slideChange", (() => { t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && T() })), Object.assign(t.zoom, { enable: I, disable: L, in: E, out: S, toggle: C }) }, function (e) { let { swiper: t, extendParams: i, on: n, emit: s } = e; i({ lazy: { checkInView: !1, enabled: !1, loadPrevNext: !1, loadPrevNextAmount: 1, loadOnTransitionStart: !1, scrollingElement: "", elementClass: "swiper-lazy", loadingClass: "swiper-lazy-loading", loadedClass: "swiper-lazy-loaded", preloaderClass: "swiper-lazy-preloader" } }), t.lazy = {}; let o = !1, a = !1; function l(e, i) { void 0 === i && (i = !0); const n = t.params.lazy; if (void 0 === e) return; if (0 === t.slides.length) return; const r = t.virtual && t.params.virtual.enabled ? t.$wrapperEl.children(`.${t.params.slideClass}[data-swiper-slide-index="${e}"]`) : t.slides.eq(e), o = r.find(`.${n.elementClass}:not(.${n.loadedClass}):not(.${n.loadingClass})`); !r.hasClass(n.elementClass) || r.hasClass(n.loadedClass) || r.hasClass(n.loadingClass) || o.push(r[0]), 0 !== o.length && o.each((e => { const o = c(e); o.addClass(n.loadingClass); const a = o.attr("data-background"), d = o.attr("data-src"), u = o.attr("data-srcset"), h = o.attr("data-sizes"), p = o.parent("picture"); t.loadImage(o[0], d || a, u, h, !1, (() => { if (null != t && t && (!t || t.params) && !t.destroyed) { if (a ? (o.css("background-image", `url("${a}")`), o.removeAttr("data-background")) : (u && (o.attr("srcset", u), o.removeAttr("data-srcset")), h && (o.attr("sizes", h), o.removeAttr("data-sizes")), p.length && p.children("source").each((e => { const t = c(e); t.attr("data-srcset") && (t.attr("srcset", t.attr("data-srcset")), t.removeAttr("data-srcset")) })), d && (o.attr("src", d), o.removeAttr("data-src"))), o.addClass(n.loadedClass).removeClass(n.loadingClass), r.find(`.${n.preloaderClass}`).remove(), t.params.loop && i) { const e = r.attr("data-swiper-slide-index"); r.hasClass(t.params.slideDuplicateClass) ? l(t.$wrapperEl.children(`[data-swiper-slide-index="${e}"]:not(.${t.params.slideDuplicateClass})`).index(), !1) : l(t.$wrapperEl.children(`.${t.params.slideDuplicateClass}[data-swiper-slide-index="${e}"]`).index(), !1) } s("lazyImageReady", r[0], o[0]), t.params.autoHeight && t.updateAutoHeight() } })), s("lazyImageLoad", r[0], o[0]) })) } function d() { const { $wrapperEl: e, params: i, slides: n, activeIndex: s } = t, r = t.virtual && i.virtual.enabled, o = i.lazy; let d = i.slidesPerView; function u(t) { if (r) { if (e.children(`.${i.slideClass}[data-swiper-slide-index="${t}"]`).length) return !0 } else if (n[t]) return !0; return !1 } function h(e) { return r ? c(e).attr("data-swiper-slide-index") : c(e).index() } if ("auto" === d && (d = 0), a || (a = !0), t.params.watchSlidesProgress) e.children(`.${i.slideVisibleClass}`).each((e => { l(r ? c(e).attr("data-swiper-slide-index") : c(e).index()) })); else if (d > 1) for (let e = s; e < s + d; e += 1)u(e) && l(e); else l(s); if (o.loadPrevNext) if (d > 1 || o.loadPrevNextAmount && o.loadPrevNextAmount > 1) { const e = o.loadPrevNextAmount, t = Math.ceil(d), i = Math.min(s + t + Math.max(e, t), n.length), r = Math.max(s - Math.max(t, e), 0); for (let e = s + t; e < i; e += 1)u(e) && l(e); for (let e = r; e < s; e += 1)u(e) && l(e) } else { const t = e.children(`.${i.slideNextClass}`); t.length > 0 && l(h(t)); const n = e.children(`.${i.slidePrevClass}`); n.length > 0 && l(h(n)) } } function u() { const e = r(); if (!t || t.destroyed) return; const i = t.params.lazy.scrollingElement ? c(t.params.lazy.scrollingElement) : c(e), n = i[0] === e, s = n ? e.innerWidth : i[0].offsetWidth, a = n ? e.innerHeight : i[0].offsetHeight, l = t.$el.offset(), { rtlTranslate: h } = t; let p = !1; h && (l.left -= t.$el[0].scrollLeft); const f = [[l.left, l.top], [l.left + t.width, l.top], [l.left, l.top + t.height], [l.left + t.width, l.top + t.height]]; for (let e = 0; e < f.length; e += 1) { const t = f[e]; if (t[0] >= 0 && t[0] <= s && t[1] >= 0 && t[1] <= a) { if (0 === t[0] && 0 === t[1]) continue; p = !0 } } const m = !("touchstart" !== t.touchEvents.start || !t.support.passiveListener || !t.params.passiveListeners) && { passive: !0, capture: !1 }; p ? (d(), i.off("scroll", u, m)) : o || (o = !0, i.on("scroll", u, m)) } n("beforeInit", (() => { t.params.lazy.enabled && t.params.preloadImages && (t.params.preloadImages = !1) })), n("init", (() => { t.params.lazy.enabled && (t.params.lazy.checkInView ? u() : d()) })), n("scroll", (() => { t.params.freeMode && t.params.freeMode.enabled && !t.params.freeMode.sticky && d() })), n("scrollbarDragMove resize _freeModeNoMomentumRelease", (() => { t.params.lazy.enabled && (t.params.lazy.checkInView ? u() : d()) })), n("transitionStart", (() => { t.params.lazy.enabled && (t.params.lazy.loadOnTransitionStart || !t.params.lazy.loadOnTransitionStart && !a) && (t.params.lazy.checkInView ? u() : d()) })), n("transitionEnd", (() => { t.params.lazy.enabled && !t.params.lazy.loadOnTransitionStart && (t.params.lazy.checkInView ? u() : d()) })), n("slideChange", (() => { const { lazy: e, cssMode: i, watchSlidesProgress: n, touchReleaseOnEdges: s, resistanceRatio: r } = t.params; e.enabled && (i || n && (s || 0 === r)) && d() })), n("destroy", (() => { t.$el && t.$el.find(`.${t.params.lazy.loadingClass}`).removeClass(t.params.lazy.loadingClass) })), Object.assign(t.lazy, { load: d, loadInSlide: l }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; function s(e, t) { const i = function () { let e, t, i; return (n, s) => { for (t = -1, e = n.length; e - t > 1;)i = e + t >> 1, n[i] <= s ? t = i : e = i; return e } }(); let n, s; return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) { return e ? (s = i(this.x, e), n = s - 1, (e - this.x[n]) * (this.y[s] - this.y[n]) / (this.x[s] - this.x[n]) + this.y[n]) : 0 }, this } function r() { t.controller.control && t.controller.spline && (t.controller.spline = void 0, delete t.controller.spline) } i({ controller: { control: void 0, inverse: !1, by: "slide" } }), t.controller = { control: void 0 }, n("beforeInit", (() => { t.controller.control = t.params.controller.control })), n("update", (() => { r() })), n("resize", (() => { r() })), n("observerUpdate", (() => { r() })), n("setTranslate", ((e, i, n) => { t.controller.control && t.controller.setTranslate(i, n) })), n("setTransition", ((e, i, n) => { t.controller.control && t.controller.setTransition(i, n) })), Object.assign(t.controller, { setTranslate: function (e, i) { const n = t.controller.control; let r, o; const a = t.constructor; function l(e) { const i = t.rtlTranslate ? -t.translate : t.translate; "slide" === t.params.controller.by && (function (e) { t.controller.spline || (t.controller.spline = t.params.loop ? new s(t.slidesGrid, e.slidesGrid) : new s(t.snapGrid, e.snapGrid)) }(e), o = -t.controller.spline.interpolate(-i)), o && "container" !== t.params.controller.by || (r = (e.maxTranslate() - e.minTranslate()) / (t.maxTranslate() - t.minTranslate()), o = (i - t.minTranslate()) * r + e.minTranslate()), t.params.controller.inverse && (o = e.maxTranslate() - o), e.updateProgress(o), e.setTranslate(o, t), e.updateActiveIndex(), e.updateSlidesClasses() } if (Array.isArray(n)) for (let e = 0; e < n.length; e += 1)n[e] !== i && n[e] instanceof a && l(n[e]); else n instanceof a && i !== n && l(n) }, setTransition: function (e, i) { const n = t.constructor, s = t.controller.control; let r; function o(i) { i.setTransition(e, t), 0 !== e && (i.transitionStart(), i.params.autoHeight && u((() => { i.updateAutoHeight() })), i.$wrapperEl.transitionEnd((() => { s && (i.params.loop && "slide" === t.params.controller.by && i.loopFix(), i.transitionEnd()) }))) } if (Array.isArray(s)) for (r = 0; r < s.length; r += 1)s[r] !== i && s[r] instanceof n && o(s[r]); else s instanceof n && i !== s && o(s) } }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; i({ a11y: { enabled: !0, notificationClass: "swiper-notification", prevSlideMessage: "Previous slide", nextSlideMessage: "Next slide", firstSlideMessage: "This is the first slide", lastSlideMessage: "This is the last slide", paginationBulletMessage: "Go to slide {{index}}", slideLabelMessage: "{{index}} / {{slidesLength}}", containerMessage: null, containerRoleDescriptionMessage: null, itemRoleDescriptionMessage: null, slideRole: "group", id: null } }); let s = null; function r(e) { const t = s; 0 !== t.length && (t.html(""), t.html(e)) } function o(e) { e.attr("tabIndex", "0") } function a(e) { e.attr("tabIndex", "-1") } function l(e, t) { e.attr("role", t) } function d(e, t) { e.attr("aria-roledescription", t) } function u(e, t) { e.attr("aria-label", t) } function h(e) { e.attr("aria-disabled", !0) } function p(e) { e.attr("aria-disabled", !1) } function f(e) { if (13 !== e.keyCode && 32 !== e.keyCode) return; const i = t.params.a11y, n = c(e.target); t.navigation && t.navigation.$nextEl && n.is(t.navigation.$nextEl) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? r(i.lastSlideMessage) : r(i.nextSlideMessage)), t.navigation && t.navigation.$prevEl && n.is(t.navigation.$prevEl) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? r(i.firstSlideMessage) : r(i.prevSlideMessage)), t.pagination && n.is(U(t.params.pagination.bulletClass)) && n[0].click() } function m() { return t.pagination && t.pagination.bullets && t.pagination.bullets.length } function g() { return m() && t.params.pagination.clickable } const v = (e, t, i) => { o(e), "BUTTON" !== e[0].tagName && (l(e, "button"), e.on("keydown", f)), u(e, i), function (e, t) { e.attr("aria-controls", t) }(e, t) }, y = e => { const i = e.target.closest(`.${t.params.slideClass}`); if (!i || !t.slides.includes(i)) return; const n = t.slides.indexOf(i) === t.activeIndex, s = t.params.watchSlidesProgress && t.visibleSlides && t.visibleSlides.includes(i); n || s || (t.isHorizontal() ? t.el.scrollLeft = 0 : t.el.scrollTop = 0, t.slideTo(t.slides.indexOf(i), 0)) }, b = () => { const e = t.params.a11y; e.itemRoleDescriptionMessage && d(c(t.slides), e.itemRoleDescriptionMessage), e.slideRole && l(c(t.slides), e.slideRole); const i = t.params.loop ? t.slides.filter((e => !e.classList.contains(t.params.slideDuplicateClass))).length : t.slides.length; e.slideLabelMessage && t.slides.each(((n, s) => { const r = c(n), o = t.params.loop ? parseInt(r.attr("data-swiper-slide-index"), 10) : s; u(r, e.slideLabelMessage.replace(/\{\{index\}\}/, o + 1).replace(/\{\{slidesLength\}\}/, i)) })) }; n("beforeInit", (() => { s = c(`<span class="${t.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`) })), n("afterInit", (() => { t.params.a11y.enabled && (() => { const e = t.params.a11y; t.$el.append(s); const i = t.$el; e.containerRoleDescriptionMessage && d(i, e.containerRoleDescriptionMessage), e.containerMessage && u(i, e.containerMessage); const n = t.$wrapperEl, r = e.id || n.attr("id") || `swiper-wrapper-${o = 16, void 0 === o && (o = 16), "x".repeat(o).replace(/x/g, (() => Math.round(16 * Math.random()).toString(16)))}`; var o; const a = t.params.autoplay && t.params.autoplay.enabled ? "off" : "polite"; var l; let c, h; l = r, n.attr("id", l), function (e, t) { e.attr("aria-live", t) }(n, a), b(), t.navigation && t.navigation.$nextEl && (c = t.navigation.$nextEl), t.navigation && t.navigation.$prevEl && (h = t.navigation.$prevEl), c && c.length && v(c, r, e.nextSlideMessage), h && h.length && v(h, r, e.prevSlideMessage), g() && t.pagination.$el.on("keydown", U(t.params.pagination.bulletClass), f), t.$el.on("focus", y, !0) })() })), n("slidesLengthChange snapGridLengthChange slidesGridLengthChange", (() => { t.params.a11y.enabled && b() })), n("fromEdge toEdge afterInit lock unlock", (() => { t.params.a11y.enabled && function () { if (t.params.loop || t.params.rewind || !t.navigation) return; const { $nextEl: e, $prevEl: i } = t.navigation; i && i.length > 0 && (t.isBeginning ? (h(i), a(i)) : (p(i), o(i))), e && e.length > 0 && (t.isEnd ? (h(e), a(e)) : (p(e), o(e))) }() })), n("paginationUpdate", (() => { t.params.a11y.enabled && function () { const e = t.params.a11y; m() && t.pagination.bullets.each((i => { const n = c(i); t.params.pagination.clickable && (o(n), t.params.pagination.renderBullet || (l(n, "button"), u(n, e.paginationBulletMessage.replace(/\{\{index\}\}/, n.index() + 1)))), n.is(`.${t.params.pagination.bulletActiveClass}`) ? n.attr("aria-current", "true") : n.removeAttr("aria-current") })) }() })), n("destroy", (() => { t.params.a11y.enabled && function () { let e, i; s && s.length > 0 && s.remove(), t.navigation && t.navigation.$nextEl && (e = t.navigation.$nextEl), t.navigation && t.navigation.$prevEl && (i = t.navigation.$prevEl), e && e.off("keydown", f), i && i.off("keydown", f), g() && t.pagination.$el.off("keydown", U(t.params.pagination.bulletClass), f), t.$el.off("focus", y, !0) }() })) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; i({ history: { enabled: !1, root: "", replaceState: !1, key: "slides", keepQuery: !1 } }); let s = !1, o = {}; const a = e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), l = e => { const t = r(); let i; i = e ? new URL(e) : t.location; const n = i.pathname.slice(1).split("/").filter((e => "" !== e)), s = n.length; return { key: n[s - 2], value: n[s - 1] } }, c = (e, i) => { const n = r(); if (!s || !t.params.history.enabled) return; let o; o = t.params.url ? new URL(t.params.url) : n.location; const l = t.slides.eq(i); let c = a(l.attr("data-history")); if (t.params.history.root.length > 0) { let i = t.params.history.root; "/" === i[i.length - 1] && (i = i.slice(0, i.length - 1)), c = `${i}/${e}/${c}` } else o.pathname.includes(e) || (c = `${e}/${c}`); t.params.history.keepQuery && (c += o.search); const d = n.history.state; d && d.value === c || (t.params.history.replaceState ? n.history.replaceState({ value: c }, null, c) : n.history.pushState({ value: c }, null, c)) }, d = (e, i, n) => { if (i) for (let s = 0, r = t.slides.length; s < r; s += 1) { const r = t.slides.eq(s); if (a(r.attr("data-history")) === i && !r.hasClass(t.params.slideDuplicateClass)) { const i = r.index(); t.slideTo(i, e, n) } } else t.slideTo(0, e, n) }, u = () => { o = l(t.params.url), d(t.params.speed, o.value, !1) }; n("init", (() => { t.params.history.enabled && (() => { const e = r(); if (t.params.history) { if (!e.history || !e.history.pushState) return t.params.history.enabled = !1, void (t.params.hashNavigation.enabled = !0); s = !0, o = l(t.params.url), (o.key || o.value) && (d(0, o.value, t.params.runCallbacksOnInit), t.params.history.replaceState || e.addEventListener("popstate", u)) } })() })), n("destroy", (() => { t.params.history.enabled && (() => { const e = r(); t.params.history.replaceState || e.removeEventListener("popstate", u) })() })), n("transitionEnd _freeModeNoMomentumRelease", (() => { s && c(t.params.history.key, t.activeIndex) })), n("slideChange", (() => { s && t.params.cssMode && c(t.params.history.key, t.activeIndex) })) }, function (e) { let { swiper: t, extendParams: i, emit: s, on: o } = e, a = !1; const l = n(), d = r(); i({ hashNavigation: { enabled: !1, replaceState: !1, watchState: !1 } }); const u = () => { s("hashChange"); const e = l.location.hash.replace("#", ""); if (e !== t.slides.eq(t.activeIndex).attr("data-hash")) { const i = t.$wrapperEl.children(`.${t.params.slideClass}[data-hash="${e}"]`).index(); if (void 0 === i) return; t.slideTo(i) } }, h = () => { if (a && t.params.hashNavigation.enabled) if (t.params.hashNavigation.replaceState && d.history && d.history.replaceState) d.history.replaceState(null, null, `#${t.slides.eq(t.activeIndex).attr("data-hash")}` || ""), s("hashSet"); else { const e = t.slides.eq(t.activeIndex), i = e.attr("data-hash") || e.attr("data-history"); l.location.hash = i || "", s("hashSet") } }; o("init", (() => { t.params.hashNavigation.enabled && (() => { if (!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled) return; a = !0; const e = l.location.hash.replace("#", ""); if (e) { const i = 0; for (let n = 0, s = t.slides.length; n < s; n += 1) { const s = t.slides.eq(n); if ((s.attr("data-hash") || s.attr("data-history")) === e && !s.hasClass(t.params.slideDuplicateClass)) { const e = s.index(); t.slideTo(e, i, t.params.runCallbacksOnInit, !0) } } } t.params.hashNavigation.watchState && c(d).on("hashchange", u) })() })), o("destroy", (() => { t.params.hashNavigation.enabled && t.params.hashNavigation.watchState && c(d).off("hashchange", u) })), o("transitionEnd _freeModeNoMomentumRelease", (() => { a && h() })), o("slideChange", (() => { a && t.params.cssMode && h() })) }, function (e) { let t, { swiper: i, extendParams: s, on: r, emit: o } = e; function a() { if (!i.size) return i.autoplay.running = !1, void (i.autoplay.paused = !1); const e = i.slides.eq(i.activeIndex); let n = i.params.autoplay.delay; e.attr("data-swiper-autoplay") && (n = e.attr("data-swiper-autoplay") || i.params.autoplay.delay), clearTimeout(t), t = u((() => { let e; i.params.autoplay.reverseDirection ? i.params.loop ? (i.loopFix(), e = i.slidePrev(i.params.speed, !0, !0), o("autoplay")) : i.isBeginning ? i.params.autoplay.stopOnLastSlide ? c() : (e = i.slideTo(i.slides.length - 1, i.params.speed, !0, !0), o("autoplay")) : (e = i.slidePrev(i.params.speed, !0, !0), o("autoplay")) : i.params.loop ? (i.loopFix(), e = i.slideNext(i.params.speed, !0, !0), o("autoplay")) : i.isEnd ? i.params.autoplay.stopOnLastSlide ? c() : (e = i.slideTo(0, i.params.speed, !0, !0), o("autoplay")) : (e = i.slideNext(i.params.speed, !0, !0), o("autoplay")), (i.params.cssMode && i.autoplay.running || !1 === e) && a() }), n) } function l() { return void 0 === t && !i.autoplay.running && (i.autoplay.running = !0, o("autoplayStart"), a(), !0) } function c() { return !!i.autoplay.running && void 0 !== t && (t && (clearTimeout(t), t = void 0), i.autoplay.running = !1, o("autoplayStop"), !0) } function d(e) { i.autoplay.running && (i.autoplay.paused || (t && clearTimeout(t), i.autoplay.paused = !0, 0 !== e && i.params.autoplay.waitForTransition ? ["transitionend", "webkitTransitionEnd"].forEach((e => { i.$wrapperEl[0].addEventListener(e, p) })) : (i.autoplay.paused = !1, a()))) } function h() { const e = n(); "hidden" === e.visibilityState && i.autoplay.running && d(), "visible" === e.visibilityState && i.autoplay.paused && (a(), i.autoplay.paused = !1) } function p(e) { i && !i.destroyed && i.$wrapperEl && e.target === i.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach((e => { i.$wrapperEl[0].removeEventListener(e, p) })), i.autoplay.paused = !1, i.autoplay.running ? a() : c()) } function f() { i.params.autoplay.disableOnInteraction ? c() : (o("autoplayPause"), d()), ["transitionend", "webkitTransitionEnd"].forEach((e => { i.$wrapperEl[0].removeEventListener(e, p) })) } function m() { i.params.autoplay.disableOnInteraction || (i.autoplay.paused = !1, o("autoplayResume"), a()) } i.autoplay = { running: !1, paused: !1 }, s({ autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !0, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1 } }), r("init", (() => { i.params.autoplay.enabled && (l(), n().addEventListener("visibilitychange", h), i.params.autoplay.pauseOnMouseEnter && (i.$el.on("mouseenter", f), i.$el.on("mouseleave", m))) })), r("beforeTransitionStart", ((e, t, n) => { i.autoplay.running && (n || !i.params.autoplay.disableOnInteraction ? i.autoplay.pause(t) : c()) })), r("sliderFirstMove", (() => { i.autoplay.running && (i.params.autoplay.disableOnInteraction ? c() : d()) })), r("touchEnd", (() => { i.params.cssMode && i.autoplay.paused && !i.params.autoplay.disableOnInteraction && a() })), r("destroy", (() => { i.$el.off("mouseenter", f), i.$el.off("mouseleave", m), i.autoplay.running && c(), n().removeEventListener("visibilitychange", h) })), Object.assign(i.autoplay, { pause: d, run: a, start: l, stop: c }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; i({ thumbs: { swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: "swiper-slide-thumb-active", thumbsContainerClass: "swiper-thumbs" } }); let s = !1, r = !1; function o() { const e = t.thumbs.swiper; if (!e || e.destroyed) return; const i = e.clickedIndex, n = e.clickedSlide; if (n && c(n).hasClass(t.params.thumbs.slideThumbActiveClass)) return; if (null == i) return; let s; if (s = e.params.loop ? parseInt(c(e.clickedSlide).attr("data-swiper-slide-index"), 10) : i, t.params.loop) { let e = t.activeIndex; t.slides.eq(e).hasClass(t.params.slideDuplicateClass) && (t.loopFix(), t._clientLeft = t.$wrapperEl[0].clientLeft, e = t.activeIndex); const i = t.slides.eq(e).prevAll(`[data-swiper-slide-index="${s}"]`).eq(0).index(), n = t.slides.eq(e).nextAll(`[data-swiper-slide-index="${s}"]`).eq(0).index(); s = void 0 === i ? n : void 0 === n ? i : n - e < e - i ? n : i } t.slideTo(s) } function a() { const { thumbs: e } = t.params; if (s) return !1; s = !0; const i = t.constructor; if (e.swiper instanceof i) t.thumbs.swiper = e.swiper, Object.assign(t.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), Object.assign(t.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 }); else if (f(e.swiper)) { const n = Object.assign({}, e.swiper); Object.assign(n, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), t.thumbs.swiper = new i(n), r = !0 } return t.thumbs.swiper.$el.addClass(t.params.thumbs.thumbsContainerClass), t.thumbs.swiper.on("tap", o), !0 } function l(e) { const i = t.thumbs.swiper; if (!i || i.destroyed) return; const n = "auto" === i.params.slidesPerView ? i.slidesPerViewDynamic() : i.params.slidesPerView; let s = 1; const r = t.params.thumbs.slideThumbActiveClass; if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (s = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (s = 1), s = Math.floor(s), i.slides.removeClass(r), i.params.loop || i.params.virtual && i.params.virtual.enabled) for (let e = 0; e < s; e += 1)i.$wrapperEl.children(`[data-swiper-slide-index="${t.realIndex + e}"]`).addClass(r); else for (let e = 0; e < s; e += 1)i.slides.eq(t.realIndex + e).addClass(r); const o = t.params.thumbs.autoScrollOffset, a = o && !i.params.loop; if (t.realIndex !== i.realIndex || a) { let s, r, l = i.activeIndex; if (i.params.loop) { i.slides.eq(l).hasClass(i.params.slideDuplicateClass) && (i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft, l = i.activeIndex); const e = i.slides.eq(l).prevAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(), n = i.slides.eq(l).nextAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(); s = void 0 === e ? n : void 0 === n ? e : n - l == l - e ? i.params.slidesPerGroup > 1 ? n : l : n - l < l - e ? n : e, r = t.activeIndex > t.previousIndex ? "next" : "prev" } else s = t.realIndex, r = s > t.previousIndex ? "next" : "prev"; a && (s += "next" === r ? o : -1 * o), i.visibleSlidesIndexes && i.visibleSlidesIndexes.indexOf(s) < 0 && (i.params.centeredSlides ? s = s > l ? s - Math.floor(n / 2) + 1 : s + Math.floor(n / 2) - 1 : s > l && i.params.slidesPerGroup, i.slideTo(s, e ? 0 : void 0)) } } t.thumbs = { swiper: null }, n("beforeInit", (() => { const { thumbs: e } = t.params; e && e.swiper && (a(), l(!0)) })), n("slideChange update resize observerUpdate", (() => { l() })), n("setTransition", ((e, i) => { const n = t.thumbs.swiper; n && !n.destroyed && n.setTransition(i) })), n("beforeDestroy", (() => { const e = t.thumbs.swiper; e && !e.destroyed && r && e.destroy() })), Object.assign(t.thumbs, { init: a, update: l }) }, function (e) { let { swiper: t, extendParams: i, emit: n, once: s } = e; i({ freeMode: { enabled: !1, momentum: !0, momentumRatio: 1, momentumBounce: !0, momentumBounceRatio: 1, momentumVelocityRatio: 1, sticky: !1, minimumVelocity: .02 } }), Object.assign(t, { freeMode: { onTouchStart: function () { const e = t.getTranslate(); t.setTranslate(e), t.setTransition(0), t.touchEventsData.velocities.length = 0, t.freeMode.onTouchEnd({ currentPos: t.rtl ? t.translate : -t.translate }) }, onTouchMove: function () { const { touchEventsData: e, touches: i } = t; 0 === e.velocities.length && e.velocities.push({ position: i[t.isHorizontal() ? "startX" : "startY"], time: e.touchStartTime }), e.velocities.push({ position: i[t.isHorizontal() ? "currentX" : "currentY"], time: h() }) }, onTouchEnd: function (e) { let { currentPos: i } = e; const { params: r, $wrapperEl: o, rtlTranslate: a, snapGrid: l, touchEventsData: c } = t, d = h() - c.touchStartTime; if (i < -t.minTranslate()) t.slideTo(t.activeIndex); else if (i > -t.maxTranslate()) t.slides.length < l.length ? t.slideTo(l.length - 1) : t.slideTo(t.slides.length - 1); else { if (r.freeMode.momentum) { if (c.velocities.length > 1) { const e = c.velocities.pop(), i = c.velocities.pop(), n = e.position - i.position, s = e.time - i.time; t.velocity = n / s, t.velocity /= 2, Math.abs(t.velocity) < r.freeMode.minimumVelocity && (t.velocity = 0), (s > 150 || h() - e.time > 300) && (t.velocity = 0) } else t.velocity = 0; t.velocity *= r.freeMode.momentumVelocityRatio, c.velocities.length = 0; let e = 1e3 * r.freeMode.momentumRatio; const i = t.velocity * e; let d = t.translate + i; a && (d = -d); let u, p = !1; const f = 20 * Math.abs(t.velocity) * r.freeMode.momentumBounceRatio; let m; if (d < t.maxTranslate()) r.freeMode.momentumBounce ? (d + t.maxTranslate() < -f && (d = t.maxTranslate() - f), u = t.maxTranslate(), p = !0, c.allowMomentumBounce = !0) : d = t.maxTranslate(), r.loop && r.centeredSlides && (m = !0); else if (d > t.minTranslate()) r.freeMode.momentumBounce ? (d - t.minTranslate() > f && (d = t.minTranslate() + f), u = t.minTranslate(), p = !0, c.allowMomentumBounce = !0) : d = t.minTranslate(), r.loop && r.centeredSlides && (m = !0); else if (r.freeMode.sticky) { let e; for (let t = 0; t < l.length; t += 1)if (l[t] > -d) { e = t; break } d = Math.abs(l[e] - d) < Math.abs(l[e - 1] - d) || "next" === t.swipeDirection ? l[e] : l[e - 1], d = -d } if (m && s("transitionEnd", (() => { t.loopFix() })), 0 !== t.velocity) { if (e = a ? Math.abs((-d - t.translate) / t.velocity) : Math.abs((d - t.translate) / t.velocity), r.freeMode.sticky) { const i = Math.abs((a ? -d : d) - t.translate), n = t.slidesSizesGrid[t.activeIndex]; e = i < n ? r.speed : i < 2 * n ? 1.5 * r.speed : 2.5 * r.speed } } else if (r.freeMode.sticky) return void t.slideToClosest(); r.freeMode.momentumBounce && p ? (t.updateProgress(u), t.setTransition(e), t.setTranslate(d), t.transitionStart(!0, t.swipeDirection), t.animating = !0, o.transitionEnd((() => { t && !t.destroyed && c.allowMomentumBounce && (n("momentumBounce"), t.setTransition(r.speed), setTimeout((() => { t.setTranslate(u), o.transitionEnd((() => { t && !t.destroyed && t.transitionEnd() })) }), 0)) }))) : t.velocity ? (n("_freeModeNoMomentumRelease"), t.updateProgress(d), t.setTransition(e), t.setTranslate(d), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, o.transitionEnd((() => { t && !t.destroyed && t.transitionEnd() })))) : t.updateProgress(d), t.updateActiveIndex(), t.updateSlidesClasses() } else { if (r.freeMode.sticky) return void t.slideToClosest(); r.freeMode && n("_freeModeNoMomentumRelease") } (!r.freeMode.momentum || d >= r.longSwipesMs) && (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses()) } } } }) }, function (e) { let t, i, n, { swiper: s, extendParams: r } = e; r({ grid: { rows: 1, fill: "column" } }), s.grid = { initSlides: e => { const { slidesPerView: r } = s.params, { rows: o, fill: a } = s.params.grid; i = t / o, n = Math.floor(e / o), t = Math.floor(e / o) === e / o ? e : Math.ceil(e / o) * o, "auto" !== r && "row" === a && (t = Math.max(t, r * o)) }, updateSlide: (e, r, o, a) => { const { slidesPerGroup: l, spaceBetween: c } = s.params, { rows: d, fill: u } = s.params.grid; let h, p, f; if ("row" === u && l > 1) { const i = Math.floor(e / (l * d)), n = e - d * l * i, s = 0 === i ? l : Math.min(Math.ceil((o - i * d * l) / d), l); f = Math.floor(n / s), p = n - f * s + i * l, h = p + f * t / d, r.css({ "-webkit-order": h, order: h }) } else "column" === u ? (p = Math.floor(e / d), f = e - p * d, (p > n || p === n && f === d - 1) && (f += 1, f >= d && (f = 0, p += 1))) : (f = Math.floor(e / i), p = e - f * i); r.css(a("margin-top"), 0 !== f ? c && `${c}px` : "") }, updateWrapperSize: (e, i, n) => { const { spaceBetween: r, centeredSlides: o, roundLengths: a } = s.params, { rows: l } = s.params.grid; if (s.virtualSize = (e + r) * t, s.virtualSize = Math.ceil(s.virtualSize / l) - r, s.$wrapperEl.css({ [n("width")]: `${s.virtualSize + r}px` }), o) { i.splice(0, i.length); const e = []; for (let t = 0; t < i.length; t += 1) { let n = i[t]; a && (n = Math.floor(n)), i[t] < s.virtualSize + i[0] && e.push(n) } i.push(...e) } } } }, function (e) { let { swiper: t } = e; Object.assign(t, { appendSlide: Q.bind(t), prependSlide: K.bind(t), addSlide: Z.bind(t), removeSlide: J.bind(t), removeAllSlides: ee.bind(t) }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; i({ fadeEffect: { crossFade: !1, transformEl: null } }), te({ effect: "fade", swiper: t, on: n, setTranslate: () => { const { slides: e } = t, i = t.params.fadeEffect; for (let n = 0; n < e.length; n += 1) { const e = t.slides.eq(n); let s = -e[0].swiperSlideOffset; t.params.virtualTranslate || (s -= t.translate); let r = 0; t.isHorizontal() || (r = s, s = 0); const o = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(e[0].progress), 0) : 1 + Math.min(Math.max(e[0].progress, -1), 0); ie(i, e).css({ opacity: o }).transform(`translate3d(${s}px, ${r}px, 0px)`) } }, setTransition: e => { const { transformEl: i } = t.params.fadeEffect; (i ? t.slides.find(i) : t.slides).transition(e), ne({ swiper: t, duration: e, transformEl: i, allSlides: !0 }) }, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !t.params.cssMode }) }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; i({ cubeEffect: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94 } }); const s = (e, t, i) => { let n = i ? e.find(".swiper-slide-shadow-left") : e.find(".swiper-slide-shadow-top"), s = i ? e.find(".swiper-slide-shadow-right") : e.find(".swiper-slide-shadow-bottom"); 0 === n.length && (n = c(`<div class="swiper-slide-shadow-${i ? "left" : "top"}"></div>`), e.append(n)), 0 === s.length && (s = c(`<div class="swiper-slide-shadow-${i ? "right" : "bottom"}"></div>`), e.append(s)), n.length && (n[0].style.opacity = Math.max(-t, 0)), s.length && (s[0].style.opacity = Math.max(t, 0)) }; te({ effect: "cube", swiper: t, on: n, setTranslate: () => { const { $el: e, $wrapperEl: i, slides: n, width: r, height: o, rtlTranslate: a, size: l, browser: d } = t, u = t.params.cubeEffect, h = t.isHorizontal(), p = t.virtual && t.params.virtual.enabled; let f, m = 0; u.shadow && (h ? (f = i.find(".swiper-cube-shadow"), 0 === f.length && (f = c('<div class="swiper-cube-shadow"></div>'), i.append(f)), f.css({ height: `${r}px` })) : (f = e.find(".swiper-cube-shadow"), 0 === f.length && (f = c('<div class="swiper-cube-shadow"></div>'), e.append(f)))); for (let e = 0; e < n.length; e += 1) { const t = n.eq(e); let i = e; p && (i = parseInt(t.attr("data-swiper-slide-index"), 10)); let r = 90 * i, o = Math.floor(r / 360); a && (r = -r, o = Math.floor(-r / 360)); const c = Math.max(Math.min(t[0].progress, 1), -1); let d = 0, f = 0, g = 0; i % 4 == 0 ? (d = 4 * -o * l, g = 0) : (i - 1) % 4 == 0 ? (d = 0, g = 4 * -o * l) : (i - 2) % 4 == 0 ? (d = l + 4 * o * l, g = l) : (i - 3) % 4 == 0 && (d = -l, g = 3 * l + 4 * l * o), a && (d = -d), h || (f = d, d = 0); const v = `rotateX(${h ? 0 : -r}deg) rotateY(${h ? r : 0}deg) translate3d(${d}px, ${f}px, ${g}px)`; c <= 1 && c > -1 && (m = 90 * i + 90 * c, a && (m = 90 * -i - 90 * c)), t.transform(v), u.slideShadows && s(t, c, h) } if (i.css({ "-webkit-transform-origin": `50% 50% -${l / 2}px`, "transform-origin": `50% 50% -${l / 2}px` }), u.shadow) if (h) f.transform(`translate3d(0px, ${r / 2 + u.shadowOffset}px, ${-r / 2}px) rotateX(90deg) rotateZ(0deg) scale(${u.shadowScale})`); else { const e = Math.abs(m) - 90 * Math.floor(Math.abs(m) / 90), t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2), i = u.shadowScale, n = u.shadowScale / t, s = u.shadowOffset; f.transform(`scale3d(${i}, 1, ${n}) translate3d(0px, ${o / 2 + s}px, ${-o / 2 / n}px) rotateX(-90deg)`) } const g = d.isSafari || d.isWebView ? -l / 2 : 0; i.transform(`translate3d(0px,0,${g}px) rotateX(${t.isHorizontal() ? 0 : m}deg) rotateY(${t.isHorizontal() ? -m : 0}deg)`), i[0].style.setProperty("--swiper-cube-translate-z", `${g}px`) }, setTransition: e => { const { $el: i, slides: n } = t; n.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), t.params.cubeEffect.shadow && !t.isHorizontal() && i.find(".swiper-cube-shadow").transition(e) }, recreateShadows: () => { const e = t.isHorizontal(); t.slides.each((t => { const i = Math.max(Math.min(t.progress, 1), -1); s(c(t), i, e) })) }, getEffectParams: () => t.params.cubeEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0 }) }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; i({ flipEffect: { slideShadows: !0, limitRotation: !0, transformEl: null } }); const s = (e, i, n) => { let s = t.isHorizontal() ? e.find(".swiper-slide-shadow-left") : e.find(".swiper-slide-shadow-top"), r = t.isHorizontal() ? e.find(".swiper-slide-shadow-right") : e.find(".swiper-slide-shadow-bottom"); 0 === s.length && (s = se(n, e, t.isHorizontal() ? "left" : "top")), 0 === r.length && (r = se(n, e, t.isHorizontal() ? "right" : "bottom")), s.length && (s[0].style.opacity = Math.max(-i, 0)), r.length && (r[0].style.opacity = Math.max(i, 0)) }; te({ effect: "flip", swiper: t, on: n, setTranslate: () => { const { slides: e, rtlTranslate: i } = t, n = t.params.flipEffect; for (let r = 0; r < e.length; r += 1) { const o = e.eq(r); let a = o[0].progress; t.params.flipEffect.limitRotation && (a = Math.max(Math.min(o[0].progress, 1), -1)); const l = o[0].swiperSlideOffset; let c = -180 * a, d = 0, u = t.params.cssMode ? -l - t.translate : -l, h = 0; t.isHorizontal() ? i && (c = -c) : (h = u, u = 0, d = -c, c = 0), o[0].style.zIndex = -Math.abs(Math.round(a)) + e.length, n.slideShadows && s(o, a, n); const p = `translate3d(${u}px, ${h}px, 0px) rotateX(${d}deg) rotateY(${c}deg)`; ie(n, o).transform(p) } }, setTransition: e => { const { transformEl: i } = t.params.flipEffect; (i ? t.slides.find(i) : t.slides).transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), ne({ swiper: t, duration: e, transformEl: i }) }, recreateShadows: () => { const e = t.params.flipEffect; t.slides.each((i => { const n = c(i); let r = n[0].progress; t.params.flipEffect.limitRotation && (r = Math.max(Math.min(i.progress, 1), -1)), s(n, r, e) })) }, getEffectParams: () => t.params.flipEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !t.params.cssMode }) }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; i({ coverflowEffect: { rotate: 50, stretch: 0, depth: 100, scale: 1, modifier: 1, slideShadows: !0, transformEl: null } }), te({ effect: "coverflow", swiper: t, on: n, setTranslate: () => { const { width: e, height: i, slides: n, slidesSizesGrid: s } = t, r = t.params.coverflowEffect, o = t.isHorizontal(), a = t.translate, l = o ? e / 2 - a : i / 2 - a, c = o ? r.rotate : -r.rotate, d = r.depth; for (let e = 0, t = n.length; e < t; e += 1) { const t = n.eq(e), i = s[e], a = (l - t[0].swiperSlideOffset - i / 2) / i, u = "function" == typeof r.modifier ? r.modifier(a) : a * r.modifier; let h = o ? c * u : 0, p = o ? 0 : c * u, f = -d * Math.abs(u), m = r.stretch; "string" == typeof m && -1 !== m.indexOf("%") && (m = parseFloat(r.stretch) / 100 * i); let g = o ? 0 : m * u, v = o ? m * u : 0, y = 1 - (1 - r.scale) * Math.abs(u); Math.abs(v) < .001 && (v = 0), Math.abs(g) < .001 && (g = 0), Math.abs(f) < .001 && (f = 0), Math.abs(h) < .001 && (h = 0), Math.abs(p) < .001 && (p = 0), Math.abs(y) < .001 && (y = 0); const b = `translate3d(${v}px,${g}px,${f}px)  rotateX(${p}deg) rotateY(${h}deg) scale(${y})`; if (ie(r, t).transform(b), t[0].style.zIndex = 1 - Math.abs(Math.round(u)), r.slideShadows) { let e = o ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"), i = o ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom"); 0 === e.length && (e = se(r, t, o ? "left" : "top")), 0 === i.length && (i = se(r, t, o ? "right" : "bottom")), e.length && (e[0].style.opacity = u > 0 ? u : 0), i.length && (i[0].style.opacity = -u > 0 ? -u : 0) } } }, setTransition: e => { const { transformEl: i } = t.params.coverflowEffect; (i ? t.slides.find(i) : t.slides).transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0 }) }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; i({ creativeEffect: { transformEl: null, limitProgress: 1, shadowPerProgress: !1, progressMultiplier: 1, perspective: !0, prev: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 }, next: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 } } }); const s = e => "string" == typeof e ? e : `${e}px`; te({ effect: "creative", swiper: t, on: n, setTranslate: () => { const { slides: e, $wrapperEl: i, slidesSizesGrid: n } = t, r = t.params.creativeEffect, { progressMultiplier: o } = r, a = t.params.centeredSlides; if (a) { const e = n[0] / 2 - t.params.slidesOffsetBefore || 0; i.transform(`translateX(calc(50% - ${e}px))`) } for (let i = 0; i < e.length; i += 1) { const n = e.eq(i), l = n[0].progress, c = Math.min(Math.max(n[0].progress, -r.limitProgress), r.limitProgress); let d = c; a || (d = Math.min(Math.max(n[0].originalProgress, -r.limitProgress), r.limitProgress)); const u = n[0].swiperSlideOffset, h = [t.params.cssMode ? -u - t.translate : -u, 0, 0], p = [0, 0, 0]; let f = !1; t.isHorizontal() || (h[1] = h[0], h[0] = 0); let m = { translate: [0, 0, 0], rotate: [0, 0, 0], scale: 1, opacity: 1 }; c < 0 ? (m = r.next, f = !0) : c > 0 && (m = r.prev, f = !0), h.forEach(((e, t) => { h[t] = `calc(${e}px + (${s(m.translate[t])} * ${Math.abs(c * o)}))` })), p.forEach(((e, t) => { p[t] = m.rotate[t] * Math.abs(c * o) })), n[0].style.zIndex = -Math.abs(Math.round(l)) + e.length; const g = h.join(", "), v = `rotateX(${p[0]}deg) rotateY(${p[1]}deg) rotateZ(${p[2]}deg)`, y = d < 0 ? `scale(${1 + (1 - m.scale) * d * o})` : `scale(${1 - (1 - m.scale) * d * o})`, b = d < 0 ? 1 + (1 - m.opacity) * d * o : 1 - (1 - m.opacity) * d * o, w = `translate3d(${g}) ${v} ${y}`; if (f && m.shadow || !f) { let e = n.children(".swiper-slide-shadow"); if (0 === e.length && m.shadow && (e = se(r, n)), e.length) { const t = r.shadowPerProgress ? c * (1 / r.limitProgress) : c; e[0].style.opacity = Math.min(Math.max(Math.abs(t), 0), 1) } } const x = ie(r, n); x.transform(w).css({ opacity: b }), m.origin && x.css("transform-origin", m.origin) } }, setTransition: e => { const { transformEl: i } = t.params.creativeEffect; (i ? t.slides.find(i) : t.slides).transition(e).find(".swiper-slide-shadow").transition(e), ne({ swiper: t, duration: e, transformEl: i, allSlides: !0 }) }, perspective: () => t.params.creativeEffect.perspective, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !t.params.cssMode }) }) }, function (e) { let { swiper: t, extendParams: i, on: n } = e; i({ cardsEffect: { slideShadows: !0, transformEl: null, rotate: !0 } }), te({ effect: "cards", swiper: t, on: n, setTranslate: () => { const { slides: e, activeIndex: i } = t, n = t.params.cardsEffect, { startTranslate: s, isTouched: r } = t.touchEventsData, o = t.translate; for (let a = 0; a < e.length; a += 1) { const l = e.eq(a), c = l[0].progress, d = Math.min(Math.max(c, -4), 4); let u = l[0].swiperSlideOffset; t.params.centeredSlides && !t.params.cssMode && t.$wrapperEl.transform(`translateX(${t.minTranslate()}px)`), t.params.centeredSlides && t.params.cssMode && (u -= e[0].swiperSlideOffset); let h = t.params.cssMode ? -u - t.translate : -u, p = 0; const f = -100 * Math.abs(d); let m = 1, g = -2 * d, v = 8 - .75 * Math.abs(d); const y = t.virtual && t.params.virtual.enabled ? t.virtual.from + a : a, b = (y === i || y === i - 1) && d > 0 && d < 1 && (r || t.params.cssMode) && o < s, w = (y === i || y === i + 1) && d < 0 && d > -1 && (r || t.params.cssMode) && o > s; if (b || w) { const e = (1 - Math.abs((Math.abs(d) - .5) / .5)) ** .5; g += -28 * d * e, m += -.5 * e, v += 96 * e, p = -25 * e * Math.abs(d) + "%" } if (h = d < 0 ? `calc(${h}px + (${v * Math.abs(d)}%))` : d > 0 ? `calc(${h}px + (-${v * Math.abs(d)}%))` : `${h}px`, !t.isHorizontal()) { const e = p; p = h, h = e } const x = d < 0 ? "" + (1 + (1 - m) * d) : "" + (1 - (1 - m) * d), _ = `\n        translate3d(${h}, ${p}, ${f}px)\n        rotateZ(${n.rotate ? g : 0}deg)\n        scale(${x})\n      `; if (n.slideShadows) { let e = l.find(".swiper-slide-shadow"); 0 === e.length && (e = se(n, l)), e.length && (e[0].style.opacity = Math.min(Math.max((Math.abs(d) - .5) / .5, 0), 1)) } l[0].style.zIndex = -Math.abs(Math.round(c)) + e.length, ie(n, l).transform(_) } }, setTransition: e => { const { transformEl: i } = t.params.cardsEffect; (i ? t.slides.find(i) : t.slides).transition(e).find(".swiper-slide-shadow").transition(e), ne({ swiper: t, duration: e, transformEl: i }) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !t.params.cssMode }) }) }]; return V.use(re), V }));
/*!
 * Typer.js v0.1.0
 * https://unpkg.com/typer-dot-js@0.1.0/typer.js
 */
var Typer = function (e) { this.element = e; var t = e.dataset.delim || ",", i = e.dataset.words || "override these,sample typing"; this.words = i.split(t).filter((e => e)), this.delayVariance = parseInt(e.dataset.delayVariance) || 0, this.delay = parseInt(e.dataset.delay) || 200, this.loop = e.dataset.loop || "true", "false" === this.loop && (this.loop = 1), this.deleteDelay = e.dataset.deletedelay || e.dataset.deleteDelay || 800, this.progress = { word: 0, char: 0, building: !0, looped: 0 }, this.typing = !0; var n = e.dataset.colors || "black"; this.colors = n.split(","), this.element.style.color = this.colors[0], this.colorIndex = 0, this.doTyping() }; Typer.prototype.start = function () { this.typing || (this.typing = !0, this.doTyping()) }, Typer.prototype.stop = function () { this.typing = !1 }, Typer.prototype.doTyping = function () { var e, t = this.element, i = this.progress, n = i.word, s = i.char, r = [...this.words[n]].slice(0, s).join(""), o = (2 * Math.random() - 1) * this.delayVariance + this.delay; this.cursor && (this.cursor.element.style.opacity = "1", this.cursor.on = !0, clearInterval(this.cursor.interval), this.cursor.interval = setInterval((() => this.cursor.updateBlinkState()), 400)), t.innerHTML = r, i.building ? (e = i.char === this.words[n].length) ? i.building = !1 : i.char += 1 : 0 === i.char ? (i.building = !0, i.word = (i.word + 1) % this.words.length, this.colorIndex = (this.colorIndex + 1) % this.colors.length, this.element.style.color = this.colors[this.colorIndex]) : i.char -= 1, i.word === this.words.length - 1 && (i.looped += 1), !i.building && this.loop <= i.looped && (this.typing = !1), setTimeout((() => { this.typing && this.doTyping() }), e ? this.deleteDelay : o) }; var Cursor = function (e) { this.element = e, this.cursorDisplay = e.dataset.cursordisplay || e.dataset.cursorDisplay || "|", e.innerHTML = this.cursorDisplay, this.on = !0, e.style.transition = "all 0.1s", this.interval = setInterval((() => this.updateBlinkState()), 400) }; function TyperSetup() { var e = {}; for (let t of document.getElementsByClassName("typer")) e[t.id] = new Typer(t); for (let t of document.getElementsByClassName("typer-stop")) { let i = e[t.dataset.owner]; t.onclick = () => i.stop() } for (let t of document.getElementsByClassName("typer-start")) { let i = e[t.dataset.owner]; t.onclick = () => i.start() } for (let t of document.getElementsByClassName("cursor")) { new Cursor(t).owner = e[t.dataset.owner] } } Cursor.prototype.updateBlinkState = function () { this.on ? (this.element.style.opacity = "0", this.on = !1) : (this.element.style.opacity = "1", this.on = !0) }, TyperSetup();